{"version":3,"sources":["webpack:///dist/aloetouch.min.js","webpack:///webpack/bootstrap 21406633ef3b9c04283b","webpack:///./src/services/Utils.js","webpack:///./src/services/constants.js","webpack:///./src/classes/AloeTouchObject.js","webpack:///./src/classes/Dispatcher.js","webpack:///./src/classes/Emitter.js","webpack:///./src/classes/State.js","webpack:///./src/services/Events.js","webpack:///./src/AloeTouch.js"],"names":["exports","modules","__webpack_require__","moduleId","installedModules","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","getTouches","event","element","strict","data","touches","e","keys","forEach","validate","push","screenX","screenY","touch","target","contains","coords","ATOstart","ATOend","diff","pointA","pointB","x","y","fingers","ATO","length","isVertical","_coords","Math","abs","isHorizontal","stringDirection","velocity","duration","time","scalar","distanceBetween","distance","a","b","sqrt","pow","direction","angle","atan2","PI","rotation","ALOETOUCH_MIN_TIME","ALOETOUCH_PRESS_MIN_TIME","ALOETOUCH_MIN_SWIPE_DISTANCE","ALOETOUCH_DBL_TAP_TIME","_interopRequireDefault","obj","default","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","props","descriptor","writable","key","protoProps","staticProps","_constants","_Utils","_Dispatcher","_Dispatcher2","DEFAULT_SETTINGS","stopPropagation","isPermissible","onlyX","onlyY","AloeTouchObject","id","events","settings","this","el","document","querySelector","assign","locked","public","getPublicMethods","Dispatcher","start","bind","move","finish","unlock","style","willChange","isStarted","end","preventDefault","stopImmediatePropagation","dispatch","clear","_this","started","ended","Date","now","_isHorizontal","_isVertical","cancelable","off","on","handler","passive","_this2","split","addEventListener","_this3","removeEventListener","ato","$id","attach","Emitter","detach","getState","State","clearState","addState","state","add","removeState","remove","lock","isLock","$ref","_Emitter","_Emitter2","lastTap","_fingers","prepare","emitAfter","emit","final","dispatchFinalEvents","dispatchMovedEvents","dispatchSwipe","dispatchTap","clearAfter","refresh","_Events","_Events2","_State","_State2","initialData","after","eventName","delay","callback","window","setTimeout","clearTimeout","setStateData","$state","pan","pinch","rotate","set","_this4","constructor","_typeof","Symbol","iterator","customState","old","empty","values","cs","copy","k","nativeEvent","indexOf","$event","isSwipe","directions","tap","dbltap","press","swipe","swipeLeft","swipeRight","swipeTop","swipeBottom","pan2","_AloeTouchObject","_AloeTouchObject2","AloeTouch","version","increment","list","setAttribute","unbind","aloetouchobject","nodeType","getAttribute","getIds","aloetouchobjects","first","map","filter","lockExcept","ids","lockOnly","unlockExcept","unlockOnly","callable"],"mappings":"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","file":"./dist/aloetouch.min.js","sourcesContent":["exports[\"AloeTouch\"] =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getTouches = getTouches;\nexports.validate = validate;\nexports.coords = coords;\nexports.diff = diff;\nexports.fingers = fingers;\nexports.isVertical = isVertical;\nexports.isHorizontal = isHorizontal;\nexports.stringDirection = stringDirection;\nexports.velocity = velocity;\nexports.distanceBetween = distanceBetween;\nexports.distance = distance;\nexports.scalar = scalar;\nexports.direction = direction;\nexports.angle = angle;\nexports.rotation = rotation;\n/**\n * Preleva la touchlist (modificata) dall'evento\n *\n * @param  {Touchlist}  touches [description]\n * @param  {DOMElement} element L'emento esiste solo se è settato STRICT\n * @param  {Boolean}    strict\n * @return {Array}\n */\nfunction getTouches(event, element, strict) {\n\n    var data = [];\n    var touches = event.touches ? event.touches : { 'e': event };\n\n    Object.keys(touches).forEach(function (e) {\n        validate(touches[e], element, strict) && data.push({\n            screenX: touches[e].screenX,\n            screenY: touches[e].screenY\n        });\n    });\n\n    return data;\n}\n\n/**\n * Aggiunge l'oggetto Touch se rispetta la validazone\n *\n * @param {Touch}      touch\n * @param {DOMElement} element\n * @param {Boolean}    strict\n */\nfunction validate(touch, element, strict) {\n    return touch && (touch.screenX || touch.screenY) && (!strict ? element.contains(touch.target) : element == touch.target);\n}\n\n/**\n * Ritorna la differenza delle coordinate tra due ATO\n *\n * @param {ATO} ATOstart\n * @param {ATO} ATOend\n */\nfunction coords(ATOstart, ATOend) {\n    return diff(ATOstart.touches[0], ATOend.touches[0]);\n}\n\n/**\n * Ritorna una coordinata basata sulla differenza tra due punti\n *\n * @param {ATO.touch} pointA\n * @param {ATO.touch} pointB\n */\nfunction diff(pointA, pointB) {\n    return {\n        x: pointB.screenX - pointA.screenX,\n        y: pointB.screenY - pointA.screenY\n    };\n}\n\n/**\n * Ritorna il numero di touch\n *\n * @param {ATO} ATOe\n */\nfunction fingers(ATO) {\n    return ATO && ATO.touches ? ATO.touches.length : 0;\n}\n\n/**\n * Ritorna true se la differenza tra le coordinate è principalmente verticale\n *\n * @param {ATO} ATOstart\n * @param {ATO} ATOend\n */\nfunction isVertical(ATOstart, ATOend) {\n    var _coords = coords(ATOstart, ATOend);\n    return Math.abs(_coords.y) > Math.abs(_coords.x);\n}\n\n/**\n * Ritorna true se la differenza tra le coordinate è principalmente orizzontale\n *\n * @param {ATO} ATOstart\n * @param {ATO} ATOend\n */\nfunction isHorizontal(ATOstart, ATOend) {\n    var _coords = coords(ATOstart, ATOend);\n    return Math.abs(_coords.x) > Math.abs(_coords.y);\n}\n\n/**\n * Ritorna la direzione in base al valore delle coordinate\n *\n * @param {Object{x,y} } coords\n */\nfunction stringDirection(_coords) {\n    return {\n        x: _coords.x <= 0 ? 'Left' : 'Right',\n        y: _coords.y <= 0 ? 'Top' : 'Bottom'\n    };\n}\n\nfunction velocity(ATOstart, ATOend) {\n    var _coords = coords(ATOstart, ATOend);\n    var duration = (ATOend.time - ATOstart.time) / 1000;\n\n    return {\n        x: _coords.x / duration,\n        y: _coords.y / duration,\n        d: scalar(_coords.x, _coords.y) / duration\n    };\n}\n\n/**\n * Ritorna la distanza tra due ATO\n *\n * @param {ATO} ATOstart\n * @param {ATO} ATOend\n */\nfunction distanceBetween(ATOstart, ATOend) {\n    return distance(ATOend) - distance(ATOstart);\n}\n\n/**\n * Ritorna la distanza vettoriale tra due coordinata\n *\n * @param {ATO} ATO\n */\nfunction distance(ATO) {\n    var distance = diff(ATO.touches[0], ATO.touches[1]);\n    return scalar(distance.x, distance.y);\n}\n\n/**\n * Distanza scalare\n */\nfunction scalar(a, b) {\n    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n}\n\n/**\n * Ritorna la direzione tangente tra due coordinate\n *\n * @param {ATO} ATO\n */\nfunction direction(ATO) {\n    var distance = diff(ATO.touches[0], ATO.touches[1]);\n    return angle(distance.x, distance.y);\n}\n\n/**\n * Angolo\n */\nfunction angle(a, b) {\n    return Math.atan2(b, a) * 180 / Math.PI;\n}\n\n/**\n * Ritorna l'angolo di rotazione tra due ATO\n *\n * @param {ATO} ATOstart\n * @param {ATO} ATOend\n */\nfunction rotation(ATOstart, ATOend) {\n    return direction(ATOend) - direction(ATOstart);\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * La durata minimina per bindare un evento\n * Utile a non prevenire lo scrolling\n * @type {Number}\n */\nvar ALOETOUCH_MIN_TIME = exports.ALOETOUCH_MIN_TIME = 100;\n\n/**\n * Tempo minimo per bindare l'evento press\n * @type {Number}\n */\nvar ALOETOUCH_PRESS_MIN_TIME = exports.ALOETOUCH_PRESS_MIN_TIME = 600;\n\n/**\n * Distanza minima per bindare l'evento swipe[Direction]\n * @type {Number}\n */\nvar ALOETOUCH_MIN_SWIPE_DISTANCE = exports.ALOETOUCH_MIN_SWIPE_DISTANCE = 60;\n\n/**\n * Distanza tra due Tap per bindare l'evento Double Tap\n * @type {Number}\n */\nvar ALOETOUCH_DBL_TAP_TIME = exports.ALOETOUCH_DBL_TAP_TIME = 200;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _constants = __webpack_require__(1);\n\nvar _Utils = __webpack_require__(0);\n\nvar _Dispatcher = __webpack_require__(3);\n\nvar _Dispatcher2 = _interopRequireDefault(_Dispatcher);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Settaggi di default\n * @type Object\n */\nvar DEFAULT_SETTINGS = {\n    strict: false,\n    stopPropagation: false,\n    isPermissible: null,\n    onlyX: false,\n    onlyY: false\n};\n\n/**\n * Assegna gli eventi touch ad un elemento\n *\n * GLi eventi disponibili sono:\n * Touch singolo\n *     tap, dbltap, press, pan, swipe, swipeLeft, swipeRight, swipeTop, swipeBottom\n * Touch doppio\n *     pan2, pinch, rotate\n */\n\nvar AloeTouchObject = function () {\n\n    /**\n     * Binda gli eventi all'elemento\n     * @param {DomElement} element\n     * @param {Object} events Oggetto che contiene le funzioni es. { tap: ..., swipeLeft: ..., rotate: ... }\n     * @param {Object<Boolean>} strict\n     */\n    function AloeTouchObject(id, element, events, settings) {\n        _classCallCheck(this, AloeTouchObject);\n\n        this.id = id;\n        this.el = typeof element === 'string' ? document.querySelector(element) : element;\n        this.settings = Object.assign({}, DEFAULT_SETTINGS, settings);\n\n        this.locked = true;\n\n        this.public = this.getPublicMethods();\n\n        this.Dispatcher = new _Dispatcher2.default(id, this.el, events, this.public);\n\n        this.start = this.start.bind(this);\n        this.move = this.move.bind(this);\n        this.finish = this.finish.bind(this);\n\n        this.unlock();\n\n        this.el.style.willChange = 'transform';\n    }\n\n    /**\n     * Eventi 'touchstart' 'mousedown'\n     */\n\n\n    _createClass(AloeTouchObject, [{\n        key: 'start',\n        value: function start(event) {\n            !this.locked && this.Dispatcher.start(event, (0, _Utils.getTouches)(event, this.el, this.settings.strict), this.settings.stopPropagation);\n        }\n\n        /**\n         * Eventi 'touchmove'\n         */\n\n    }, {\n        key: 'move',\n        value: function move(event) {\n            if (!this.locked && this.Dispatcher.isStarted() && this.Dispatcher.end(event, (0, _Utils.getTouches)(event, this.el, this.settings.strict)) && this.isPermissible(event)) {\n                event.preventDefault();\n                if (this.settings.stopPropagation === true || this.settings.stopPropagation === 1) event.stopPropagation();\n                if (this.settings.stopPropagation === true || this.settings.stopPropagation === 2) event.stopImmediatePropagation();\n\n                this.Dispatcher.dispatch(null, event);\n            } else {\n                this.Dispatcher.clear();\n            }\n        }\n\n        /**\n         * Questa funzionalitò è molto importante poiché previene che l'evento 'touchmove'\n         * prevenga l'azione di default dell'evento (e quindi blocchi lo scrolling)\n         */\n\n    }, {\n        key: 'isPermissible',\n        value: function isPermissible(event) {\n            var _this = this;\n\n            return this.settings.isPermissible ? this.settings.isPermissible(event, (0, _Utils.coords)(this.Dispatcher.started, this.Dispatcher.ended), this.Dispatcher.started, this.Dispatcher.ended) : function () {\n                var time = Date.now() - _this.Dispatcher.started.time;\n                var _isHorizontal = (0, _Utils.isHorizontal)(_this.Dispatcher.started, _this.Dispatcher.ended);\n                var _isVertical = (0, _Utils.isVertical)(_this.Dispatcher.started, _this.Dispatcher.ended);\n\n                return event.cancelable && (!_this.settings.onlyX && !_this.settings.onlyY && time > _constants.ALOETOUCH_MIN_TIME || _isHorizontal || _this.settings.onlyX && _isHorizontal || _this.settings.onlyY && _isVertical);\n            };\n        }\n\n        /**\n         * Termino l'evento\n         */\n\n    }, {\n        key: 'finish',\n        value: function finish(event) {\n            if (!this.locked && this.Dispatcher.isStarted()) {\n                this.Dispatcher.dispatch(true, event);\n\n                if (this.settings.stopPropagation) {\n                    event.stopPropagation();\n                    event.stopImmediatePropagation();\n                }\n            }\n        }\n\n        /**\n         * Ritorna vero se questo oggetto è bloccato, falso altrimenti\n         *\n         * @return {Boolean}\n         */\n\n    }, {\n        key: 'isLock',\n        value: function isLock() {\n            return this.locked;\n        }\n\n        /**\n         * Rimuove i listener degli eventi\n         */\n\n    }, {\n        key: 'lock',\n        value: function lock() {\n            if (!this.locked) {\n                this.off('touchstart', this.start, true);\n                this.off('touchmove', this.move);\n                this.off('touchend touchcancel', this.finish, true);\n                this.locked = true;\n            }\n        }\n\n        /**\n         * Binda gli eventi\n         */\n\n    }, {\n        key: 'unlock',\n        value: function unlock() {\n            if (this.locked) {\n                this.on('touchstart', this.start, true);\n                this.on('touchmove', this.move);\n                this.on('touchend touchleave touchcancel', this.finish, true);\n                this.locked = false;\n            }\n        }\n\n        /**\n         * Bindo gli eventi all'elemento\n         */\n\n    }, {\n        key: 'on',\n        value: function on(events, handler, passive) {\n            var _this2 = this;\n\n            events.split(' ').forEach(function (e) {\n                return _this2.el.addEventListener(e, handler, passive ? { passive: true } : true);\n            });\n        }\n\n        /**\n         * Rimuovo i listeners\n         */\n\n    }, {\n        key: 'off',\n        value: function off(events, handler) {\n            var _this3 = this;\n\n            events.split(' ').forEach(function (e) {\n                return _this3.el.removeEventListener(e, handler, true);\n            });\n        }\n\n        /**\n         * Helper per una chiamata più semplice alle funzioni\n         */\n\n    }, {\n        key: 'getPublicMethods',\n        value: function getPublicMethods() {\n            var ato = this;\n\n            return {\n                el: this.el,\n                $id: this.id,\n\n                attach: function attach(events) {\n                    ato.Dispatcher.Emitter.attach(events);\n                },\n                detach: function detach(events) {\n                    ato.Dispatcher.Emitter.detach(events);\n                },\n                getState: function getState() {\n                    ato.Dispatcher.Emitter.State.get();\n                },\n                clearState: function clearState() {\n                    ato.Dispatcher.Emitter.State.clear();\n                },\n                addState: function addState(state) {\n                    ato.Dispatcher.Emitter.State.add(state);\n                },\n                removeState: function removeState(name) {\n                    ato.Dispatcher.Emitter.State.remove(name);\n                },\n                lock: function lock() {\n                    ato.lock();\n                },\n                unlock: function unlock() {\n                    ato.unlock();\n                },\n                isLock: function isLock() {\n                    return ato.isLock();\n                },\n\n\n                $ref: this\n            };\n        }\n    }]);\n\n    return AloeTouchObject;\n}();\n\nexports.default = AloeTouchObject;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _constants = __webpack_require__(1);\n\nvar _Utils = __webpack_require__(0);\n\nvar _Emitter = __webpack_require__(4);\n\nvar _Emitter2 = _interopRequireDefault(_Emitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dispatcher - smistare gli eventi\n */\nvar Dispatcher = function () {\n\n    /**\n     * Binda l'Emtitter che chiamerà gli eventi\n     */\n    function Dispatcher(id, element, events, ato) {\n        _classCallCheck(this, Dispatcher);\n\n        this.Emitter = new _Emitter2.default(id, element, events || {}, ato);\n        this.started = null;\n        this.ended = null;\n        this.lastTap = null;\n    }\n\n    /**\n     * Setta l'evento iniziale\n     * Binderà l'evento press nel caso in cui l'utente non rilascerà o muoverà l'elemento\n     */\n\n\n    _createClass(Dispatcher, [{\n        key: 'start',\n        value: function start(event, touches, stopPropagation) {\n            if (!event.cancelable) return this.clear();\n\n            !this.started ? this.started = { time: Date.now(), touches: touches } : this.started.touches = touches;\n\n            var _fingers = (0, _Utils.fingers)(this.started);\n\n            if (_fingers) {\n                this.Emitter.prepare(this.started);\n                this.Emitter.emitAfter('press', _constants.ALOETOUCH_PRESS_MIN_TIME);\n                this.Emitter.emit('start', event);\n\n                if (_fingers > 1) {\n                    event.preventDefault(); // Blocca lo scrolling nel caso in cui l'utente abbia toccato l'elemento con più di un dito\n\n                    if (stopPropagation) {\n                        if (stopPropagation === true || stopPropagation === 1) event.stopPropagation();\n                        if (stopPropagation === true || stopPropagation === 2) event.stopImmediatePropagation();\n                    }\n                }\n            }\n        }\n\n        /**\n         * Ritorna vero se l'evento è stato inizializzato correttamente\n         */\n\n    }, {\n        key: 'isStarted',\n        value: function isStarted() {\n            return !!this.started;\n        }\n\n        /**\n         * Setta il punto corrente ( richiamato dalla gestore dell'evento touchmove: AloeTouchObject@move )\n         */\n\n    }, {\n        key: 'end',\n        value: function end(event, touches) {\n            this.ended = { time: Date.now(), touches: touches };\n\n            return (0, _Utils.fingers)(this.started) == (0, _Utils.fingers)(this.ended);\n        }\n\n        /**\n         * Smisto gli eventi in 'touchmove' in base al numero di tocchi in base alla tipologia dell'evento\n         *\n         * @param {Boolean} final Questo valore è settato a true se questa funzione è chiamanta dall'evento touchend o touchcancel\n         * @param {Event} \n         */\n\n    }, {\n        key: 'dispatch',\n        value: function dispatch(final, event) {\n            var _fingers = (0, _Utils.fingers)(this.ended);\n\n            this.Emitter.prepare(this.started, this.ended, _fingers, !!final);\n\n            final ? this.dispatchFinalEvents(!!this.ended, event) : this.dispatchMovedEvents(_fingers, event); // Smisto al tipo di eventi\n        }\n\n        /**\n         * Gestione degli eventi che non richiedono movimento\n         */\n\n    }, {\n        key: 'dispatchFinalEvents',\n        value: function dispatchFinalEvents(move, event) {\n            move ? this.dispatchSwipe(event) : this.dispatchTap(event);\n            this.Emitter.emit('end', event);\n            this.clear();\n        }\n\n        /**\n         * Gestione degli eventi con movimento\n         */\n\n    }, {\n        key: 'dispatchMovedEvents',\n        value: function dispatchMovedEvents(_fingers, event) {\n            this.Emitter.clearAfter('press'); // l'evento press non è più valido se l'utente si muove sull'elemento\n\n            // Smisto gli eventi in base al numero dei tocchi\n            if (_fingers == 1) this.Emitter.emit('pan', event);else if (_fingers == 2) {\n                this.Emitter.emit('pan2', event);\n                this.Emitter.emit('pinch', event);\n                this.Emitter.emit('rotate', event);\n            }\n\n            this.Emitter.emit('move', event); // Chiamo l'evento speciale 'move' in ogni caso\n        }\n\n        /**\n         * Gestione dell'evento particolare 'tap' e 'dbltap'\n         */\n\n    }, {\n        key: 'dispatchTap',\n        value: function dispatchTap(event) {\n            var _this = this;\n\n            if (!this.lastTap) {\n                this.lastTap = this.started.time;\n                this.Emitter.emitAfter('tap', _constants.ALOETOUCH_DBL_TAP_TIME, function () {\n                    return _this.lastTap = null;\n                });\n            } else if (this.started.time - this.lastTap < _constants.ALOETOUCH_DBL_TAP_TIME) {\n                this.Emitter.clearAfter('tap');\n                this.Emitter.emit('dbltap', event);\n                this.lastTap = null;\n            }\n        }\n\n        /**\n         * Gestione dell'evento 'swipe'\n         */\n\n    }, {\n        key: 'dispatchSwipe',\n        value: function dispatchSwipe(event) {\n            this.Emitter.emit('swipe', event);\n            this.Emitter.emit('swipeLeft', event);\n            this.Emitter.emit('swipeRight', event);\n            this.Emitter.emit('swipeTop', event);\n            this.Emitter.emit('swipeBottom', event);\n        }\n\n        /**\n         * Reset delle variabili\n         */\n\n    }, {\n        key: 'clear',\n        value: function clear() {\n            this.started = null;\n            this.ended = null;\n\n            this.Emitter.clearAfter('press');\n            this.Emitter.State.refresh();\n        }\n    }]);\n\n    return Dispatcher;\n}();\n\nexports.default = Dispatcher;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Utils = __webpack_require__(0);\n\nvar _Events = __webpack_require__(6);\n\nvar _Events2 = _interopRequireDefault(_Events);\n\nvar _State = __webpack_require__(5);\n\nvar _State2 = _interopRequireDefault(_State);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* -------------------------------------\n *  Bindaggio ed emissione eventi\n * ------------------------------------- */\n\nvar Emitter = function () {\n\n    /**\n     * Gestore degli eventi e relativi argomenti\n     */\n    function Emitter(id, el, events, ato) {\n        _classCallCheck(this, Emitter);\n\n        this.ato = ato;\n        this.events = events;\n        this.State = new _State2.default(events.state || {});\n\n        this.initialData = { id: id, el: el, ato: ato };\n        this.after = {};\n\n        this.detach('state');\n    }\n\n    /**\n     * Emette un evento se settato\n     *\n     * @param {String} eventName Nome dell'evento da emettere\n     * @param {Event} event\n     */\n\n\n    _createClass(Emitter, [{\n        key: 'emit',\n        value: function emit(eventName, event) {\n            if (_Events2.default.emit(eventName, this.data, this.events[eventName], event) === false) this.detach(eventName);\n        }\n\n        /**\n         * Emette un evento dopo un certo 'delay'\n         *\n         * @param {String}     event Nome dell'evento da emettere\n         * @param {Int}        delay Millisecondi da ritardare\n         * @param {Callable?}  callback Funzione da chiamare dopo il delay\n         */\n\n    }, {\n        key: 'emitAfter',\n        value: function emitAfter(event, delay, callback) {\n            var _this = this;\n\n            this.clearAfter(event);\n\n            this.after[event] = window.setTimeout(function () {\n                _this.emit(event);\n                callback && callback();\n            }, delay);\n        }\n\n        /**\n         * Rimuove un evento da ritardare\n         *\n         * @param {String?} event Nome dell'evento da rimuovere. Se non settato, verranno rimossi tutti.\n         */\n\n    }, {\n        key: 'clearAfter',\n        value: function clearAfter(event) {\n            var _this2 = this;\n\n            if (typeof event === 'undefined') Object.keys(this.after).forEach(function (e) {\n                return _this2.clearAfter(e);\n            });else {\n                this.after[event] && window.clearTimeout(this.after[event]);\n                this.after[event] = null;\n                delete this.after[event];\n            }\n        }\n\n        /**\n         * Prepare i dati da inviare agli eventi\n         */\n\n    }, {\n        key: 'prepare',\n        value: function prepare(started, ended, fingers, final) {\n            this.data = Object.assign({}, this.initialData, { started: started, ended: ended, fingers: fingers, final: final });\n\n            this.setStateData(started, ended, fingers, final); // Setta lo state se si sta 'preparando' un evento non finale\n\n            this.data.$state = this.State.get();\n        }\n\n        /**\n         * Prepara la variabile che conterrà lo 'state'\n         */\n\n    }, {\n        key: 'setStateData',\n        value: function setStateData(started, ended, fingers, final) {\n            if (fingers == 1) this.data.pan = (0, _Utils.coords)(started, ended);else if (fingers == 2) {\n                this.data.pan = (0, _Utils.coords)(started, ended);\n                this.data.pinch = (0, _Utils.distanceBetween)(started, ended);\n                this.data.rotate = (0, _Utils.rotation)(started, ended);\n            }\n            !final && this.State.set(this.data);\n        }\n\n        /**\n         * Aggiunge un evento\n         */\n\n    }, {\n        key: 'attach',\n        value: function attach(events) {\n            var _this3 = this;\n\n            Object.keys(events).forEach(function (e) {\n                return _this3.events[e] = events[e];\n            });\n        }\n\n        /**\n         * Rimuove un evento\n         */\n\n    }, {\n        key: 'detach',\n        value: function detach(events) {\n            var _this4 = this;\n\n            events = events.constructor.name === 'Array' ? events : [events];\n            events.forEach(function (e) {\n                return _this4.events[e] && delete _this4.events[e];\n            });\n        }\n    }]);\n\n    return Emitter;\n}();\n\nexports.default = Emitter;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* -------------------------------------\n *  State\n * ------------------------------------- */\n\nvar State = function () {\n\n    /**\n     * Setta gli state personalizzati\n     */\n    function State(customState) {\n        _classCallCheck(this, State);\n\n        this.customState = customState;\n\n        this.old = this.empty();\n        this.values = this.empty();\n    }\n\n    /**\n     * Ritorna uno state vuoto\n     * @return {Object}\n     */\n\n\n    _createClass(State, [{\n        key: 'empty',\n        value: function empty() {\n            return {\n                pan: { x: 0, y: 0 },\n                pinch: 0,\n                rotate: 0\n            };\n        }\n\n        /**\n         * Binda i nuovi valori dall'evento corrente (chiamato da touchmove->dispatch->emit) con i valori precendenti\n         *\n         * @param {ATS} state\n         * @param {ATEvent} event\n         */\n\n    }, {\n        key: 'set',\n        value: function set(data) {\n            var _this = this;\n\n            data.rotate && (this.values.rotate = data.rotate + this.old.rotate);\n            data.pinch && (this.values.pinch = data.pinch + this.old.pinch);\n            data.pan && data.pan.x && (this.values.pan.x = data.pan.x + this.old.pan.x);\n            data.pan && data.pan.y && (this.values.pan.y = data.pan.y + this.old.pan.y);\n\n            // Aggiungo gli state settati dall'utente\n            Object.keys(this.customState).forEach(function (cs) {\n                return _this.values[cs] = _this.customState[cs](_this.values);\n            });\n\n            return this.get();\n        }\n\n        /**\n         * Ritorna i valori dello state corrente\n         */\n\n    }, {\n        key: 'get',\n        value: function get() {\n            return this.values;\n        }\n\n        /**\n         * All'evento touchend setto i valori precendeti con l'ultimo settato\n         *\n         * @param {ATS} state\n         */\n\n    }, {\n        key: 'refresh',\n        value: function refresh() {\n            this.old = this.copy(this.values);\n        }\n\n        /**\n         * Copia un oggetto\n         *\n         * @return {Object}\n         */\n\n    }, {\n        key: 'copy',\n        value: function copy(d) {\n            var _this2 = this;\n\n            var n = {};\n            Object.keys(d).forEach(function (k) {\n                n[k] = _typeof(d[k]) === 'object' && d[k] !== null ? _this2.copy(d[k]) : d[k];\n            });\n            return n;\n        }\n\n        /**\n         * Setta uno state\n         *\n         * @param {Object} state\n         */\n\n    }, {\n        key: 'add',\n        value: function add(state) {\n            var _this3 = this;\n\n            Object.keys(state).forEach(function (s) {\n                return _this3.customState[s] = state[s];\n            });\n            this.set({});\n        }\n\n        /**\n         * Rimuove uno state\n         *\n         * @param {String} name Nome dello state da rimuovere\n         */\n\n    }, {\n        key: 'remove',\n        value: function remove(name) {\n            this.values[name] = null;\n            this.values[name] = null;\n\n            delete this.values[name];\n            delete this.values[name];\n        }\n\n        /**\n         * Cancella lo state con ivalori correnti\n         */\n\n    }, {\n        key: 'clear',\n        value: function clear() {\n            this.values = this.empty();\n            this.old = this.empty();\n        }\n    }]);\n\n    return State;\n}();\n\nexports.default = State;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _constants = __webpack_require__(1);\n\nvar _Utils = __webpack_require__(0);\n\n/* -------------------------------------\n *  Eventi\n * ------------------------------------- */\n\n/**\n * Lista di tutti gli eventi gestibili\n * @type {Array<String>}\n */\nvar events = ['start', 'move', 'end', // Eventi speciali\n'tap', 'dbltap', 'press', 'swipe', 'swipeTop', 'swipeBottom', 'swipeLeft', 'swipeRight', 'pan', // Eventi un solo dito\n'pan2', 'pinch', 'rotate' // Eventi due dita\n];\n\nexports.default = {\n\n  /**\n   * Richiama gli altri eventi\n   */\n  emit: function emit(event, values, callback, nativeEvent) {\n    if (events.indexOf(event) >= 0 && this[event] && callback) {\n      values.$event = nativeEvent;\n      return this[event](values, callback);\n    }\n  },\n\n\n  /**\n   * Special Event\n   */\n  start: function start(values, callback) {\n    return callback(values);\n  },\n\n\n  /**\n   * Special Event\n   */\n  move: function move(values, callback) {\n    return callback(values);\n  },\n\n\n  /**\n   * Special Event\n   */\n  end: function end(values, callback) {\n    var coords = values.pan;\n\n    if (coords) {\n      values.isSwipe = false;\n      var directions = (0, _Utils.stringDirection)(coords);\n\n      if (Math.abs(coords.x) > _constants.ALOETOUCH_MIN_SWIPE_DISTANCE) {\n        values.isSwipe = true;\n        values.directions ? values.directions.x = directions.x : values.directions = { x: directions.x };\n      }\n\n      if (Math.abs(coords.y) > _constants.ALOETOUCH_MIN_SWIPE_DISTANCE) {\n        values.isSwipe = true;\n        values.directions ? values.directions.y = directions.y : values.directions = { y: directions.y };\n      }\n    }\n\n    return callback(values);\n  },\n\n\n  /**\n   * Valido l'evento Tap\n   */\n  tap: function tap(values, callback) {\n    if (Date.now() - values.started.time < _constants.ALOETOUCH_PRESS_MIN_TIME) return callback();\n  },\n\n\n  /**\n   * Evento doppio tap\n   * ( Validazione nell'Emitter )\n   */\n  dbltap: function dbltap(values, callback) {\n    return callback();\n  },\n\n\n  /**\n   * Evento press\n   * ( Validazione nell'Emitter )\n   */\n  press: function press(values, callback) {\n    return callback();\n  },\n\n\n  /**\n   * Valido l'evento swipe\n   */\n  swipe: function swipe(values, callback) {\n    var coords = values.pan;\n    var directions = (0, _Utils.stringDirection)(coords);\n\n    if (Math.abs(coords.x) > _constants.ALOETOUCH_MIN_SWIPE_DISTANCE || Math.abs(coords.y) > _constants.ALOETOUCH_MIN_SWIPE_DISTANCE) return callback({ coords: coords, directions: directions }, values);\n  },\n\n\n  /**\n  * Valido l'evento swipeLeft\n  */\n  swipeLeft: function swipeLeft(values, callback) {\n    var coords = values.pan;\n    if (coords.x < 0 && Math.abs(coords.x) > _constants.ALOETOUCH_MIN_SWIPE_DISTANCE) return callback({ coords: coords }, values);\n  },\n\n\n  /**\n   * Valido l'evento swipeRight\n   */\n  swipeRight: function swipeRight(values, callback) {\n    var coords = values.pan;\n    if (coords.x > 0 && Math.abs(coords.x) > _constants.ALOETOUCH_MIN_SWIPE_DISTANCE) return callback({ coords: coords }, values);\n  },\n\n\n  /**\n   * Valido l'evento swipeTop\n   */\n  swipeTop: function swipeTop(values, callback) {\n    var coords = values.pan;\n    if (Math.abs(coords.y) > _constants.ALOETOUCH_MIN_SWIPE_DISTANCE) return callback({ coords: coords }, values);\n  },\n\n\n  /**\n   * Valido l'evento swipeBottom\n   */\n  swipeBottom: function swipeBottom(values, callback) {\n    var coords = values.pan;\n    if (Math.abs(values.pan.y) > _constants.ALOETOUCH_MIN_SWIPE_DISTANCE) return callback({ coords: coords }, values);\n  },\n\n\n  /**\n   * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n   *\n   * @param {Object} coords\n   */\n  pan: function pan(values, callback) {\n    return callback(values.pan, values);\n  },\n\n\n  /**\n   * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n   *\n   * @param {Object} coords\n   */\n  pan2: function pan2(values, callback) {\n    return callback(values.pan, values);\n  },\n\n\n  /**\n   * L'evento pinch non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n   *\n   * @param {Number} distance\n   */\n  pinch: function pinch(values, callback) {\n    return callback(values.pinch, values);\n  },\n\n\n  /**\n   * L'evento rotate non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n   *\n   * @param {Number} rotation\n   */\n  rotate: function rotate(values, callback) {\n    return callback(values.rotation, values);\n  }\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AloeTouchObject = __webpack_require__(2);\n\nvar _AloeTouchObject2 = _interopRequireDefault(_AloeTouchObject);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * AloeTouch\n */\nvar AloeTouch = {\n\n  /**\n   * Version\n   *\n   * @type {String}\n   */\n  version: '0.0.0-beta.03',\n\n  /**\n   * Contiene il numero di elementi\n   *\n   * @type {Number}\n   */\n  increment: 0,\n\n  /**\n   * Lista degli AloeTouchObject\n   *\n   * @type {Object}\n   */\n  list: {},\n\n  /**\n   * Binda un nuovo elemento\n   *\n   * @param {DOMElement} element Elemento da bindare\n   * @param {Object}     events  Eventi da assegnare all'elemento\n   * @param {Object}    settings Impostazioni per l'ATO\n   */\n  bind: function bind(element, events, settings) {\n    var id = ++AloeTouch.increment;\n\n    var ato = new _AloeTouchObject2.default(id, element, events, settings).public;\n    ato.el.setAttribute('aloetouch-data-id', id);\n\n    return AloeTouch.list[id] = ato;\n  },\n\n\n  /**\n   * Rimuove i listener ad un elemento\n   *\n   * @param {AloeTouchObject or Numer} aloetouchobject\n   * @return {Boolean} true se l'elemento è stato rimosso, falso altrimenti\n   */\n  unbind: function unbind(aloetouchobject) {\n    var id = aloetouchobject.nodeType ? aloetouchobject.getAttribute('aloetouch-data-id') : this.getIds(aloetouchobject, true);\n\n    if (id) {\n      AloeTouch.list[id].lock();\n      delete AloeTouch.list[id].$ref;\n      delete AloeTouch.list[id];\n      return true;\n    }\n\n    return false;\n  },\n\n\n  /**\n   * Ritorna un elemento in base al suo id\n   *\n   * @param {Number} id\n   */\n  get: function get(id) {\n    return AloeTouch.list.hasOwnProperty(id) ? AloeTouch.list[id] : null;\n  },\n\n\n  /**\n   * Ritorna un' array di id\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   * @param {Boolean} first Ritorna un id se l'array ha lunghezza pari a uno\n   * @return {Array<Number> or Number}\n   */\n  getIds: function getIds(aloetouchobjects, first) {\n    aloetouchobjects = aloetouchobjects.constructor.name === 'Array' ? aloetouchobjects : [aloetouchobjects];\n    aloetouchobjects = aloetouchobjects.map(function (ato) {\n      return typeof ato === 'number' ? AloeTouch.get(ato) ? ato : null : ato.$ref ? ato.$id : null;\n    });\n    aloetouchobjects = aloetouchobjects.filter(function (id) {\n      return !!id;\n    });\n\n    return first ? aloetouchobjects[0] : aloetouchobjects;\n  },\n\n\n  /**\n   * Blocca un oggetto singolo o tutti\n   *\n   * @param {Number?} id Blocca gli eventi per l'oggetto con id 'id'\n   */\n  lock: function lock(id) {\n    id ? AloeTouch.list[id].lock() : AloeTouch.map(function (ato) {\n      return ato.lock();\n    });\n  },\n\n\n  /**\n   *  Blocca tutti gli oggetti tranne quelli presenti nell'array ids\n   *\n   * @param {Array<AloeTouchObject or Number>} ids\n   */\n  lockExcept: function lockExcept(ids) {\n    ids = this.getIds(ids) || [];\n\n    AloeTouch.map(function (ato, id) {\n      return ato[ids.indexOf(id) == -1 ? 'unlock' : 'lock']();\n    });\n  },\n\n\n  /**\n   * Blocca solo gli oggetti presenti in ids\n   *\n   * @param {Array<AloeTouchObject or Number>} ids\n   */\n  lockOnly: function lockOnly(ids) {\n    ids = this.getIds(ids) || [];\n\n    AloeTouch.map(function (ato, id) {\n      return ato[ids.indexOf(id) >= 0 ? 'lock' : 'unlock']();\n    });\n  },\n\n\n  /**\n   * Abilita li eventi ad un oggetto singolo o tutti\n   *\n   * @param {Number?} id\n   */\n  unlock: function unlock(id) {\n    id ? AloeTouch.list[id].unlock() : AloeTouch.map(function (ato) {\n      return ato.unlock();\n    });\n  },\n\n\n  /**\n   * Abilita gli eventi tranne agli elementi presenti nell'array aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  unlockExcept: function unlockExcept(aloetouchobjects) {\n    AloeTouch.lockOnly(aloetouchobjects);\n  },\n\n\n  /**\n   * Abilita gli eventi solo agli elementi presenti nell'array ids\n   *\n   * @param {Array<AloeTouchObject or Number>} ids\n   */\n  unlockOnly: function unlockOnly(ids) {\n    AloeTouch.lockExcept(ids);\n  },\n\n\n  /**\n   * Mappa tutti li elementi bindati\n   *\n   * @param {Callable(AloeTouchObject, id)}\n   */\n  map: function map(callable) {\n    Object.keys(AloeTouch.list).forEach(function (id) {\n      return callable(AloeTouch.list[id], id);\n    });\n  }\n};\n\nexports.default = AloeTouch;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dist/aloetouch.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 21406633ef3b9c04283b","/**\n * Preleva la touchlist (modificata) dall'evento\n *\n * @param  {Touchlist}  touches [description]\n * @param  {DOMElement} element L'emento esiste solo se è settato STRICT\n * @param  {Boolean}    strict\n * @return {Array}\n */\nexport function getTouches(event, element, strict){\n\n    let data = []\n    let touches = event.touches ? event.touches : { 'e': event }\n\n    Object.keys(touches).forEach(e => {\n        validate(touches[e], element, strict) && data.push({\n            screenX: touches[e].screenX,\n            screenY: touches[e].screenY\n        })\n    })\n\n    return data\n}\n\n/**\n * Aggiunge l'oggetto Touch se rispetta la validazone\n *\n * @param {Touch}      touch\n * @param {DOMElement} element\n * @param {Boolean}    strict\n */\nexport function validate(touch, element, strict)\n{\n    return touch && ( touch.screenX || touch.screenY ) && ( !strict ? element.contains(touch.target) : element == touch.target )\n}\n\n\n/**\n * Ritorna la differenza delle coordinate tra due ATO\n *\n * @param {ATO} ATOstart\n * @param {ATO} ATOend\n */\nexport function coords(ATOstart, ATOend)\n{\n    return diff(ATOstart.touches[0], ATOend.touches[0])\n}\n\n/**\n * Ritorna una coordinata basata sulla differenza tra due punti\n *\n * @param {ATO.touch} pointA\n * @param {ATO.touch} pointB\n */\nexport function diff(pointA, pointB)\n{\n    return {\n        x: pointB.screenX - pointA.screenX,\n        y: pointB.screenY - pointA.screenY\n    }\n}\n\n/**\n * Ritorna il numero di touch\n *\n * @param {ATO} ATOe\n */\nexport function fingers(ATO)\n{\n    return ATO && ATO.touches ? ATO.touches.length : 0\n}\n\n/**\n * Ritorna true se la differenza tra le coordinate è principalmente verticale\n *\n * @param {ATO} ATOstart\n * @param {ATO} ATOend\n */\nexport function isVertical(ATOstart, ATOend)\n{\n    let _coords = coords(ATOstart, ATOend)\n    return Math.abs(_coords.y) > Math.abs(_coords.x)\n}\n\n\n/**\n * Ritorna true se la differenza tra le coordinate è principalmente orizzontale\n *\n * @param {ATO} ATOstart\n * @param {ATO} ATOend\n */\nexport function isHorizontal(ATOstart, ATOend)\n{\n    let _coords = coords(ATOstart, ATOend)\n    return Math.abs(_coords.x) > Math.abs(_coords.y)\n}\n\n/**\n * Ritorna la direzione in base al valore delle coordinate\n *\n * @param {Object{x,y} } coords\n */\nexport function stringDirection(_coords)\n{\n    return {\n        x: _coords.x <= 0 ? 'Left' : 'Right',\n        y: _coords.y <= 0 ? 'Top' : 'Bottom'\n    }\n}\n\nexport function velocity(ATOstart, ATOend)\n{\n    let _coords = coords(ATOstart, ATOend)\n    let duration = (ATOend.time - ATOstart.time) / 1000\n\n    return {\n        x: _coords.x / duration,\n        y: _coords.y / duration,\n        d: scalar(_coords.x, _coords.y) / duration\n    }\n}\n\n/**\n * Ritorna la distanza tra due ATO\n *\n * @param {ATO} ATOstart\n * @param {ATO} ATOend\n */\nexport function distanceBetween(ATOstart, ATOend)\n{\n    return distance(ATOend) - distance(ATOstart)\n}\n\n/**\n * Ritorna la distanza vettoriale tra due coordinata\n *\n * @param {ATO} ATO\n */\nexport function distance(ATO)\n{\n    let distance = diff(ATO.touches[0], ATO.touches[1])\n    return scalar(distance.x, distance.y)\n}\n\n/**\n * Distanza scalare\n */\nexport function scalar(a, b)\n{\n    return Math.sqrt(Math.pow(a, 2) +  Math.pow(b, 2))\n}\n\n/**\n * Ritorna la direzione tangente tra due coordinate\n *\n * @param {ATO} ATO\n */\nexport function direction(ATO)\n{\n    let distance = diff(ATO.touches[0], ATO.touches[1])\n    return angle(distance.x, distance.y)\n}\n\n/**\n * Angolo\n */\nexport function angle(a, b) \n{\n    return Math.atan2(b, a) * 180 / Math.PI\n}\n\n/**\n * Ritorna l'angolo di rotazione tra due ATO\n *\n * @param {ATO} ATOstart\n * @param {ATO} ATOend\n */\nexport function rotation(ATOstart, ATOend)\n{\n    return direction(ATOend) - direction(ATOstart)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/services/Utils.js","/**\n * La durata minimina per bindare un evento\n * Utile a non prevenire lo scrolling\n * @type {Number}\n */\nexport const ALOETOUCH_MIN_TIME = 100\n\n/**\n * Tempo minimo per bindare l'evento press\n * @type {Number}\n */\nexport const ALOETOUCH_PRESS_MIN_TIME = 600\n\n/**\n * Distanza minima per bindare l'evento swipe[Direction]\n * @type {Number}\n */\nexport const ALOETOUCH_MIN_SWIPE_DISTANCE = 60\n\n/**\n * Distanza tra due Tap per bindare l'evento Double Tap\n * @type {Number}\n */\nexport const ALOETOUCH_DBL_TAP_TIME = 200\n\n\n\n// WEBPACK FOOTER //\n// ./src/services/constants.js","import { ALOETOUCH_MIN_TIME } from '../services/constants'\nimport { getTouches, isHorizontal, isVertical, coords } from '../services/Utils'\n\nimport Dispatcher from './Dispatcher'\n\n/**\n * Settaggi di default\n * @type Object\n */\nconst DEFAULT_SETTINGS = {\n    strict: false,\n    stopPropagation: false,\n    isPermissible: null,\n    onlyX: false,\n    onlyY: false\n}\n\n/**\n * Assegna gli eventi touch ad un elemento\n *\n * GLi eventi disponibili sono:\n * Touch singolo\n *     tap, dbltap, press, pan, swipe, swipeLeft, swipeRight, swipeTop, swipeBottom\n * Touch doppio\n *     pan2, pinch, rotate\n */\nexport default class AloeTouchObject {\n\n    /**\n     * Binda gli eventi all'elemento\n     * @param {DomElement} element\n     * @param {Object} events Oggetto che contiene le funzioni es. { tap: ..., swipeLeft: ..., rotate: ... }\n     * @param {Object<Boolean>} strict\n     */\n    constructor(id, element, events, settings)\n    {\n        this.id = id\n        this.el = typeof element === 'string' ? document.querySelector(element) : element\n        this.settings = Object.assign({}, DEFAULT_SETTINGS, settings)\n\n        this.locked = true\n\n        this.public = this.getPublicMethods()\n\n        this.Dispatcher = new Dispatcher(id, this.el, events, this.public)\n\n        this.start = this.start.bind(this)\n        this.move = this.move.bind(this)\n        this.finish = this.finish.bind(this)\n\n        this.unlock()\n\n        this.el.style.willChange = 'transform'\n    }\n\n    /**\n     * Eventi 'touchstart' 'mousedown'\n     */\n    start(event)\n    {\n        !this.locked && this.Dispatcher.start( event, getTouches(event, this.el, this.settings.strict), this.settings.stopPropagation )\n    }\n\n    /**\n     * Eventi 'touchmove'\n     */\n    move(event)\n    {\n        if(\n            !this.locked &&\n            this.Dispatcher.isStarted() &&\n            this.Dispatcher.end(event, getTouches(event, this.el, this.settings.strict) ) &&\n            this.isPermissible(event)\n        ) {\n            event.preventDefault();\n            if(this.settings.stopPropagation === true || this.settings.stopPropagation === 1) event.stopPropagation()\n            if(this.settings.stopPropagation === true || this.settings.stopPropagation === 2) event.stopImmediatePropagation()\n\n            this.Dispatcher.dispatch(null, event)\n        } else {\n            this.Dispatcher.clear()\n        }\n    }\n\n    /**\n     * Questa funzionalitò è molto importante poiché previene che l'evento 'touchmove'\n     * prevenga l'azione di default dell'evento (e quindi blocchi lo scrolling)\n     */\n    isPermissible(event)\n    {\n        return this.settings.isPermissible ? this.settings.isPermissible(event, coords(this.Dispatcher.started, this.Dispatcher.ended), this.Dispatcher.started, this.Dispatcher.ended) : (() => {\n            let time = Date.now() - this.Dispatcher.started.time\n            let _isHorizontal = isHorizontal(this.Dispatcher.started, this.Dispatcher.ended)\n            let _isVertical = isVertical(this.Dispatcher.started, this.Dispatcher.ended)\n\n            return event.cancelable && (\n                ((!this.settings.onlyX && !this.settings.onlyY && time > ALOETOUCH_MIN_TIME) || _isHorizontal) ||\n                (this.settings.onlyX && _isHorizontal) ||\n                (this.settings.onlyY && _isVertical)\n            )\n        })\n    }\n\n    /**\n     * Termino l'evento\n     */\n    finish(event)\n    {\n        if (!this.locked && this.Dispatcher.isStarted()) {\n            this.Dispatcher.dispatch(true, event)\n            \n            if (this.settings.stopPropagation) {    \n                event.stopPropagation()\n                event.stopImmediatePropagation()\n            }\n        }\n    }\n\n    /**\n     * Ritorna vero se questo oggetto è bloccato, falso altrimenti\n     *\n     * @return {Boolean}\n     */\n    isLock() {\n        return this.locked\n    }\n\n    /**\n     * Rimuove i listener degli eventi\n     */\n    lock()\n    {\n        if( !this.locked ) {\n            this.off('touchstart', this.start, true)\n            this.off('touchmove', this.move)\n            this.off('touchend touchcancel', this.finish, true)\n            this.locked = true\n        }\n    }\n\n    /**\n     * Binda gli eventi\n     */\n    unlock()\n    {\n        if( this.locked ) {\n            this.on('touchstart', this.start, true)\n            this.on('touchmove', this.move)\n            this.on('touchend touchleave touchcancel', this.finish, true)\n            this.locked = false\n        }\n    }\n\n    /**\n     * Bindo gli eventi all'elemento\n     */\n    on(events, handler, passive)\n    {\n        events.split(' ').forEach( e => this.el.addEventListener(e, handler, passive ? { passive: true } : true) )\n    }\n\n    /**\n     * Rimuovo i listeners\n     */\n    off(events, handler)\n    {\n        events.split(' ').forEach( e => this.el.removeEventListener(e, handler, true) )\n    }\n\n    /**\n     * Helper per una chiamata più semplice alle funzioni\n     */\n    getPublicMethods()\n    {\n        let ato = this\n\n        return {\n            el: this.el,\n            $id: this.id,\n\n            attach(events){ ato.Dispatcher.Emitter.attach(events) },\n            detach(events){ ato.Dispatcher.Emitter.detach(events) },\n\n            getState(){ ato.Dispatcher.Emitter.State.get() },\n            clearState(){ ato.Dispatcher.Emitter.State.clear() },\n            addState(state){ ato.Dispatcher.Emitter.State.add(state) },\n            removeState(name){ ato.Dispatcher.Emitter.State.remove(name) },\n\n            lock(){ ato.lock() },\n            unlock(){ ato.unlock() },\n            isLock(){ return ato.isLock() },\n\n            $ref: this\n        }\n    }\n\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/classes/AloeTouchObject.js","import { ALOETOUCH_PRESS_MIN_TIME, ALOETOUCH_DBL_TAP_TIME } from '../services/constants'\nimport { fingers } from '../services/Utils'\n\nimport Emitter from './Emitter'\n\n/**\n * Dispatcher - smistare gli eventi\n */\nexport default class Dispatcher {\n\n    /**\n     * Binda l'Emtitter che chiamerà gli eventi\n     */\n    constructor(id, element, events, ato)\n    {\n        this.Emitter = new Emitter(id, element, events || {}, ato)\n        this.started = null\n        this.ended = null\n        this.lastTap = null\n    }\n\n    /**\n     * Setta l'evento iniziale\n     * Binderà l'evento press nel caso in cui l'utente non rilascerà o muoverà l'elemento\n     */\n    start(event, touches, stopPropagation)\n    {\n        if (!event.cancelable)\n            return this.clear()\n\n        !this.started ? ( this.started = { time: Date.now(), touches } ) : ( this.started.touches = touches )\n\n        let _fingers = fingers(this.started)\n\n        if( _fingers ) {\n            this.Emitter.prepare(this.started)\n            this.Emitter.emitAfter('press', ALOETOUCH_PRESS_MIN_TIME)\n            this.Emitter.emit('start', event)\n            \n            if (_fingers > 1) {\n                event.preventDefault() // Blocca lo scrolling nel caso in cui l'utente abbia toccato l'elemento con più di un dito\n                \n                if (stopPropagation) {\n                    if(stopPropagation === true || stopPropagation === 1) event.stopPropagation()\n                    if(stopPropagation === true || stopPropagation === 2) event.stopImmediatePropagation()\n                }\n            }\n        }\n    }\n\n    /**\n     * Ritorna vero se l'evento è stato inizializzato correttamente\n     */\n    isStarted()\n    {\n        return !!this.started\n    }\n\n    /**\n     * Setta il punto corrente ( richiamato dalla gestore dell'evento touchmove: AloeTouchObject@move )\n     */\n    end(event, touches)\n    {\n        this.ended = { time: Date.now(), touches }\n\n        return fingers(this.started) == fingers(this.ended)\n    }\n\n    /**\n     * Smisto gli eventi in 'touchmove' in base al numero di tocchi in base alla tipologia dell'evento\n     *\n     * @param {Boolean} final Questo valore è settato a true se questa funzione è chiamanta dall'evento touchend o touchcancel\n     * @param {Event} \n     */\n    dispatch(final, event)\n    {\n        let _fingers = fingers(this.ended)\n\n        this.Emitter.prepare(this.started, this.ended, _fingers, !!final)\n\n        final ? this.dispatchFinalEvents(!!this.ended, event) : this.dispatchMovedEvents(_fingers, event) // Smisto al tipo di eventi\n    }\n\n    /**\n     * Gestione degli eventi che non richiedono movimento\n     */\n    dispatchFinalEvents(move, event)\n    {\n        move ? this.dispatchSwipe(event) : this.dispatchTap(event)\n        this.Emitter.emit('end', event)\n        this.clear()\n    }\n\n    /**\n     * Gestione degli eventi con movimento\n     */\n    dispatchMovedEvents(_fingers, event)\n    {\n        this.Emitter.clearAfter('press') // l'evento press non è più valido se l'utente si muove sull'elemento\n\n        // Smisto gli eventi in base al numero dei tocchi\n        if( _fingers == 1)\n           this.Emitter.emit('pan', event)\n        else if( _fingers == 2 ) {\n            this.Emitter.emit('pan2', event)\n            this.Emitter.emit('pinch', event)\n            this.Emitter.emit('rotate', event)\n        }\n\n        this.Emitter.emit('move', event) // Chiamo l'evento speciale 'move' in ogni caso\n    }\n\n    /**\n     * Gestione dell'evento particolare 'tap' e 'dbltap'\n     */\n    dispatchTap(event)\n    {\n        if(!this.lastTap) {\n            this.lastTap = this.started.time\n            this.Emitter.emitAfter('tap', ALOETOUCH_DBL_TAP_TIME, () => this.lastTap = null)\n        } else if( this.started.time - this.lastTap < ALOETOUCH_DBL_TAP_TIME ) {\n            this.Emitter.clearAfter('tap') \n            this.Emitter.emit('dbltap', event) \n            this.lastTap = null\n        }\n    }\n\n    /**\n     * Gestione dell'evento 'swipe'\n     */\n    dispatchSwipe(event)\n    {\n        this.Emitter.emit('swipe', event)\n        this.Emitter.emit('swipeLeft', event)\n        this.Emitter.emit('swipeRight', event)\n        this.Emitter.emit('swipeTop', event)\n        this.Emitter.emit('swipeBottom', event)\n    }\n\n    /**\n     * Reset delle variabili\n     */\n    clear()\n    {\n        this.started = null\n        this.ended = null\n\n        this.Emitter.clearAfter('press')\n        this.Emitter.State.refresh()\n    }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./src/classes/Dispatcher.js","import { coords, rotation, distanceBetween } from '../services/Utils'\nimport Events from '../services/Events'\nimport State from './State'\n\n/* -------------------------------------\n *  Bindaggio ed emissione eventi\n * ------------------------------------- */\n\nexport default class Emitter {\n\n    /**\n     * Gestore degli eventi e relativi argomenti\n     */\n    constructor(id, el, events, ato)\n    {\n        this.ato = ato\n        this.events = events\n        this.State = new State(events.state || {})\n\n        this.initialData = { id, el, ato }\n        this.after = {}\n\n        this.detach('state')\n    }\n\n    /**\n     * Emette un evento se settato\n     *\n     * @param {String} eventName Nome dell'evento da emettere\n     * @param {Event} event\n     */\n    emit(eventName, event)\n    {\n        if (Events.emit(eventName, this.data, this.events[eventName], event) === false)\n            this.detach(eventName)    \n    }\n\n    /**\n     * Emette un evento dopo un certo 'delay'\n     *\n     * @param {String}     event Nome dell'evento da emettere\n     * @param {Int}        delay Millisecondi da ritardare\n     * @param {Callable?}  callback Funzione da chiamare dopo il delay\n     */\n    emitAfter(event, delay, callback)\n    {\n        this.clearAfter(event)\n\n        this.after[event] = window.setTimeout(() => {\n            this.emit(event)\n            callback && callback()\n        }, delay)\n    }\n\n    /**\n     * Rimuove un evento da ritardare\n     *\n     * @param {String?} event Nome dell'evento da rimuovere. Se non settato, verranno rimossi tutti.\n     */\n    clearAfter(event)\n    {\n        if( typeof event === 'undefined' )\n            Object.keys(this.after).forEach(e => this.clearAfter(e))\n        else {\n            this.after[event] && window.clearTimeout(this.after[event])\n            this.after[event] = null\n            delete this.after[event]\n        }\n    }\n\n\n    /**\n     * Prepare i dati da inviare agli eventi\n     */\n    prepare(started, ended, fingers, final)\n    {\n        this.data = Object.assign({}, this.initialData, { started, ended, fingers, final })\n\n        this.setStateData(started, ended, fingers, final) // Setta lo state se si sta 'preparando' un evento non finale\n\n        this.data.$state = this.State.get()\n    }\n\n    /**\n     * Prepara la variabile che conterrà lo 'state'\n     */\n    setStateData(started, ended, fingers, final)\n    {\n        if( fingers == 1 )\n            this.data.pan = coords(started, ended)\n        else if( fingers == 2) {\n            this.data.pan = coords(started, ended)\n            this.data.pinch = distanceBetween(started, ended)\n            this.data.rotate = rotation(started, ended)\n        }\n        !final && this.State.set(this.data)\n    }\n\n    /**\n     * Aggiunge un evento\n     */\n    attach(events)\n    {\n        Object.keys(events).forEach( e => this.events[e] = events[e] )\n    }\n\n    /**\n     * Rimuove un evento\n     */\n    detach(events)\n    {\n        events = events.constructor.name === 'Array' ? events : [events]\n        events.forEach(e => this.events[e] && delete this.events[e])\n    }\n\n\n}\n\n\n// WEBPACK FOOTER //\n// ./src/classes/Emitter.js","\n/* -------------------------------------\n *  State\n * ------------------------------------- */\n\nexport default class State {\n\n    /**\n     * Setta gli state personalizzati\n     */\n    constructor(customState)\n    {\n        this.customState = customState\n\n        this.old = this.empty()\n        this.values = this.empty()\n    }\n\n    /**\n     * Ritorna uno state vuoto\n     * @return {Object}\n     */\n    empty() {\n        return {\n            pan: { x: 0, y: 0 },\n            pinch: 0,\n            rotate: 0\n        }\n    }\n\n    /**\n     * Binda i nuovi valori dall'evento corrente (chiamato da touchmove->dispatch->emit) con i valori precendenti\n     *\n     * @param {ATS} state\n     * @param {ATEvent} event\n     */\n    set(data)\n    {\n        data.rotate && ( this.values.rotate = data.rotate + this.old.rotate )\n        data.pinch && ( this.values.pinch = data.pinch + this.old.pinch )\n        data.pan && data.pan.x && ( this.values.pan.x = data.pan.x + this.old.pan.x )\n        data.pan && data.pan.y && ( this.values.pan.y = data.pan.y + this.old.pan.y )\n\n        // Aggiungo gli state settati dall'utente\n        Object.keys(this.customState).forEach( cs => this.values[cs] = this.customState[cs](this.values) )\n\n        return this.get()\n    }\n\n    /**\n     * Ritorna i valori dello state corrente\n     */\n    get()\n    {\n        return this.values\n    }\n\n    /**\n     * All'evento touchend setto i valori precendeti con l'ultimo settato\n     *\n     * @param {ATS} state\n     */\n    refresh()\n    {\n        this.old = this.copy(this.values)\n    }\n\n    /**\n     * Copia un oggetto\n     *\n     * @return {Object}\n     */\n    copy(d)\n    {\n        let n = {}\n        Object.keys(d).forEach( k => {\n            n[k] = typeof(d[k]) === 'object' && d[k] !== null ? this.copy(d[k]) : d[k]\n        })\n        return n\n    }\n\n\n    /**\n     * Setta uno state\n     *\n     * @param {Object} state\n     */\n    add(state)\n    {\n        Object.keys(state).forEach( s => this.customState[s] = state[s] )\n        this.set({})\n    }\n\n    /**\n     * Rimuove uno state\n     *\n     * @param {String} name Nome dello state da rimuovere\n     */\n    remove(name)\n    {\n        this.values[name] = null\n        this.values[name] = null\n\n        delete this.values[name]\n        delete this.values[name]\n    }\n\n    /**\n     * Cancella lo state con ivalori correnti\n     */\n    clear()\n    {\n        this.values = this.empty()\n        this.old = this.empty()\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/classes/State.js","import { ALOETOUCH_PRESS_MIN_TIME, ALOETOUCH_MIN_SWIPE_DISTANCE } from './constants'\nimport { stringDirection } from './Utils'\n\n/* -------------------------------------\n *  Eventi\n * ------------------------------------- */\n\n/**\n * Lista di tutti gli eventi gestibili\n * @type {Array<String>}\n */\nconst events = [\n    'start', 'move', 'end', // Eventi speciali\n    'tap', 'dbltap', 'press', 'swipe', 'swipeTop', 'swipeBottom', 'swipeLeft', 'swipeRight', 'pan', // Eventi un solo dito\n    'pan2', 'pinch', 'rotate' // Eventi due dita\n]\n\nexport default  {\n\n    /**\n     * Richiama gli altri eventi\n     */\n    emit(event, values, callback, nativeEvent)\n    {\n        if (events.indexOf(event) >= 0 && this[event] && callback) {\n            values.$event = nativeEvent\n            return this[event](values, callback)\n        }\n    },\n\n    /**\n     * Special Event\n     */\n    start(values, callback){ return callback(values) },\n\n    /**\n     * Special Event\n     */\n    move(values, callback){ return callback(values) },\n\n    /**\n     * Special Event\n     */\n    end(values, callback){\n        let coords = values.pan\n\n        if( coords ) {\n            values.isSwipe = false\n            let directions = stringDirection(coords)\n\n            if( Math.abs(coords.x) > ALOETOUCH_MIN_SWIPE_DISTANCE ) {\n                values.isSwipe = true\n                values.directions ? ( values.directions.x = directions.x ) : ( values.directions = { x: directions.x } )\n            }\n\n            if( Math.abs(coords.y) > ALOETOUCH_MIN_SWIPE_DISTANCE ) {\n                values.isSwipe = true\n                values.directions ? ( values.directions.y = directions.y ) : ( values.directions = { y: directions.y } )\n            }\n        }\n\n        return callback(values)\n    },\n\n    /**\n     * Valido l'evento Tap\n     */\n    tap(values, callback)\n    {\n        if( Date.now() - values.started.time < ALOETOUCH_PRESS_MIN_TIME )\n            return callback()\n    },\n\n    /**\n     * Evento doppio tap\n     * ( Validazione nell'Emitter )\n     */\n    dbltap(values, callback){ return callback() },\n\n    /**\n     * Evento press\n     * ( Validazione nell'Emitter )\n     */\n    press(values, callback){ return callback() },\n\n    /**\n     * Valido l'evento swipe\n     */\n    swipe(values, callback)\n    {\n        let coords = values.pan\n        let directions = stringDirection(coords)\n\n        if( Math.abs(coords.x) > ALOETOUCH_MIN_SWIPE_DISTANCE || Math.abs(coords.y) > ALOETOUCH_MIN_SWIPE_DISTANCE )\n            return callback({ coords, directions }, values)\n    },\n\n     /**\n     * Valido l'evento swipeLeft\n     */\n    swipeLeft(values, callback)\n    {\n        let coords = values.pan\n        if(coords.x < 0 && Math.abs(coords.x) > ALOETOUCH_MIN_SWIPE_DISTANCE )\n            return callback({ coords }, values)\n    },\n\n    /**\n     * Valido l'evento swipeRight\n     */\n    swipeRight(values, callback)\n    {\n        let coords = values.pan\n        if( coords.x > 0 && Math.abs(coords.x) > ALOETOUCH_MIN_SWIPE_DISTANCE )\n            return callback({ coords }, values)\n    },\n\n    /**\n     * Valido l'evento swipeTop\n     */\n    swipeTop(values, callback)\n    {\n        let coords = values.pan\n        if( Math.abs(coords.y) > ALOETOUCH_MIN_SWIPE_DISTANCE )\n            return callback({ coords }, values)\n    },\n\n    /**\n     * Valido l'evento swipeBottom\n     */\n    swipeBottom(values, callback)\n    {\n        let coords = values.pan\n        if( Math.abs(values.pan.y) > ALOETOUCH_MIN_SWIPE_DISTANCE )\n            return callback({ coords }, values)\n    },\n\n    /**\n     * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n     *\n     * @param {Object} coords\n     */\n    pan(values, callback)\n    {\n        return callback(values.pan, values)\n    },\n\n    /**\n     * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n     *\n     * @param {Object} coords\n     */\n    pan2(values, callback)\n    {\n        return callback(values.pan, values)\n    },\n\n    /**\n     * L'evento pinch non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n     *\n     * @param {Number} distance\n     */\n    pinch(values, callback)\n    {\n        return callback(values.pinch, values)\n    },\n\n    /**\n     * L'evento rotate non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n     *\n     * @param {Number} rotation\n     */\n    rotate(values, callback)\n    {\n        return callback(values.rotation, values)\n    }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./src/services/Events.js","import AloeTouchObject from './classes/AloeTouchObject'\n\n/**\n * AloeTouch\n */\nlet AloeTouch = {\n\n    /**\n     * Version\n     *\n     * @type {String}\n     */\n    version: '0.0.0-beta.03',\n\n    /**\n     * Contiene il numero di elementi\n     *\n     * @type {Number}\n     */\n    increment: 0,\n\n    /**\n     * Lista degli AloeTouchObject\n     *\n     * @type {Object}\n     */\n    list: {},\n\n    /**\n     * Binda un nuovo elemento\n     *\n     * @param {DOMElement} element Elemento da bindare\n     * @param {Object}     events  Eventi da assegnare all'elemento\n     * @param {Object}    settings Impostazioni per l'ATO\n     */\n    bind(element, events, settings)\n    {\n        let id = ++AloeTouch.increment\n\n        let ato = new AloeTouchObject( id, element, events, settings ).public\n        ato.el.setAttribute('aloetouch-data-id', id)\n\n        return ( AloeTouch.list[id] = ato )\n    },\n\n\n    /**\n     * Rimuove i listener ad un elemento\n     *\n     * @param {AloeTouchObject or Numer} aloetouchobject\n     * @return {Boolean} true se l'elemento è stato rimosso, falso altrimenti\n     */\n    unbind(aloetouchobject)\n    {\n        let id = aloetouchobject.nodeType ? aloetouchobject.getAttribute('aloetouch-data-id') : this.getIds(aloetouchobject, true)\n\n        if(id) {\n            AloeTouch.list[id].lock()\n            delete AloeTouch.list[id].$ref\n            delete AloeTouch.list[id]\n            return true\n        }\n\n        return false\n    },\n\n    /**\n     * Ritorna un elemento in base al suo id\n     *\n     * @param {Number} id\n     */\n    get(id)\n    {\n        return AloeTouch.list.hasOwnProperty(id) ? AloeTouch.list[id] : null\n    },\n\n    /**\n     * Ritorna un' array di id\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     * @param {Boolean} first Ritorna un id se l'array ha lunghezza pari a uno\n     * @return {Array<Number> or Number}\n     */\n    getIds(aloetouchobjects, first)\n    {\n        aloetouchobjects = aloetouchobjects.constructor.name === 'Array' ? aloetouchobjects : [aloetouchobjects]\n        aloetouchobjects = aloetouchobjects.map( ato => typeof ato === 'number' ? ( AloeTouch.get(ato) ? ato : null ) : ( ato.$ref ? ato.$id : null ) )\n        aloetouchobjects = aloetouchobjects.filter(id => !!id)\n\n        return first ? aloetouchobjects[0] : aloetouchobjects\n    },\n\n    /**\n     * Blocca un oggetto singolo o tutti\n     *\n     * @param {Number?} id Blocca gli eventi per l'oggetto con id 'id'\n     */\n    lock(id)\n    {\n        id ? AloeTouch.list[id].lock() : AloeTouch.map(ato => ato.lock())\n    },\n\n    /**\n     *  Blocca tutti gli oggetti tranne quelli presenti nell'array ids\n     *\n     * @param {Array<AloeTouchObject or Number>} ids\n     */\n    lockExcept(ids)\n    {\n        ids = this.getIds(ids) || []\n\n        AloeTouch.map((ato, id) => ato[ids.indexOf(id) == -1 ? 'unlock' : 'lock']())\n    },\n\n    /**\n     * Blocca solo gli oggetti presenti in ids\n     *\n     * @param {Array<AloeTouchObject or Number>} ids\n     */\n    lockOnly(ids)\n    {\n        ids = this.getIds(ids) || []\n\n        AloeTouch.map((ato, id) => ato[ids.indexOf(id) >= 0 ? 'lock' : 'unlock']())\n    },\n\n    /**\n     * Abilita li eventi ad un oggetto singolo o tutti\n     *\n     * @param {Number?} id\n     */\n    unlock(id)\n    {\n        id ? AloeTouch.list[id].unlock() : AloeTouch.map(ato => ato.unlock())\n    },\n\n    /**\n     * Abilita gli eventi tranne agli elementi presenti nell'array aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    unlockExcept(aloetouchobjects)\n    {\n        AloeTouch.lockOnly(aloetouchobjects)\n    },\n\n    /**\n     * Abilita gli eventi solo agli elementi presenti nell'array ids\n     *\n     * @param {Array<AloeTouchObject or Number>} ids\n     */\n    unlockOnly(ids)\n    {\n        AloeTouch.lockExcept(ids)\n    },\n\n    /**\n     * Mappa tutti li elementi bindati\n     *\n     * @param {Callable(AloeTouchObject, id)}\n     */\n    map(callable) {\n        Object.keys(AloeTouch.list).forEach(id => callable(AloeTouch.list[id], id))\n    }\n\n}\n\nexport default AloeTouch\n\n\n// WEBPACK FOOTER //\n// ./src/AloeTouch.js"],"sourceRoot":""}