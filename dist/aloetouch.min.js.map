{"version":3,"sources":["webpack:///dist/aloetouch.min.js","webpack:///webpack/bootstrap bc2b79c99b47978b6f87","webpack:///./src/aloetouch.js","webpack:///./src/aloetouch.object.js","webpack:///./src/aloetouch.state.js","webpack:///./src/aloetouch.utils.js","webpack:///./index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireDefault","obj","default","_aloetouch","_aloetouch2","AloeTouch","length","list","bind","element","events","strict","id","ato","el","attach","detach","setState","removeState","clearState","lock","unlock","map","lockExcept","ids","indexOf","lockOnly","unlockExcept","unlockOnly","callable","keys","forEach","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","_aloetouch3","_aloetouch4","ALOETOUCH_MIN_TIME","ALOETOUCH_PRESS_MIN_TIME","ALOETOUCH_MIN_SWIPE_DISTANCE","AloeTouchObject","this","document","querySelector","strictMode","utils","state","locked","eventBind","__start","start","__move","move","__finish","finish","clear","event","started","create","updated","mooving","pressEmitted","window","setTimeout","press","emit","_this","prepareMove","ended","isPermissible","preventDefault","stopPropagation","dispatch","callback","time","isHorizontal","howManyTouches","pan","pinch","rotate","coords","distanceBetween","rotation","setStateAndEmit","stateValue","swipe","tap","refresh","clearTimeout","off","on","eventValues","set","_this2","Date","now","Math","abs","x","stringDirection","y","distance","data","handler","passive","_this3","split","e","addEventListener","_this4","removeEventListener","_typeof","Symbol","iterator","constructor","AloeTouchState","new","assign","old","customState","cs","copyState","k","AloeTouchUtils","oldATO","ATO","touches","getTouches","validate","push","clientX","clientY","touch","ATOstart","ATOend","diff","pointA","pointB","isVertical","sqrt","pow","direction","atan2","PI"],"mappings":"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","file":"./dist/aloetouch.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _aloetouch = __webpack_require__(1);\n\nvar _aloetouch2 = _interopRequireDefault(_aloetouch);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * AloeTouch\n */\nvar AloeTouch = {\n\n    length: 0,\n\n    list: {},\n\n    /**\n     * Binda un nuovo elemento\n     */\n    bind: function bind(element, events, strict) {\n        var id = ++AloeTouch.length;\n\n        AloeTouch.list[id] = new _aloetouch2.default(id, element, events, strict);\n\n        return AloeTouch.get(id);\n    },\n\n\n    /**\n     * Ritorna un elemento in base al suo id\n     */\n    get: function get(id) {\n        var ato = AloeTouch.list[id];\n\n        return {\n            el: ato.el,\n            attach: ato.attach.bind(ato), // Binda un evento\n            detach: ato.detach.bind(ato), // Rimuovo il listener di un evento\n            setState: ato.setState.bind(ato), // Setta uno stato personalizzato\n            removeState: ato.removeState.bind(ato), // Rimuove uno state\n            clearState: ato.clearState.bind(ato), // Azzera la variabile state\n            lock: ato.lock.bind(ato), // Rimuove i listener per tutti gli eventi\n            unlock: ato.unlock.bind(ato), // Rebinda i listener per gli eventii\n            id: id // id dell'oggetto\n        };\n    },\n\n\n    /**\n     * Blocca un oggetto singolo o tutti\n     *\n     * @param {Number?} id Blocca gli eventi per l'oggetto con id id\n     */\n    lock: function lock(id) {\n        id && AloeTouch.list[id].lock();\n        !id && AloeTouch.map(function (ato) {\n            return ato.lock();\n        });\n    },\n\n\n    /**\n     *  Blocca tutti gli oggetti tranne gli id presenti nell'array ids\n     *\n     * @param {Array<Number>} ids\n     */\n    lockExcept: function lockExcept(ids) {\n        AloeTouch.map(function (ato, id) {\n            AloeTouch.list[id][ids.indexOf(id) == -1 ? 'unlock' : 'lock']();\n        });\n    },\n\n\n    /**\n     * Blocca solo gli oggetti con id presente in ids\n     *\n     * @param {Number?} id\n     */\n    lockOnly: function lockOnly(ids) {\n        AloeTouch.map(function (ato, id) {\n            AloeTouch.list[id][ids.indexOf(id) >= 0 ? 'lock' : 'unlock']();\n        });\n    },\n\n\n    /**\n     * Abilita li eventi ad un oggetto singolo o tutti\n     *\n     * @param {Number?} id\n     */\n    unlock: function unlock(id) {\n        id && AloeTouch.list[id].unlock();\n        !id && AloeTouch.map(function (ato) {\n            return ato.unlock();\n        });\n    },\n\n\n    /**\n     * Abilita gli eventi tranne agli elementi con id presente nell'array ids\n     *\n     * @param {Number?} id\n     */\n    unlockExcept: function unlockExcept(ids) {\n        AloeTouch.lockOnly(ids);\n    },\n\n\n    /**\n     * Abilita gli eventi solo agli elementi con id presente nell'array ids\n     *\n     * @param {Number?} id\n     */\n    unlockOnly: function unlockOnly(ids) {\n        AloeTouch.lockExcept(ids);\n    },\n\n\n    /**\n     * Mappa tutti li elementi bindati\n     *\n     * @param {Callable(Object, id)}\n     */\n    map: function map(callable) {\n        Object.keys(AloeTouch.list).forEach(function (id) {\n            return callable(AloeTouch.list[id], id);\n        });\n    }\n};\n\nexports.default = AloeTouch;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _aloetouch = __webpack_require__(3);\n\nvar _aloetouch2 = _interopRequireDefault(_aloetouch);\n\nvar _aloetouch3 = __webpack_require__(2);\n\nvar _aloetouch4 = _interopRequireDefault(_aloetouch3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * La durata minimina per bindare un evento\n * Utile a non prevenire lo scrolling\n * @type {Number}\n */\nvar ALOETOUCH_MIN_TIME = 85;\n\n/**\n * Tempo minimo per bindare l'evento press\n * @type {Number}\n */\nvar ALOETOUCH_PRESS_MIN_TIME = 600;\n\n/**\n * Distanza minima per bindare l'evento swipe[Direction]\n * @type {Number}\n */\nvar ALOETOUCH_MIN_SWIPE_DISTANCE = 20;\n\n/**\n * Assegna gli eventi touch ad un elemento\n *\n * GLi eventi disponibili sono:\n * Touch singolo\n *     tap, press, pan, swipeLeft, swipeRight, swipeTop, swipeBottom\n * Touch doppio\n *     pinch, rotate\n */\n\nvar AloeTouchObject = function () {\n\n    /**\n     * Binda gli eventi all'elemento\n     * @param {DomElement} element\n     * @param {Object} events Oggetto che contiene le funzioni es. { tap: ..., swipeLeft: ..., rotate: ... }\n     * @param {Boolean} strict Aggiunge le coordinate del tuoch solo se il target è uguale all'elemento bindato\n     */\n    function AloeTouchObject(id, element, events, strict) {\n        _classCallCheck(this, AloeTouchObject);\n\n        this.id = id;\n        this.el = typeof element === 'string' ? document.querySelector(element) : element;\n        this.events = events || {};\n        this.strictMode = strict || true;\n        this.utils = _aloetouch2.default;\n        this.state = _aloetouch4.default;\n        this.locked = true;\n        this.events.state = this.events.state || {};\n\n        // Oggetto da passare come 'this' ad un evento\n        this.eventBind = { el: this.el, clearState: this.clearState.bind(this) };\n        this.__start = this.start.bind(this);\n        this.__move = this.move.bind(this);\n        this.__finish = this.finish.bind(this);\n\n        this.clear();\n        this.clearState();\n        this.unlock();\n    }\n\n    /**\n     * Eventi 'touchstart' 'mousedown'\n     */\n\n\n    _createClass(AloeTouchObject, [{\n        key: 'start',\n        value: function start(event) {\n            if (!this.locked) {\n                this.started = this.utils.create(event, this.strictMode ? this.el : null, this.started);\n\n                this.started.updated && (this.mooving = true);\n\n                // Binderà l'evento press solo se non sarà invocato nè l'evento move, nè finish\n                !this.started.updated && (this.pressEmitted = window.setTimeout(this.press.bind(this), ALOETOUCH_PRESS_MIN_TIME));\n\n                this.emit('touchstart');\n            }\n        }\n\n        /**\n         * Eventi 'touchmove'\n         */\n\n    }, {\n        key: 'move',\n        value: function move(event) {\n            var _this = this;\n\n            // Controllo se sono settate le coordinate del touch all'evento start e bindo le nuove coordinate (ended)\n            !this.locked && this.prepareMove(event, function (ended) {\n                if (_this.isPermissible()) {\n                    event.preventDefault();\n                    event.stopPropagation();\n\n                    _this.mooving = true;\n                    _this.dispatch(); // Smisto gli eventi 'mobili': pan, rotate, pitch\n                } else {\n                    _this.mooving = false; // L'evento non può più essere prevenuto\n                }\n            });\n        }\n\n        /**\n         * Eseguo la funczione moove solo se sono settate le coordinate iniziali\n         */\n\n    }, {\n        key: 'prepareMove',\n        value: function prepareMove(event, callback) {\n            this.started && callback.call(this, this.ended = this.utils.create(event, this.el));\n            !this.started && this.clear();\n        }\n\n        /**\n         * Questa funzionalitò è molto importante poiché previene che l'evento 'touchmove'\n         * prevenga l'azione di default dell'evento (e quindi blocchi lo scrolling)\n         */\n\n    }, {\n        key: 'isPermissible',\n        value: function isPermissible() {\n            var time = this.ended.time - this.started.time;\n            var isHorizontal = this.utils.isHorizontal(this.started, this.ended); // Se lo scrolling è orizzontale implica che l'utente non sta scorrendo\n            // verticalmente la pagina, quindi è possibile bloccare lo scrolling\n            return this.mooving || this.mooving === null // Il caso in cui questa variabile risulta === null avviene solo la priva volta che viene invocata la fuonzione move,\n            && (isHorizontal || time > ALOETOUCH_MIN_TIME) // infatti viene nullata con la funzione clear presente nel metodo start. Questa cndizione è necessaria perché il metodo\n            ; // preventDefault() di Event non può essere invocato in un secondo stadio dell'evento 'touchmove', ma solo la prima volta\n        }\n\n        /**\n         * Smisto gli eventi in 'touchmove' in base al numero di tocchi\n         */\n\n    }, {\n        key: 'dispatch',\n        value: function dispatch() {\n            var howManyTouches = this.utils.howManyTouches(this.ended),\n                pan = null,\n                pinch = null,\n                rotate = null;\n\n            if (howManyTouches == 1) {\n                pan = this.utils.coords(this.started, this.ended);\n            } else if (howManyTouches == 2) {\n                pan = this.utils.coords(this.started, this.ended), pinch = this.utils.distanceBetween(this.started, this.ended), rotate = this.utils.rotation(this.started, this.ended);\n            }\n\n            this.setStateAndEmit({ pan: pan, pinch: pinch, rotate: rotate });\n            return this.emit('touchmove', this.stateValue);\n        }\n\n        /**\n         * Termino l'evento\n         */\n\n    }, {\n        key: 'finish',\n        value: function finish(event) {\n            if (!this.locked && this.started) // Controllo che vale anche per l'evento touchmove\n                {\n                    this.mooving && this.swipe();\n                    this.mooving === null && this.tap();\n\n                    this.stateValue = this.state.refresh(this.stateValue, this.events.state);\n\n                    this.emit('touchend');\n                }\n\n            this.clear();\n        }\n\n        /**\n         * Reset delle variabili\n         */\n\n    }, {\n        key: 'clear',\n        value: function clear() {\n            this.pressEmitted && window.clearTimeout(this.pressEmitted); // Cancello l'evento press\n\n            this.started = null;\n            this.ended = null;\n            this.mooving = null;\n            this.pressEmitted = null;\n        }\n\n        /* -------------------------------------\n         *  Eventi\n         * ------------------------------------- */\n\n    }, {\n        key: 'isLock',\n        value: function isLock() {\n            return this.locked;\n        }\n\n        /**\n         * Rimuove i listener degli eventi\n         */\n\n    }, {\n        key: 'lock',\n        value: function lock() {\n            if (!this.locked) {\n                this.off('touchstart', this.__start, true);\n                this.off('touchmove', this.__move);\n                this.off('touchend touchcancel', this.__finish, true);\n                this.locked = true;\n            }\n        }\n\n        /**\n         * Binda gli eventi\n         */\n\n    }, {\n        key: 'unlock',\n        value: function unlock() {\n            if (this.locked) {\n                this.on('touchstart', this.__start, true);\n                this.on('touchmove', this.__move);\n                this.on('touchend touchcancel', this.__finish, true);\n                this.locked = false;\n            }\n        }\n\n        /* -------------------------------------\n         *  State\n         * ------------------------------------- */\n\n        /**\n         * Setta i valore dello state ed emette gli eventi\n         */\n\n    }, {\n        key: 'setStateAndEmit',\n        value: function setStateAndEmit(eventValues) {\n            this.stateValue = this.state.set(this.stateValue, eventValues, this.events.state);\n\n            eventValues.pan && this.pan(eventValues.pan, this.stateValue);\n            eventValues.pinch && this.pinch(eventValues.pinch, this.stateValue);\n            eventValues.rotate && this.rotate(eventValues.rotate, this.stateValue);\n        }\n\n        /**\n         * Setta uno state\n         */\n\n    }, {\n        key: 'setState',\n        value: function setState(state) {\n            var _this2 = this;\n\n            Object.keys(state).forEach(function (s) {\n                _this2.events.state[s] = state[s];\n            });\n        }\n\n        /**\n         * Rimuove uno state\n         */\n\n    }, {\n        key: 'removeState',\n        value: function removeState(name) {\n            delete this.state[name];\n            delete this.stateValue[name];\n        }\n\n        /**\n         * Cancella lo state con ivalori correnti\n         */\n\n    }, {\n        key: 'clearState',\n        value: function clearState() {\n            this.stateValue = this.state.create();\n        }\n\n        /* -------------------------------------\n         *  Eventi\n         * ------------------------------------- */\n\n        /**\n         * Valido l'evento tap\n         */\n\n    }, {\n        key: 'tap',\n        value: function tap() {\n            var howManyTouches = this.utils.howManyTouches(this.ended);\n            var time = Date.now() - this.started.time;\n\n            if (howManyTouches == 1 && time < ALOETOUCH_PRESS_MIN_TIME) this.emit('tap');\n        }\n\n        /**\n         * Evento press\n         */\n\n    }, {\n        key: 'press',\n        value: function press() {\n            if (this.pressEmitted) {\n                this.emit('press', null);\n                this.pressEmitted = null;\n            }\n        }\n\n        /**\n         * Valido l'evento swipe\n         */\n\n    }, {\n        key: 'swipe',\n        value: function swipe() {\n            var coords = this.utils.coords(this.started, this.ended);\n\n            if (Math.abs(coords.x) > ALOETOUCH_MIN_SWIPE_DISTANCE) {\n                var stringDirection = this.utils.stringDirection(coords);\n\n                this.emit('swipe' + stringDirection.x, coords);\n                this.emit('swipe' + stringDirection.y, coords);\n            }\n        }\n\n        /**\n         * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n         */\n\n    }, {\n        key: 'pan',\n        value: function pan(coords) {\n            return this.emit('pan', coords);\n        }\n\n        /**\n         * L'evento pinch non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n         */\n\n    }, {\n        key: 'pinch',\n        value: function pinch(distance) {\n            return this.emit('pinch', distance);\n        }\n\n        /**\n         * L'evento rotate non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n         */\n\n    }, {\n        key: 'rotate',\n        value: function rotate(rotation) {\n            return this.emit('rotate', rotation);\n        }\n\n        /* -------------------------------------\n         *  Bindaggio ed emissione eventi\n         * ------------------------------------- */\n\n        /**\n         * Emette un evento se settato\n         */\n\n    }, {\n        key: 'emit',\n        value: function emit(event, data) {\n            this.events[event] && this.events[event](data, this.stateValue);\n\n            return data;\n        }\n\n        /**\n         * Aggiunge un evento\n         */\n\n    }, {\n        key: 'attach',\n        value: function attach(event, callable) {\n            this.events[event] = callable;\n        }\n        /**\n         * Rimuove un evento\n         */\n\n    }, {\n        key: 'detach',\n        value: function detach(event) {\n            this.events[event] && delete this.events[event];\n        }\n\n        /**\n         * Bindo gli eventi all'elemento\n         */\n\n    }, {\n        key: 'on',\n        value: function on(events, handler, passive) {\n            var _this3 = this;\n\n            events.split(' ').forEach(function (e) {\n                return _this3.el.addEventListener(e, handler, passive ? { passive: true } : false);\n            });\n        }\n\n        /**\n         * Rimuovo i listeners\n         */\n\n    }, {\n        key: 'off',\n        value: function off(events, handler, passive) {\n            var _this4 = this;\n\n            events.split(' ').forEach(function (e) {\n                return _this4.el.removeEventListener(e, handler, passive ? { passive: true } : false);\n            });\n        }\n    }]);\n\n    return AloeTouchObject;\n}();\n\nexports.default = AloeTouchObject;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar AloeTouchState = {\n\n    /**\n     * Crea un oggetto vuoto per il contenimento dei valori degli eventi pan, pinch e rotate\n     */\n    new: function _new() {\n        return {\n            pan: { x: null, y: null },\n            pinch: null,\n            rotate: null\n        };\n    },\n\n\n    /**\n     * Crea un nuovo oggetto che conterra i valori precedenti degli eventi\n     */\n    create: function create() {\n        return Object.assign({}, AloeTouchState.new(), { old: AloeTouchState.new() });\n    },\n\n\n    /**\n     * Binda i nuovi valori dall'evento corrente (chiamato da touchmove->dispatch->emit) con i valori precendenti\n     *\n     * @param {ATS} state\n     * @param {ATEvent} event\n     */\n    set: function set(state, event, customState) {\n        event.rotate && (state.rotate = event.rotate + state.old.rotate);\n        event.pinch && (state.pinch = event.pinch + state.old.pinch);\n        event.pan && event.pan.x && (state.pan.x = event.pan.x + state.old.pan.x);\n        event.pan && event.pan.y && (state.pan.y = event.pan.y + state.old.pan.y);\n\n        // Aggiungo gli state settati dall'utente\n        Object.keys(customState).forEach(function (cs) {\n            return state[cs] = customState[cs](state);\n        });\n\n        return state;\n    },\n\n\n    /**\n     * All'evento touchend setto i valori precendeti con l'ultimo settato\n     *\n     * @param {ATS} state\n     */\n    refresh: function refresh(state) {\n        state.old = AloeTouchState.copyState(state);\n\n        return state;\n    },\n\n\n    /**\n     * Copio l'oggetto state\n     */\n    copyState: function copyState(state) {\n        var n = {};\n        Object.keys(state).forEach(function (k) {\n            k != 'old' && (n[k] = _typeof(state[k]) === 'object' && state[k] !== null ? AloeTouchState.copyState(state[k]) : state[k]);\n        });\n        return n;\n    }\n};\n\nexports.default = {\n    set: AloeTouchState.set,\n    create: AloeTouchState.create,\n    refresh: AloeTouchState.refresh\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar AloeTouchUtils = {\n    /**\n     * Crea (o modifico) l'oggetto ATO (AloeTouchObject) contenente la Touchlist\n     *\n     * @param  {Event}      event\n     * @param  {DOMElement} element\n     * @param  {ATO?}       oldATO\n     */\n    create: function create(event, element, oldATO) {\n        var ATO = oldATO ? Object.assign({}, oldATO, { updated: true }) : { time: Date.now() };\n\n        ATO.touches = AloeTouchUtils.getTouches(event.touches ? event.touches : [event], element);\n\n        return ATO;\n    },\n\n\n    /**\n     * Preleva la touchlist (modificata) dall'evento\n     *\n     * @param  {Touclist}  touches [description]\n     * @param  {DOMElement} element L'emento esiste solo se è settato STRICT\n     * @return {Array}\n     */\n    getTouches: function getTouches(touches, element) {\n        var data = [];\n\n        Object.keys(touches).forEach(function (e) {\n            AloeTouchUtils.validate(touches[e], element) && data.push({\n                clientX: touches[e].clientX,\n                clientY: touches[e].clientY\n            });\n        });\n\n        return data;\n    },\n\n\n    /**\n     * Aggiunge l'oggetto Touch se rispetta la validazone\n     *\n     * @param {Touch}      touch\n     * @param {DOMElement} element\n     */\n    validate: function validate(touch, element) {\n        return touch && (touch.clientX || touch.clientY) && (!element || element == touch.target);\n    },\n\n\n    /**\n     * Ritorna la differenza delle coordinate tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    coords: function coords(ATOstart, ATOend) {\n        return AloeTouchUtils.diff(ATOstart.touches[0], ATOend.touches[0]);\n    },\n\n\n    /**\n     * Ritorna una coordinata basata sulla differenza tra due punti\n     *\n     * @param {ATO.touch} pointA\n     * @param {ATO.touch} pointB\n     */\n    diff: function diff(pointA, pointB) {\n        return {\n            x: pointB.clientX - pointA.clientX,\n            y: pointB.clientY - pointA.clientY\n        };\n    },\n\n\n    /**\n     * Ritorna il numero di touch\n     *\n     * @param {ATO} ATOe\n     */\n    howManyTouches: function howManyTouches(ATO) {\n        return ATO && ATO.touches ? ATO.touches.length : 0;\n    },\n\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente verticale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isVertical: function isVertical(ATOstart, ATOend) {\n        var coords = AloeTouchUtils.coords(ATOstart, ATOend);\n        return Math.abs(coords.y) > Math.abs(coords.x);\n    },\n\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente orizzontale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isHorizontal: function isHorizontal(ATOstart, ATOend) {\n        var coords = AloeTouchUtils.coords(ATOstart, ATOend);\n        return Math.abs(coords.x) > Math.abs(coords.y);\n    },\n\n\n    /**\n     * Ritorna la direzione in base al valore delle coordinate\n     *\n     * @param {Object{x,y} } coords\n     */\n    stringDirection: function stringDirection(coords) {\n        return {\n            x: coords.x <= 0 ? 'Left' : 'Right',\n            y: coords.y <= 0 ? 'Top' : 'Bottom'\n        };\n    },\n\n\n    /* -------------------------------------\n     *  Helper per eventi\n     * ------------------------------------- */\n\n    /**\n     * Ritorna la distanza tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    distanceBetween: function distanceBetween(ATOstart, ATOend) {\n        return AloeTouchUtils.distance(ATOend) - AloeTouchUtils.distance(ATOstart);\n    },\n\n\n    /**\n     * Ritorna la distanza vettoriale tra due coordinata\n     *\n     * @param {ATO} ATO\n     */\n    distance: function distance(ATO) {\n        var distance = AloeTouchUtils.diff(ATO.touches[0], ATO.touches[1]);\n        return Math.sqrt(Math.pow(distance.x, 2) + Math.pow(distance.y, 2));\n    },\n\n\n    /**\n     * Ritorna la direzione tangente tra due coordinate\n     *\n     * @param {ATO} ATO\n     */\n    direction: function direction(ATO) {\n        var distance = AloeTouchUtils.diff(ATO.touches[0], ATO.touches[1]);\n        return Math.atan2(distance.y, distance.x) * 180 / Math.PI;\n    },\n\n\n    /**\n     * Ritorna l'angolo di rotazione tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    rotation: function rotation(ATOstart, ATOend) {\n        return AloeTouchUtils.direction(ATOend) - AloeTouchUtils.direction(ATOstart);\n    }\n};\n\nexports.default = {\n    create: AloeTouchUtils.create,\n    coords: AloeTouchUtils.coords,\n    howManyTouches: AloeTouchUtils.howManyTouches,\n    isVertical: AloeTouchUtils.isVertical,\n    isHorizontal: AloeTouchUtils.isHorizontal,\n    stringDirection: AloeTouchUtils.stringDirection,\n    distanceBetween: AloeTouchUtils.distanceBetween,\n    distance: AloeTouchUtils.distance,\n    direction: AloeTouchUtils.direction,\n    rotation: AloeTouchUtils.rotation\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _aloetouch = __webpack_require__(0);\n\nvar _aloetouch2 = _interopRequireDefault(_aloetouch);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.AloeTouch = _aloetouch2.default;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dist/aloetouch.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bc2b79c99b47978b6f87","import AloeTouchObject from './aloetouch.object'\n\n/**\n * AloeTouch\n */\nlet AloeTouch = {\n\n    length: 0,\n\n    list: {},\n\n    /**\n     * Binda un nuovo elemento\n     */\n    bind(element, events, strict)\n    {\n        let id = ++AloeTouch.length\n\n        AloeTouch.list[id] = new AloeTouchObject(id, element, events, strict)\n\n        return AloeTouch.get(id)\n    },\n\n    /**\n     * Ritorna un elemento in base al suo id\n     */\n    get(id)\n    {\n        let ato = AloeTouch.list[id]\n\n        return {\n            el: ato.el,\n            attach: ato.attach.bind(ato),               // Binda un evento\n            detach: ato.detach.bind(ato),               // Rimuovo il listener di un evento\n            setState: ato.setState.bind(ato),           // Setta uno stato personalizzato\n            removeState: ato.removeState.bind(ato),     // Rimuove uno state\n            clearState: ato.clearState.bind(ato),       // Azzera la variabile state\n            lock: ato.lock.bind(ato),                   // Rimuove i listener per tutti gli eventi\n            unlock: ato.unlock.bind(ato),               // Rebinda i listener per gli eventii\n            id                                          // id dell'oggetto\n        }\n    },\n\n    /**\n     * Blocca un oggetto singolo o tutti\n     *\n     * @param {Number?} id Blocca gli eventi per l'oggetto con id id\n     */\n    lock(id)\n    {\n        id && ( AloeTouch.list[id].lock() )\n        !id && AloeTouch.map(ato => ato.lock() )\n    },\n\n    /**\n     *  Blocca tutti gli oggetti tranne gli id presenti nell'array ids\n     *\n     * @param {Array<Number>} ids\n     */\n    lockExcept(ids)\n    {\n        AloeTouch.map((ato, id) => {\n            AloeTouch.list[id][ids.indexOf(id) == -1 ? 'unlock' : 'lock']()\n        })\n    },\n\n    /**\n     * Blocca solo gli oggetti con id presente in ids\n     *\n     * @param {Number?} id\n     */\n    lockOnly(ids)\n    {\n        AloeTouch.map((ato, id) => {\n            AloeTouch.list[id][ids.indexOf(id) >= 0 ? 'lock' : 'unlock']()\n        })\n    },\n\n    /**\n     * Abilita li eventi ad un oggetto singolo o tutti\n     *\n     * @param {Number?} id\n     */\n    unlock(id)\n    {\n        id && ( AloeTouch.list[id].unlock() )\n        !id && AloeTouch.map(ato => ato.unlock() )\n    },\n\n    /**\n     * Abilita gli eventi tranne agli elementi con id presente nell'array ids\n     *\n     * @param {Number?} id\n     */\n    unlockExcept(ids)\n    {\n        AloeTouch.lockOnly(ids)\n    },\n\n    /**\n     * Abilita gli eventi solo agli elementi con id presente nell'array ids\n     *\n     * @param {Number?} id\n     */\n    unlockOnly(ids)\n    {\n        AloeTouch.lockExcept(ids)\n    },\n\n    /**\n     * Mappa tutti li elementi bindati\n     *\n     * @param {Callable(Object, id)}\n     */\n    map(callable){\n        Object.keys(AloeTouch.list).forEach(id => callable(AloeTouch.list[id], id))\n    }\n\n}\n\nexport default AloeTouch\n\n\n// WEBPACK FOOTER //\n// ./src/aloetouch.js","import AloeTouchUtils from './aloetouch.utils'\nimport AloeTouchState from './aloetouch.state'\n\n/**\n * La durata minimina per bindare un evento\n * Utile a non prevenire lo scrolling\n * @type {Number}\n */\nconst ALOETOUCH_MIN_TIME = 85\n\n/**\n * Tempo minimo per bindare l'evento press\n * @type {Number}\n */\nconst ALOETOUCH_PRESS_MIN_TIME = 600\n\n/**\n * Distanza minima per bindare l'evento swipe[Direction]\n * @type {Number}\n */\nconst ALOETOUCH_MIN_SWIPE_DISTANCE = 20\n\n/**\n * Assegna gli eventi touch ad un elemento\n *\n * GLi eventi disponibili sono:\n * Touch singolo\n *     tap, press, pan, swipeLeft, swipeRight, swipeTop, swipeBottom\n * Touch doppio\n *     pinch, rotate\n */\nexport default class AloeTouchObject {\n\n    /**\n     * Binda gli eventi all'elemento\n     * @param {DomElement} element\n     * @param {Object} events Oggetto che contiene le funzioni es. { tap: ..., swipeLeft: ..., rotate: ... }\n     * @param {Boolean} strict Aggiunge le coordinate del tuoch solo se il target è uguale all'elemento bindato\n     */\n    constructor(id, element, events, strict)\n    {\n        this.id = id\n        this.el = typeof element === 'string' ? document.querySelector(element) : element\n        this.events = events || {}\n        this.strictMode = strict || true\n        this.utils = AloeTouchUtils\n        this.state = AloeTouchState\n        this.locked = true\n        this.events.state = this.events.state || {}\n\n        // Oggetto da passare come 'this' ad un evento\n        this.eventBind = { el: this.el, clearState: this.clearState.bind(this) }\n        this.__start = this.start.bind(this)\n        this.__move = this.move.bind(this)\n        this.__finish = this.finish.bind(this)\n\n        this.clear()\n        this.clearState()\n        this.unlock()\n    }\n\n\n    /**\n     * Eventi 'touchstart' 'mousedown'\n     */\n    start(event)\n    {\n        if(!this.locked) {\n            this.started = this.utils.create(event, this.strictMode ? this.el : null, this.started)\n\n            this.started.updated && ( this.mooving = true )\n\n            // Binderà l'evento press solo se non sarà invocato nè l'evento move, nè finish\n            !this.started.updated && ( this.pressEmitted = window.setTimeout(this.press.bind(this), ALOETOUCH_PRESS_MIN_TIME) )\n\n            this.emit('touchstart')\n        }\n    }\n\n    /**\n     * Eventi 'touchmove'\n     */\n    move(event)\n    {\n        // Controllo se sono settate le coordinate del touch all'evento start e bindo le nuove coordinate (ended)\n        !this.locked && this.prepareMove(event, ended => {\n            if(this.isPermissible())\n            {\n                event.preventDefault()\n                event.stopPropagation()\n\n                this.mooving = true\n                this.dispatch() // Smisto gli eventi 'mobili': pan, rotate, pitch\n            } else {\n                this.mooving = false // L'evento non può più essere prevenuto\n            }\n        })\n    }\n\n    /**\n     * Eseguo la funczione moove solo se sono settate le coordinate iniziali\n     */\n    prepareMove(event, callback)\n    {\n        this.started && callback.call( this, ( this.ended = this.utils.create(event, this.el) ) )\n        !this.started && this.clear()\n    }\n\n    /**\n     * Questa funzionalitò è molto importante poiché previene che l'evento 'touchmove'\n     * prevenga l'azione di default dell'evento (e quindi blocchi lo scrolling)\n     */\n    isPermissible()\n    {\n        let time = this.ended.time - this.started.time\n        let isHorizontal = this.utils.isHorizontal(this.started, this.ended); // Se lo scrolling è orizzontale implica che l'utente non sta scorrendo\n                                                                              // verticalmente la pagina, quindi è possibile bloccare lo scrolling\n        return this.mooving || (\n            this.mooving === null                              // Il caso in cui questa variabile risulta === null avviene solo la priva volta che viene invocata la fuonzione move,\n            && ( isHorizontal || time > ALOETOUCH_MIN_TIME )   // infatti viene nullata con la funzione clear presente nel metodo start. Questa cndizione è necessaria perché il metodo\n        )                                                     // preventDefault() di Event non può essere invocato in un secondo stadio dell'evento 'touchmove', ma solo la prima volta\n    }\n\n    /**\n     * Smisto gli eventi in 'touchmove' in base al numero di tocchi\n     */\n    dispatch()\n    {\n        let howManyTouches = this.utils.howManyTouches(this.ended),\n            pan = null, pinch = null, rotate = null\n\n        if(howManyTouches == 1) {\n            pan = this.utils.coords(this.started, this.ended)\n        } else if(howManyTouches == 2) {\n            pan = this.utils.coords(this.started, this.ended),\n            pinch = this.utils.distanceBetween(this.started, this.ended),\n            rotate = this.utils.rotation(this.started, this.ended)\n        }\n\n        this.setStateAndEmit({ pan, pinch, rotate })\n        return this.emit('touchmove', this.stateValue)\n    }\n\n    /**\n     * Termino l'evento\n     */\n    finish(event)\n    {\n        if(!this.locked && this.started)  // Controllo che vale anche per l'evento touchmove\n        {\n            this.mooving && this.swipe()\n            this.mooving === null && this.tap()\n\n            this.stateValue = this.state.refresh(this.stateValue, this.events.state)\n\n            this.emit('touchend')\n        }\n\n        this.clear()\n    }\n\n    /**\n     * Reset delle variabili\n     */\n    clear()\n    {\n        this.pressEmitted && window.clearTimeout(this.pressEmitted) // Cancello l'evento press\n\n        this.started = null\n        this.ended = null\n        this.mooving = null\n        this.pressEmitted = null\n    }\n\n    /* -------------------------------------\n     *  Eventi\n     * ------------------------------------- */\n\n    isLock() {\n        return this.locked\n    }\n\n    /**\n     * Rimuove i listener degli eventi\n     */\n    lock()\n    {\n        if(!this.locked) {\n            this.off('touchstart', this.__start, true)\n            this.off('touchmove', this.__move)\n            this.off('touchend touchcancel', this.__finish, true)\n            this.locked = true\n        }\n    }\n\n    /**\n     * Binda gli eventi\n     */\n    unlock()\n    {\n        if(this.locked) {\n            this.on('touchstart', this.__start, true)\n            this.on('touchmove', this.__move)\n            this.on('touchend touchcancel', this.__finish, true)\n            this.locked = false\n        }\n    }\n\n    /* -------------------------------------\n     *  State\n     * ------------------------------------- */\n\n    /**\n     * Setta i valore dello state ed emette gli eventi\n     */\n    setStateAndEmit(eventValues)\n    {\n        this.stateValue = this.state.set(this.stateValue, eventValues, this.events.state)\n\n        eventValues.pan && this.pan(eventValues.pan, this.stateValue)\n        eventValues.pinch && this.pinch(eventValues.pinch, this.stateValue)\n        eventValues.rotate && this.rotate(eventValues.rotate, this.stateValue)\n    }\n\n    /**\n     * Setta uno state\n     */\n    setState(state)\n    {\n        Object.keys(state).forEach( s => {\n            this.events.state[s] = state[s]\n        })\n    }\n\n\n    /**\n     * Rimuove uno state\n     */\n    removeState(name)\n    {\n        delete this.state[name]\n        delete this.stateValue[name]\n    }\n\n    /**\n     * Cancella lo state con ivalori correnti\n     */\n    clearState()\n    {\n        this.stateValue = this.state.create()\n    }\n\n    /* -------------------------------------\n     *  Eventi\n     * ------------------------------------- */\n\n    /**\n     * Valido l'evento tap\n     */\n    tap()\n    {\n        let howManyTouches = this.utils.howManyTouches(this.ended)\n        let time = Date.now() - this.started.time\n\n        if( howManyTouches == 1 && time < ALOETOUCH_PRESS_MIN_TIME )\n            this.emit('tap')\n    }\n\n    /**\n     * Evento press\n     */\n    press()\n    {\n        if(this.pressEmitted) {\n            this.emit('press', null)\n            this.pressEmitted = null\n        }\n    }\n\n    /**\n     * Valido l'evento swipe\n     */\n    swipe()\n    {\n        let coords = this.utils.coords(this.started, this.ended)\n\n        if( Math.abs(coords.x) > ALOETOUCH_MIN_SWIPE_DISTANCE )\n        {\n            let stringDirection = this.utils.stringDirection(coords)\n\n            this.emit('swipe' + stringDirection.x, coords)\n            this.emit('swipe' + stringDirection.y, coords)\n        }\n    }\n\n    /**\n     * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n     */\n    pan(coords)\n    {\n        return this.emit('pan', coords)\n    }\n\n    /**\n     * L'evento pinch non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n     */\n    pinch(distance)\n    {\n        return this.emit('pinch', distance)\n    }\n\n    /**\n     * L'evento rotate non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n     */\n    rotate(rotation)\n    {\n        return this.emit('rotate', rotation)\n    }\n\n    /* -------------------------------------\n     *  Bindaggio ed emissione eventi\n     * ------------------------------------- */\n\n    /**\n     * Emette un evento se settato\n     */\n    emit(event, data)\n    {\n        this.events[event] && this.events[event](data, this.stateValue)\n\n        return data\n    }\n\n    /**\n     * Aggiunge un evento\n     */\n    attach(event, callable)\n    {\n        this.events[event] = callable\n    }\n    /**\n     * Rimuove un evento\n     */\n    detach(event)\n    {\n        this.events[event] && delete this.events[event]\n    }\n\n    /**\n     * Bindo gli eventi all'elemento\n     */\n    on(events, handler, passive)\n    {\n        events.split(' ').forEach( e => this.el.addEventListener(e, handler, passive ? { passive: true } : false) )\n    }\n\n    /**\n     * Rimuovo i listeners\n     */\n    off(events, handler, passive)\n    {\n        events.split(' ').forEach(e => this.el.removeEventListener(e, handler, passive ? { passive: true } : false))\n    }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/aloetouch.object.js","let AloeTouchState = {\n\n    /**\n     * Crea un oggetto vuoto per il contenimento dei valori degli eventi pan, pinch e rotate\n     */\n    new()\n    {\n        return {\n            pan: { x: null, y: null },\n            pinch: null,\n            rotate: null\n        }\n    },\n\n    /**\n     * Crea un nuovo oggetto che conterra i valori precedenti degli eventi\n     */\n    create()\n    {\n        return Object.assign({}, AloeTouchState.new(), { old: AloeTouchState.new() })\n    },\n\n    /**\n     * Binda i nuovi valori dall'evento corrente (chiamato da touchmove->dispatch->emit) con i valori precendenti\n     *\n     * @param {ATS} state\n     * @param {ATEvent} event\n     */\n    set(state, event, customState)\n    {\n        event.rotate && ( state.rotate = event.rotate + state.old.rotate )\n        event.pinch && ( state.pinch = event.pinch + state.old.pinch )\n        event.pan && event.pan.x && ( state.pan.x = event.pan.x + state.old.pan.x )\n        event.pan && event.pan.y && ( state.pan.y = event.pan.y + state.old.pan.y )\n\n        // Aggiungo gli state settati dall'utente\n        Object.keys(customState).forEach( cs => state[cs] = customState[cs](state) )\n\n        return state\n    },\n\n    /**\n     * All'evento touchend setto i valori precendeti con l'ultimo settato\n     *\n     * @param {ATS} state\n     */\n    refresh(state)\n    {\n        state.old = AloeTouchState.copyState(state)\n\n        return state\n    },\n\n    /**\n     * Copio l'oggetto state\n     */\n    copyState(state)\n    {\n        let n = {}\n        Object.keys(state).forEach( k => {\n            k != 'old' && ( n[k] = typeof(state[k]) === 'object' && state[k] !== null ? AloeTouchState.copyState(state[k]) : state[k] )\n        })\n        return n\n    }\n\n}\n\nexport default {\n    set: AloeTouchState.set,\n    create: AloeTouchState.create,\n    refresh: AloeTouchState.refresh\n}\n\n\n// WEBPACK FOOTER //\n// ./src/aloetouch.state.js","let AloeTouchUtils = {\n    /**\n     * Crea (o modifico) l'oggetto ATO (AloeTouchObject) contenente la Touchlist\n     *\n     * @param  {Event}      event\n     * @param  {DOMElement} element\n     * @param  {ATO?}       oldATO\n     */\n    create(event, element, oldATO)\n    {\n        let ATO = oldATO ? Object.assign({}, oldATO, { updated: true }) : { time: Date.now() }\n\n        ATO.touches = AloeTouchUtils.getTouches(event.touches ? event.touches : [event], element)\n\n        return ATO\n    },\n\n    /**\n     * Preleva la touchlist (modificata) dall'evento\n     *\n     * @param  {Touclist}  touches [description]\n     * @param  {DOMElement} element L'emento esiste solo se è settato STRICT\n     * @return {Array}\n     */\n    getTouches(touches, element){\n        let data = []\n\n        Object.keys(touches).forEach(e => {\n            AloeTouchUtils.validate(touches[e], element) && data.push({\n                clientX: touches[e].clientX,\n                clientY: touches[e].clientY\n            })\n        })\n\n        return data\n    },\n\n    /**\n     * Aggiunge l'oggetto Touch se rispetta la validazone\n     *\n     * @param {Touch}      touch\n     * @param {DOMElement} element\n     */\n    validate(touch, element)\n    {\n        return touch && ( touch.clientX || touch.clientY ) && (!element || element == touch.target)\n    },\n\n    /**\n     * Ritorna la differenza delle coordinate tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    coords(ATOstart, ATOend)\n    {\n        return AloeTouchUtils.diff(ATOstart.touches[0], ATOend.touches[0])\n    },\n\n    /**\n     * Ritorna una coordinata basata sulla differenza tra due punti\n     *\n     * @param {ATO.touch} pointA\n     * @param {ATO.touch} pointB\n     */\n    diff(pointA, pointB)\n    {\n        return {\n            x: pointB.clientX - pointA.clientX,\n            y: pointB.clientY - pointA.clientY\n        }\n    },\n\n    /**\n     * Ritorna il numero di touch\n     *\n     * @param {ATO} ATOe\n     */\n    howManyTouches(ATO)\n    {\n        return ATO && ATO.touches ? ATO.touches.length : 0\n    },\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente verticale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isVertical(ATOstart, ATOend)\n    {\n        let coords = AloeTouchUtils.coords(ATOstart, ATOend)\n        return Math.abs(coords.y) > Math.abs(coords.x)\n    },\n\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente orizzontale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isHorizontal(ATOstart, ATOend)\n    {\n        let coords = AloeTouchUtils.coords(ATOstart, ATOend)\n        return Math.abs(coords.x) > Math.abs(coords.y)\n    },\n\n    /**\n     * Ritorna la direzione in base al valore delle coordinate\n     *\n     * @param {Object{x,y} } coords\n     */\n    stringDirection(coords)\n    {\n        return {\n            x: coords.x <= 0 ? 'Left' : 'Right',\n            y: coords.y <= 0 ? 'Top' : 'Bottom'\n        }\n    },\n\n    /* -------------------------------------\n     *  Helper per eventi\n     * ------------------------------------- */\n\n    /**\n     * Ritorna la distanza tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    distanceBetween(ATOstart, ATOend)\n    {\n        return AloeTouchUtils.distance(ATOend) - AloeTouchUtils.distance(ATOstart)\n    },\n\n    /**\n     * Ritorna la distanza vettoriale tra due coordinata\n     *\n     * @param {ATO} ATO\n     */\n    distance(ATO)\n    {\n        let distance = AloeTouchUtils.diff(ATO.touches[0], ATO.touches[1])\n        return Math.sqrt( Math.pow(distance.x, 2) +  Math.pow(distance.y, 2) )\n    },\n\n    /**\n     * Ritorna la direzione tangente tra due coordinate\n     *\n     * @param {ATO} ATO\n     */\n    direction(ATO)\n    {\n        let distance = AloeTouchUtils.diff(ATO.touches[0], ATO.touches[1])\n        return Math.atan2( distance.y, distance.x ) * 180 / Math.PI;\n    },\n\n    /**\n     * Ritorna l'angolo di rotazione tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    rotation(ATOstart, ATOend)\n    {\n        return AloeTouchUtils.direction(ATOend) - AloeTouchUtils.direction(ATOstart)\n    }\n}\n\nexport default {\n    create: AloeTouchUtils.create,\n    coords: AloeTouchUtils.coords,\n    howManyTouches: AloeTouchUtils.howManyTouches,\n    isVertical: AloeTouchUtils.isVertical,\n    isHorizontal: AloeTouchUtils.isHorizontal,\n    stringDirection: AloeTouchUtils.stringDirection,\n    distanceBetween: AloeTouchUtils.distanceBetween,\n    distance: AloeTouchUtils.distance,\n    direction: AloeTouchUtils.direction,\n    rotation: AloeTouchUtils.rotation,\n}\n\n\n// WEBPACK FOOTER //\n// ./src/aloetouch.utils.js","import AloeTouch from './src/aloetouch'\n\nwindow.AloeTouch = AloeTouch\n\n\n// WEBPACK FOOTER //\n// ./index.js"],"sourceRoot":""}