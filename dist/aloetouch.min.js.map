{"version":3,"sources":["webpack:///dist/aloetouch.min.js","webpack:///webpack/bootstrap 915eadc02b214556f81a","webpack:///./src/AloeTouch.js","webpack:///./src/AloeTouchObject.js","webpack:///./src/services/state.js","webpack:///./src/services/utils.js","webpack:///./index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireDefault","obj","default","_AloeTouchObject","_AloeTouchObject2","AloeTouch","length","list","bind","element","events","strict","id","$id","attach","caller","detach","setState","getState","removeState","clearState","isLock","lock","unlock","$ref","fn","data","this","unbind","aloetouchobject","getIds","aloetouchobjects","flag","constructor","map","ato","filter","lockExcept","ids","indexOf","lockOnly","unlockExcept","unlockOnly","callable","keys","forEach","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","_utils","_utils2","_state","_state2","ALOETOUCH_MIN_TIME","ALOETOUCH_PRESS_MIN_TIME","ALOETOUCH_MIN_SWIPE_DISTANCE","AloeTouchObject","el","document","querySelector","strictMode","state","locked","utils","start","move","finish","clear","event","$event","started","create","updated","mooving","pressEmitted","window","setTimeout","press","emit","_this","prepareMove","ended","isPermissible","preventDefault","dispatch","callback","time","isHorizontal","fingers","howManyTouches","pan","pinch","rotate","coords","distanceBetween","rotation","setStateAndEmit","eventValues","stateValue","set","pan2","swipe","tap","refresh","clearTimeout","off","on","_this2","Date","now","Math","abs","x","stringDirection","y","distance","setEventData","directions","duration","touches","clientX","clientY","assign","$state","_this3","e","_this4","handler","passive","_this5","split","addEventListener","_this6","removeEventListener","_typeof","Symbol","iterator","State","init","$old","customState","cs","copyState","k","Utils","oldATO","ATO","getTouches","validate","push","touch","ATOstart","ATOend","diff","pointA","pointB","isVertical","scalar","a","b","sqrt","pow","direction","angle","atan2","PI","_AloeTouch","_AloeTouch2"],"mappings":"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","file":"./dist/aloetouch.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AloeTouchObject = __webpack_require__(1);\n\nvar _AloeTouchObject2 = _interopRequireDefault(_AloeTouchObject);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * AloeTouch\n */\nvar AloeTouch = {\n\n  /**\n   * Contiene il numero di elementi\n   *\n   * @type {Number}\n   */\n  length: 0,\n\n  /**\n   * Lista degli AloeTouchObject\n   *\n   * @type {Object}\n   */\n  list: {},\n\n  /**\n   * Binda un nuovo elemento\n   *\n   * @param {DOMElement} element Elemento da bindare\n   * @param {Object}     events  Eventi da assegnare all'elemento\n   * @param {Boolean}    strict  Se settata, valida l'evento solo se il target del touch è l'elemento bindato\n   */\n  bind: function bind(element, events, strict) {\n    var id = ++AloeTouch.length;\n\n    return AloeTouch.list[id] = {\n      $id: id, // id dell'oggetto\n      attach: AloeTouch.caller('attach'), // Binda un evento\n      detach: AloeTouch.caller('detach'), // Rimuovo il listener di un evento\n      setState: AloeTouch.caller('setState'), // Setta uno stato personalizzato\n      getState: AloeTouch.caller('getState'), // Setta uno stato personalizzato\n      removeState: AloeTouch.caller('removeState'), // Rimuove uno state\n      clearState: AloeTouch.caller('clearState'), // Azzera la variabile state\n      isLock: AloeTouch.caller('isLock'), // Rimuove i listener per tutti gli eventi\n      lock: AloeTouch.caller('lock'), // Rimuove i listener per tutti gli eventi\n      unlock: AloeTouch.caller('unlock'), // Rebinda i listener per gli eventii\n      $ref: new _AloeTouchObject2.default(id, element, events, strict) // refrenza all'oggetto\n    };\n  },\n\n\n  /**\n   * Chiama una funzione bindando il riferimento dell'oggetto chimante\n   * @param  {String} fn\n   * @return {Function}\n   */\n  caller: function caller(fn) {\n    return function (data) {\n      this.$ref && this.$ref[fn](data);\n    };\n  },\n\n\n  /**\n   * Rimuove i listener ad un elemento\n   *\n   * @param {AloeTouchObject or Numer} aloetouchobject\n   * @return {Boolean} true se l'elemento è stato rimosso, falso altrimenti\n   */\n  unbind: function unbind(aloetouchobject) {\n    var id = this.getIds(aloetouchobject, true);\n\n    if (id) {\n      AloeTouch.list[id].lock();\n      delete AloeTouch.list[id].$ref;\n      delete AloeTouch.list[id];\n      return true;\n    }\n\n    return false;\n  },\n\n\n  /**\n   * Ritorna un elemento in base al suo id\n   *\n   * @param {Number} id\n   */\n  get: function get(id) {\n    return AloeTouch.list.hasOwnProperty(id) ? AloeTouch.list[id] : null;\n  },\n\n\n  /**\n   * Ritorna un' array di id\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   * @param {Boolean} flag Ritorna un id se l'array ha lunghezza pari a uno\n   * @return {Array<Number> or Number}\n   */\n  getIds: function getIds(aloetouchobjects, flag) {\n    aloetouchobjects = aloetouchobjects.constructor.name === 'Array' ? aloetouchobjects : [aloetouchobjects];\n    aloetouchobjects = aloetouchobjects.map(function (ato) {\n      return typeof ato === 'number' ? AloeTouch.get(ato) ? ato : null : ato.$ref ? ato.$id : null;\n    });\n    aloetouchobjects = aloetouchobjects.filter(function (id) {\n      return !!id;\n    });\n\n    return flag ? aloetouchobjects.length == 1 ? aloetouchobjects[0] : aloetouchobjects : aloetouchobjects;\n  },\n\n\n  /**\n   * Blocca un oggetto singolo o tutti\n   *\n   * @param {Number?} id Blocca gli eventi per l'oggetto con id 'id'\n   */\n  lock: function lock(id) {\n    id ? AloeTouch.list[id].lock() : AloeTouch.map(function (ato) {\n      return ato.lock();\n    });\n  },\n\n\n  /**\n   *  Blocca tutti gli oggetti tranne quelli presenti nell'array aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  lockExcept: function lockExcept(aloetouchobjects) {\n    ids = this.getIds(ids) || [];\n\n    AloeTouch.map(function (ato, id) {\n      return ato[ids.indexOf(id) == -1 ? 'unlock' : 'lock']();\n    });\n  },\n\n\n  /**\n   * Blocca solo gli oggetti presenti in aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  lockOnly: function lockOnly(aloetouchobjects) {\n    ids = this.getIds(ids) || [];\n\n    AloeTouch.map(function (ato, id) {\n      return ato[ids.indexOf(id) >= 0 ? 'lock' : 'unlock']();\n    });\n  },\n\n\n  /**\n   * Abilita li eventi ad un oggetto singolo o tutti\n   *\n   * @param {Number?} id\n   */\n  unlock: function unlock(id) {\n    id ? AloeTouch.list[id].unlock() : AloeTouch.map(function (ato) {\n      return ato.unlock();\n    });\n  },\n\n\n  /**\n   * Abilita gli eventi tranne agli elementi presenti nell'array aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  unlockExcept: function unlockExcept(aloetouchobjects) {\n    AloeTouch.lockOnly(aloetouchobjects);\n  },\n\n\n  /**\n   * Abilita gli eventi solo agli elementi presenti nell'array aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  unlockOnly: function unlockOnly(aloetouchobjects) {\n    AloeTouch.lockExcept(aloetouchobjects);\n  },\n\n\n  /**\n   * Mappa tutti li elementi bindati\n   *\n   * @param {Callable(AloeTouchObject, id)}\n   */\n  map: function map(callable) {\n    Object.keys(AloeTouch.list).forEach(function (id) {\n      return callable(AloeTouch.list[id], id);\n    });\n  }\n};\n\nexports.default = AloeTouch;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(3);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _state = __webpack_require__(2);\n\nvar _state2 = _interopRequireDefault(_state);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * La durata minimina per bindare un evento\n * Utile a non prevenire lo scrolling\n * @type {Number}\n */\nvar ALOETOUCH_MIN_TIME = 85;\n\n/**\n * Tempo minimo per bindare l'evento press\n * @type {Number}\n */\nvar ALOETOUCH_PRESS_MIN_TIME = 600;\n\n/**\n * Distanza minima per bindare l'evento swipe[Direction]\n * @type {Number}\n */\nvar ALOETOUCH_MIN_SWIPE_DISTANCE = 20;\n\n/**\n * Assegna gli eventi touch ad un elemento\n *\n * GLi eventi disponibili sono:\n * Touch singolo\n *     tap, press, pan, swipeLeft, swipeRight, swipeTop, swipeBottom\n * Touch doppio\n *     pinch, rotate\n */\n\nvar AloeTouchObject = function () {\n\n    /**\n     * Binda gli eventi all'elemento\n     * @param {DomElement} element\n     * @param {Object} events Oggetto che contiene le funzioni es. { tap: ..., swipeLeft: ..., rotate: ... }\n     * @param {Boolean} strict Aggiunge le coordinate del tuoch solo se il target è uguale all'elemento bindato\n     */\n    function AloeTouchObject(id, element, events, strict) {\n        _classCallCheck(this, AloeTouchObject);\n\n        this.id = id;\n        this.el = typeof element === 'string' ? document.querySelector(element) : element;\n        this.events = events || {};\n        this.strictMode = strict || false;\n        this.events.state = this.events.state || {};\n        this.locked = true;\n\n        // Services\n        this.utils = _utils2.default;\n        this.state = _state2.default;\n\n        this.start = this.start.bind(this);\n        this.move = this.move.bind(this);\n        this.finish = this.finish.bind(this);\n\n        this.clear();\n        this.clearState();\n        this.unlock();\n    }\n\n    /**\n     * Eventi 'touchstart' 'mousedown'\n     */\n\n\n    _createClass(AloeTouchObject, [{\n        key: 'start',\n        value: function start(event) {\n            if (!this.locked) {\n                this.$event = event;\n                this.started = this.utils.create(event, this.strictMode ? this.el : null, this.started);\n                this.started.updated ? this.mooving = true : this.pressEmitted = window.setTimeout(this.press.bind(this), ALOETOUCH_PRESS_MIN_TIME);\n                // Binderà l'evento press solo se non sarà invocato nè l'evento move, nè finish\n                this.emit('start');\n            }\n        }\n\n        /**\n         * Eventi 'touchmove'\n         */\n\n    }, {\n        key: 'move',\n        value: function move(event) {\n            var _this = this;\n\n            // Controllo se sono settate le coordinate del touch all'evento start e bindo le nuove coordinate (ended)\n            !this.locked && this.prepareMove(event, function (ended) {\n                if (_this.isPermissible()) {\n                    event.preventDefault();\n                    _this.$event = event;\n                    _this.mooving = true;\n                    _this.dispatch(); // Smisto gli eventi 'mobili': pan, rotate, pitch\n                } else {\n                    _this.mooving = false; // L'evento non può più essere prevenuto\n                }\n            });\n        }\n\n        /**\n         * Eseguo la funczione moove solo se sono settate le coordinate iniziali\n         */\n\n    }, {\n        key: 'prepareMove',\n        value: function prepareMove(event, callback) {\n            this.started ? callback(this.ended = this.utils.create(event, this.strictMode ? this.el : null)) : this.clear();\n        }\n\n        /**\n         * Questa funzionalitò è molto importante poiché previene che l'evento 'touchmove'\n         * prevenga l'azione di default dell'evento (e quindi blocchi lo scrolling)\n         */\n\n    }, {\n        key: 'isPermissible',\n        value: function isPermissible() {\n            var time = this.ended.time - this.started.time;\n            var isHorizontal = this.utils.isHorizontal(this.started, this.ended); // Se lo scrolling è orizzontale implica che l'utente non sta scorrendo\n            // verticalmente la pagina, quindi è possibile bloccare lo scrolling\n            return this.mooving || this.mooving === null // Il caso in cui questa variabile risulta === null avviene solo la priva volta che viene invocata la fuonzione move,\n            && (isHorizontal || time > ALOETOUCH_MIN_TIME) // infatti viene nullata con la funzione clear presente nel metodo start. Questa cndizione è necessaria perché il metodo\n            ; // preventDefault() di Event non può essere invocato in un secondo stadio dell'evento 'touchmove', ma solo la prima volta\n        }\n\n        /**\n         * Smisto gli eventi in 'touchmove' in base al numero di tocchi\n         */\n\n    }, {\n        key: 'dispatch',\n        value: function dispatch() {\n            var fingers = this.utils.howManyTouches(this.ended),\n                pan = null,\n                pinch = null,\n                rotate = null;\n\n            if (fingers == 1) {\n                pan = this.utils.coords(this.started, this.ended);\n            } else if (fingers == 2) {\n                pan = this.utils.coords(this.started, this.ended);\n                pinch = this.utils.distanceBetween(this.started, this.ended);\n                rotate = this.utils.rotation(this.started, this.ended);\n            }\n\n            this.setStateAndEmit({ pan: pan, pinch: pinch, rotate: rotate }, fingers);\n            this.emit('move');\n        }\n\n        /**\n         * Setta i valore dello state ed emette gli eventi\n         *\n         * @param {Object} eventValues Valori da emettere\n         */\n\n    }, {\n        key: 'setStateAndEmit',\n        value: function setStateAndEmit(eventValues, fingers) {\n            this.stateValue = this.state.set(this.stateValue, eventValues, this.events.state);\n\n            fingers == 1 && eventValues.pan && this.pan();\n            fingers == 2 && eventValues.pan && this.pan2();\n            eventValues.pinch && this.pinch(eventValues.pinch);\n            eventValues.rotate && this.rotate(eventValues.rotate);\n        }\n\n        /**\n         * Termino l'evento\n         */\n\n    }, {\n        key: 'finish',\n        value: function finish(event) {\n            if (!this.locked && this.started) // Controllo che vale anche per l'evento touchmove\n                {\n                    this.$event = event;\n                    this.mooving && this.swipe();\n                    this.mooving === null && this.tap();\n                    this.stateValue = this.state.refresh(this.stateValue, this.events.state); // aggiorno lo state\n                    this.emit('end');\n                }\n\n            this.clear();\n        }\n\n        /**\n         * Reset delle variabili\n         */\n\n    }, {\n        key: 'clear',\n        value: function clear() {\n            this.pressEmitted && window.clearTimeout(this.pressEmitted); // Cancello l'evento press\n\n            this.started = null;\n            this.ended = null;\n            this.mooving = null;\n            this.$event = null;\n            this.pressEmitted = null;\n        }\n\n        /* -------------------------------------\n         *  Eventi\n         * ------------------------------------- */\n\n        /**\n         * Ritorna vero se questo oggetto è bloccato, falso altrimenti\n         *\n         * @return {Boolean}\n         */\n\n    }, {\n        key: 'isLock',\n        value: function isLock() {\n            return this.locked;\n        }\n\n        /**\n         * Rimuove i listener degli eventi\n         */\n\n    }, {\n        key: 'lock',\n        value: function lock() {\n            if (!this.locked) {\n                this.off('touchstart', this.start, true);\n                this.off('touchmove', this.move);\n                this.off('touchend touchcancel', this.finish, true);\n                this.locked = true;\n            }\n        }\n\n        /**\n         * Binda gli eventi\n         */\n\n    }, {\n        key: 'unlock',\n        value: function unlock() {\n            if (this.locked) {\n                this.on('touchstart', this.start, true);\n                this.on('touchmove', this.move);\n                this.on('touchend touchcancel', this.finish, true);\n                this.locked = false;\n            }\n        }\n\n        /* -------------------------------------\n         *  State\n         * ------------------------------------- */\n\n        /**\n         * Setta uno state\n         *\n         * @param {Object} state\n         */\n\n    }, {\n        key: 'setState',\n        value: function setState(state) {\n            var _this2 = this;\n\n            Object.keys(state).forEach(function (s) {\n                return _this2.events.state[s] = state[s];\n            });\n        }\n\n        /**\n         * Ritorna i valori dello state corrente\n         */\n\n    }, {\n        key: 'getState',\n        value: function getState() {\n            return this.stateValue;\n        }\n\n        /**\n         * Rimuove uno state\n         *\n         * @param {String} name Nome dello state da rimuovere\n         */\n\n    }, {\n        key: 'removeState',\n        value: function removeState(name) {\n            this.state[name] = null;\n            this.stateValue[name] = null;\n            delete this.state[name];\n            delete this.stateValue[name];\n        }\n\n        /**\n         * Cancella lo state con ivalori correnti\n         */\n\n    }, {\n        key: 'clearState',\n        value: function clearState() {\n            this.stateValue = this.state.create();\n        }\n\n        /* -------------------------------------\n         *  Eventi\n         * ------------------------------------- */\n\n        /**\n         * Valido l'evento tap\n         */\n\n    }, {\n        key: 'tap',\n        value: function tap() {\n            var fingers = this.utils.howManyTouches(this.ended);\n            var time = Date.now() - this.started.time;\n\n            if (fingers < 2 && time < ALOETOUCH_PRESS_MIN_TIME) this.emit('tap');\n        }\n\n        /**\n         * Evento press\n         */\n\n    }, {\n        key: 'press',\n        value: function press() {\n            if (this.pressEmitted && !this.mooving) {\n                this.emit('press');\n                this.pressEmitted = null;\n            }\n        }\n\n        /**\n         * Valido l'evento swipe\n         */\n\n    }, {\n        key: 'swipe',\n        value: function swipe() {\n            var coords = this.utils.coords(this.started, this.ended);\n\n            if (Math.abs(coords.x) > ALOETOUCH_MIN_SWIPE_DISTANCE) {\n                var stringDirection = this.utils.stringDirection(coords);\n\n                this.emit('swipe' + stringDirection.x);\n                this.emit('swipe' + stringDirection.y);\n                this.emit('swipe');\n            }\n        }\n\n        /**\n         * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n          * @param {Object} coords\n         */\n\n    }, {\n        key: 'pan',\n        value: function pan() {\n            this.emit('pan');\n        }\n\n        /**\n         * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n          * @param {Object} coords\n         */\n\n    }, {\n        key: 'pan2',\n        value: function pan2() {\n            this.emit('pan2');\n        }\n\n        /**\n         * L'evento pinch non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n         *\n         * @param {Number} distance\n         */\n\n    }, {\n        key: 'pinch',\n        value: function pinch(distance) {\n            this.emit('pinch', { distance: distance });\n        }\n\n        /**\n         * L'evento rotate non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n         *\n         * @param {Number} rotation\n         */\n\n    }, {\n        key: 'rotate',\n        value: function rotate(rotation) {\n            this.emit('rotate', { rotation: rotation });\n        }\n\n        /* -------------------------------------\n         *  Bindaggio ed emissione eventi\n         * ------------------------------------- */\n\n        /**\n         * Emette un evento se settato\n         *\n         * @param {String} event Nome dell'evento da emettere\n         */\n\n    }, {\n        key: 'emit',\n        value: function emit(event, data) {\n            if (this.events[event]) {\n\n                //let result = this.events[event](data ? data : this.stateValue, data ? this.stateValue : null)\n                var result = this.events[event](this.setEventData(data));\n\n                // Prevengo la gestione degli altri eventi se - nella funzione settata dall'utente - viene restituito il booleano false\n                return result === false && this.clear();\n            }\n        }\n    }, {\n        key: 'setEventData',\n        value: function setEventData(data) {\n            var coords = void 0,\n                directions = void 0,\n                duration = void 0;\n\n            // Per l'evento tap e press\n            if (!this.ended) {\n                this.ended = this.utils.create(null);\n                coords = { x: this.started.touches[0].clientX, y: this.started.touches[0].clientY };\n            } else {\n                coords = this.utils.coords(this.started, this.ended);\n                directions = this.utils.stringDirection(coords);\n            }\n            duration = this.ended.time - this.started.time;\n\n            return Object.assign({}, {\n                el: this.el,\n                coords: coords,\n                directions: directions,\n                /*velocity: {\n                    x: coords.x / duration * 1000,\n                    y: coords.y / duration * 1000,\n                    a: (this.utils.scalar(coords.x, coords.y) / duration ) * 1000\n                },*/\n                fingers: this.utils.howManyTouches(this.ended),\n                $state: this.stateValue,\n                $event: this.$event,\n                duration: duration\n            }, data);\n        }\n\n        /**\n         * Aggiunge un evento\n         */\n\n    }, {\n        key: 'attach',\n        value: function attach(events) {\n            var _this3 = this;\n\n            Object.keys(events).forEach(function (e) {\n                return _this3.events[e] = events[e];\n            });\n        }\n        /**\n         * Rimuove un evento\n         */\n\n    }, {\n        key: 'detach',\n        value: function detach(events) {\n            var _this4 = this;\n\n            events = events.constructor.name === 'Array' ? events : [events];\n            events.forEach(function (e) {\n                return _this4.events[e] && delete _this4.events[e];\n            });\n        }\n\n        /**\n         * Bindo gli eventi all'elemento\n         */\n\n    }, {\n        key: 'on',\n        value: function on(events, handler, passive) {\n            var _this5 = this;\n\n            events.split(' ').forEach(function (e) {\n                return _this5.el.addEventListener(e, handler, passive ? { passive: true } : false);\n            });\n        }\n\n        /**\n         * Rimuovo i listeners\n         */\n\n    }, {\n        key: 'off',\n        value: function off(events, handler, passive) {\n            var _this6 = this;\n\n            events.split(' ').forEach(function (e) {\n                return _this6.el.removeEventListener(e, handler, passive ? { passive: true } : false);\n            });\n        }\n    }]);\n\n    return AloeTouchObject;\n}();\n\nexports.default = AloeTouchObject;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar State = {\n\n    /**\n     * Crea un oggetto vuoto per il contenimento dei valori degli eventi pan, pinch e rotate\n     */\n    init: function init() {\n        return {\n            pan: { x: null, y: null },\n            pinch: null,\n            rotate: null\n        };\n    },\n\n\n    /**\n     * Crea un nuovo oggetto che conterra i valori precedenti degli eventi\n     */\n    create: function create() {\n        return Object.assign({}, State.init(), { $old: State.init() });\n    },\n\n\n    /**\n     * Binda i nuovi valori dall'evento corrente (chiamato da touchmove->dispatch->emit) con i valori precendenti\n     *\n     * @param {ATS} state\n     * @param {ATEvent} event\n     */\n    set: function set(state, event, customState) {\n        event.rotate && (state.rotate = event.rotate + state.$old.rotate);\n        event.pinch && (state.pinch = event.pinch + state.$old.pinch);\n        event.pan && event.pan.x && (state.pan.x = event.pan.x + state.$old.pan.x);\n        event.pan && event.pan.y && (state.pan.y = event.pan.y + state.$old.pan.y);\n\n        // Aggiungo gli state settati dall'utente\n        Object.keys(customState).forEach(function (cs) {\n            return state[cs] = customState[cs](state);\n        });\n\n        return state;\n    },\n\n\n    /**\n     * All'evento touchend setto i valori precendeti con l'ultimo settato\n     *\n     * @param {ATS} state\n     */\n    refresh: function refresh(state) {\n        state.$old = State.copyState(state);\n\n        return state;\n    },\n\n\n    /**\n     * Copio l'oggetto state\n     */\n    copyState: function copyState(state) {\n        var n = {};\n        Object.keys(state).forEach(function (k) {\n            k != '$old' && (n[k] = _typeof(state[k]) === 'object' && state[k] !== null ? State.copyState(state[k]) : state[k]);\n        });\n        return n;\n    }\n};\n\nexports.default = {\n    set: State.set,\n    create: State.create,\n    refresh: State.refresh\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar Utils = {\n    /**\n     * Crea (o modifico) l'oggetto ATO (AloeTouchObject) contenente la Touchlist\n     *\n     * @param  {Event}      event\n     * @param  {DOMElement} element\n     * @param  {ATO?}       oldATO\n     */\n    create: function create(event, element, oldATO) {\n        var ATO = oldATO ? Object.assign({}, oldATO, { updated: true }) : { time: Date.now() };\n\n        ATO.touches = event && event.touches ? Utils.getTouches(event.touches, element) : [{ clientX: 0, clientY: 0 }];\n\n        return ATO;\n    },\n\n\n    /**\n     * Preleva la touchlist (modificata) dall'evento\n     *\n     * @param  {Touchlist}  touches [description]\n     * @param  {DOMElement} element L'emento esiste solo se è settato STRICT\n     * @return {Array}\n     */\n    getTouches: function getTouches(touches, element) {\n        var data = [];\n\n        Object.keys(touches).forEach(function (e) {\n            Utils.validate(touches[e], element) && data.push({\n                clientX: touches[e].clientX,\n                clientY: touches[e].clientY\n            });\n        });\n\n        return data;\n    },\n\n\n    /**\n     * Aggiunge l'oggetto Touch se rispetta la validazone\n     *\n     * @param {Touch}      touch\n     * @param {DOMElement} element\n     */\n    validate: function validate(touch, element) {\n        return touch && (touch.clientX || touch.clientY) && (!element || element == touch.target);\n    },\n\n\n    /**\n     * Ritorna la differenza delle coordinate tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    coords: function coords(ATOstart, ATOend) {\n        return Utils.diff(ATOstart.touches[0], ATOend.touches[0]);\n    },\n\n\n    /**\n     * Ritorna una coordinata basata sulla differenza tra due punti\n     *\n     * @param {ATO.touch} pointA\n     * @param {ATO.touch} pointB\n     */\n    diff: function diff(pointA, pointB) {\n        return {\n            x: pointB.clientX - pointA.clientX,\n            y: pointB.clientY - pointA.clientY\n        };\n    },\n\n\n    /**\n     * Ritorna il numero di touch\n     *\n     * @param {ATO} ATOe\n     */\n    howManyTouches: function howManyTouches(ATO) {\n        return ATO && ATO.touches ? ATO.touches.length : 0;\n    },\n\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente verticale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isVertical: function isVertical(ATOstart, ATOend) {\n        var coords = Utils.coords(ATOstart, ATOend);\n        return Math.abs(coords.y) > Math.abs(coords.x);\n    },\n\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente orizzontale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isHorizontal: function isHorizontal(ATOstart, ATOend) {\n        var coords = Utils.coords(ATOstart, ATOend);\n        return Math.abs(coords.x) > Math.abs(coords.y);\n    },\n\n\n    /**\n     * Ritorna la direzione in base al valore delle coordinate\n     *\n     * @param {Object{x,y} } coords\n     */\n    stringDirection: function stringDirection(coords) {\n        return {\n            x: coords.x <= 0 ? 'Left' : 'Right',\n            y: coords.y <= 0 ? 'Top' : 'Bottom'\n        };\n    },\n\n\n    /* -------------------------------------\n     *  Helper per eventi\n     * ------------------------------------- */\n\n    /**\n     * Ritorna la distanza tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    distanceBetween: function distanceBetween(ATOstart, ATOend) {\n        return Utils.distance(ATOend) - Utils.distance(ATOstart);\n    },\n\n\n    /**\n     * Ritorna la distanza vettoriale tra due coordinata\n     *\n     * @param {ATO} ATO\n     */\n    distance: function distance(ATO) {\n        var distance = Utils.diff(ATO.touches[0], ATO.touches[1]);\n        return Utils.scalar(distance.x, distance.y);\n    },\n\n\n    /**\n     * Distanza scalare\n     */\n    scalar: function scalar(a, b) {\n        return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n    },\n\n\n    /**\n     * Ritorna la direzione tangente tra due coordinate\n     *\n     * @param {ATO} ATO\n     */\n    direction: function direction(ATO) {\n        var distance = Utils.diff(ATO.touches[0], ATO.touches[1]);\n        return Utils.angle(distance.x, distance.y);\n    },\n\n\n    /**\n     * Angolo\n     */\n    angle: function angle(a, b) {\n        return Math.atan2(b, a) * 180 / Math.PI;\n    },\n\n\n    /**\n     * Ritorna l'angolo di rotazione tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    rotation: function rotation(ATOstart, ATOend) {\n        return Utils.direction(ATOend) - Utils.direction(ATOstart);\n    }\n};\n\nexports.default = {\n    create: Utils.create,\n    coords: Utils.coords,\n    howManyTouches: Utils.howManyTouches,\n    isVertical: Utils.isVertical,\n    isHorizontal: Utils.isHorizontal,\n    stringDirection: Utils.stringDirection,\n    distanceBetween: Utils.distanceBetween,\n    direction: Utils.direction,\n    rotation: Utils.rotation,\n    angle: Utils.angle,\n    scalar: Utils.scalar\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _AloeTouch = __webpack_require__(0);\n\nvar _AloeTouch2 = _interopRequireDefault(_AloeTouch);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.AloeTouch = _AloeTouch2.default;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dist/aloetouch.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 915eadc02b214556f81a","import AloeTouchObject from './AloeTouchObject'\n\n/**\n * AloeTouch\n */\nlet AloeTouch = {\n\n    /**\n     * Contiene il numero di elementi\n     *\n     * @type {Number}\n     */\n    length: 0,\n\n    /**\n     * Lista degli AloeTouchObject\n     *\n     * @type {Object}\n     */\n    list: {},\n\n    /**\n     * Binda un nuovo elemento\n     *\n     * @param {DOMElement} element Elemento da bindare\n     * @param {Object}     events  Eventi da assegnare all'elemento\n     * @param {Boolean}    strict  Se settata, valida l'evento solo se il target del touch è l'elemento bindato\n     */\n    bind(element, events, strict)\n    {\n        let id = ++AloeTouch.length\n\n        return ( AloeTouch.list[id] = {\n                    $id: id,                              // id dell'oggetto\n                 attach: AloeTouch.caller('attach'),      // Binda un evento\n                 detach: AloeTouch.caller('detach'),      // Rimuovo il listener di un evento\n               setState: AloeTouch.caller('setState'),    // Setta uno stato personalizzato\n               getState: AloeTouch.caller('getState'),    // Setta uno stato personalizzato\n            removeState: AloeTouch.caller('removeState'), // Rimuove uno state\n             clearState: AloeTouch.caller('clearState'),  // Azzera la variabile state\n                 isLock: AloeTouch.caller('isLock'),      // Rimuove i listener per tutti gli eventi\n                   lock: AloeTouch.caller('lock'),        // Rimuove i listener per tutti gli eventi\n                 unlock: AloeTouch.caller('unlock'),      // Rebinda i listener per gli eventii\n                   $ref: new AloeTouchObject( id, element, events, strict )  // refrenza all'oggetto\n        } )\n    },\n\n    /**\n     * Chiama una funzione bindando il riferimento dell'oggetto chimante\n     * @param  {String} fn\n     * @return {Function}\n     */\n    caller(fn)\n    {\n        return function(data) {\n            this.$ref && this.$ref[fn](data)\n        }\n    },\n\n    /**\n     * Rimuove i listener ad un elemento\n     *\n     * @param {AloeTouchObject or Numer} aloetouchobject\n     * @return {Boolean} true se l'elemento è stato rimosso, falso altrimenti\n     */\n    unbind(aloetouchobject)\n    {\n        let id = this.getIds(aloetouchobject, true)\n\n        if(id) {\n            AloeTouch.list[id].lock()\n            delete AloeTouch.list[id].$ref\n            delete AloeTouch.list[id]\n            return true\n        }\n\n        return false\n    },\n\n    /**\n     * Ritorna un elemento in base al suo id\n     *\n     * @param {Number} id\n     */\n    get(id)\n    {\n        return AloeTouch.list.hasOwnProperty(id) ? AloeTouch.list[id] : null\n    },\n\n    /**\n     * Ritorna un' array di id\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     * @param {Boolean} flag Ritorna un id se l'array ha lunghezza pari a uno\n     * @return {Array<Number> or Number}\n     */\n    getIds(aloetouchobjects, flag)\n    {\n        aloetouchobjects = aloetouchobjects.constructor.name === 'Array' ? aloetouchobjects : [aloetouchobjects]\n        aloetouchobjects = aloetouchobjects.map( ato => typeof ato === 'number' ? ( AloeTouch.get(ato) ? ato : null ) : ( ato.$ref ? ato.$id : null ) )\n        aloetouchobjects = aloetouchobjects.filter(id => !!id)\n\n        return flag ? ( aloetouchobjects.length == 1 ? aloetouchobjects[0] : aloetouchobjects ) : aloetouchobjects\n    },\n\n    /**\n     * Blocca un oggetto singolo o tutti\n     *\n     * @param {Number?} id Blocca gli eventi per l'oggetto con id 'id'\n     */\n    lock(id)\n    {\n        id ? AloeTouch.list[id].lock() : AloeTouch.map(ato => ato.lock())\n    },\n\n    /**\n     *  Blocca tutti gli oggetti tranne quelli presenti nell'array aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    lockExcept(aloetouchobjects)\n    {\n        ids = this.getIds(ids) || []\n\n        AloeTouch.map((ato, id) => ato[ids.indexOf(id) == -1 ? 'unlock' : 'lock']())\n    },\n\n    /**\n     * Blocca solo gli oggetti presenti in aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    lockOnly(aloetouchobjects)\n    {\n        ids = this.getIds(ids) || []\n\n        AloeTouch.map((ato, id) => ato[ids.indexOf(id) >= 0 ? 'lock' : 'unlock']())\n    },\n\n    /**\n     * Abilita li eventi ad un oggetto singolo o tutti\n     *\n     * @param {Number?} id\n     */\n    unlock(id)\n    {\n        id ? AloeTouch.list[id].unlock() : AloeTouch.map(ato => ato.unlock())\n    },\n\n    /**\n     * Abilita gli eventi tranne agli elementi presenti nell'array aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    unlockExcept(aloetouchobjects)\n    {\n        AloeTouch.lockOnly(aloetouchobjects)\n    },\n\n    /**\n     * Abilita gli eventi solo agli elementi presenti nell'array aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    unlockOnly(aloetouchobjects)\n    {\n        AloeTouch.lockExcept(aloetouchobjects)\n    },\n\n    /**\n     * Mappa tutti li elementi bindati\n     *\n     * @param {Callable(AloeTouchObject, id)}\n     */\n    map(callable){\n        Object.keys(AloeTouch.list).forEach(id => callable(AloeTouch.list[id], id))\n    }\n\n}\n\nexport default AloeTouch\n\n\n// WEBPACK FOOTER //\n// ./src/AloeTouch.js","import Utils from './services/utils'\nimport State from './services/state'\n\n/**\n * La durata minimina per bindare un evento\n * Utile a non prevenire lo scrolling\n * @type {Number}\n */\nconst ALOETOUCH_MIN_TIME = 85\n\n/**\n * Tempo minimo per bindare l'evento press\n * @type {Number}\n */\nconst ALOETOUCH_PRESS_MIN_TIME = 600\n\n/**\n * Distanza minima per bindare l'evento swipe[Direction]\n * @type {Number}\n */\nconst ALOETOUCH_MIN_SWIPE_DISTANCE = 20\n\n/**\n * Assegna gli eventi touch ad un elemento\n *\n * GLi eventi disponibili sono:\n * Touch singolo\n *     tap, press, pan, swipeLeft, swipeRight, swipeTop, swipeBottom\n * Touch doppio\n *     pinch, rotate\n */\nexport default class AloeTouchObject {\n\n    /**\n     * Binda gli eventi all'elemento\n     * @param {DomElement} element\n     * @param {Object} events Oggetto che contiene le funzioni es. { tap: ..., swipeLeft: ..., rotate: ... }\n     * @param {Boolean} strict Aggiunge le coordinate del tuoch solo se il target è uguale all'elemento bindato\n     */\n    constructor(id, element, events, strict)\n    {\n        this.id = id\n        this.el = typeof element === 'string' ? document.querySelector(element) : element\n        this.events = events || {}\n        this.strictMode = strict || false\n        this.events.state = this.events.state || {}\n        this.locked = true\n\n        // Services\n        this.utils = Utils\n        this.state = State\n\n        this.start = this.start.bind(this)\n        this.move = this.move.bind(this)\n        this.finish = this.finish.bind(this)\n\n        this.clear()\n        this.clearState()\n        this.unlock()\n    }\n\n\n    /**\n     * Eventi 'touchstart' 'mousedown'\n     */\n    start(event)\n    {\n        if(!this.locked) {\n            this.$event = event\n            this.started = this.utils.create(event, this.strictMode ? this.el : null, this.started)\n            this.started.updated ?( this.mooving = true ) : ( this.pressEmitted = window.setTimeout(this.press.bind(this), ALOETOUCH_PRESS_MIN_TIME) )\n            // Binderà l'evento press solo se non sarà invocato nè l'evento move, nè finish\n            this.emit('start')\n        }\n    }\n\n    /**\n     * Eventi 'touchmove'\n     */\n    move(event)\n    {\n        // Controllo se sono settate le coordinate del touch all'evento start e bindo le nuove coordinate (ended)\n        !this.locked && this.prepareMove(event, ended => {\n            if(this.isPermissible())\n            {\n                event.preventDefault()\n                this.$event = event\n                this.mooving = true\n                this.dispatch() // Smisto gli eventi 'mobili': pan, rotate, pitch\n            } else {\n                this.mooving = false // L'evento non può più essere prevenuto\n            }\n        })\n    }\n\n    /**\n     * Eseguo la funczione moove solo se sono settate le coordinate iniziali\n     */\n    prepareMove(event, callback)\n    {\n        this.started ? callback((this.ended = this.utils.create(event, this.strictMode ? this.el : null))) : this.clear()\n    }\n\n    /**\n     * Questa funzionalitò è molto importante poiché previene che l'evento 'touchmove'\n     * prevenga l'azione di default dell'evento (e quindi blocchi lo scrolling)\n     */\n    isPermissible()\n    {\n        let time = this.ended.time - this.started.time\n        let isHorizontal = this.utils.isHorizontal(this.started, this.ended); // Se lo scrolling è orizzontale implica che l'utente non sta scorrendo\n                                                                              // verticalmente la pagina, quindi è possibile bloccare lo scrolling\n        return this.mooving || (\n            this.mooving === null                              // Il caso in cui questa variabile risulta === null avviene solo la priva volta che viene invocata la fuonzione move,\n            && ( isHorizontal || time > ALOETOUCH_MIN_TIME )   // infatti viene nullata con la funzione clear presente nel metodo start. Questa cndizione è necessaria perché il metodo\n        )                                                      // preventDefault() di Event non può essere invocato in un secondo stadio dell'evento 'touchmove', ma solo la prima volta\n    }\n\n    /**\n     * Smisto gli eventi in 'touchmove' in base al numero di tocchi\n     */\n    dispatch()\n    {\n        let fingers = this.utils.howManyTouches(this.ended),\n            pan = null, pinch = null, rotate = null\n\n        if(fingers == 1) {\n            pan = this.utils.coords(this.started, this.ended)\n        } else if(fingers == 2) {\n            pan = this.utils.coords(this.started, this.ended)\n            pinch = this.utils.distanceBetween(this.started, this.ended)\n            rotate = this.utils.rotation(this.started, this.ended)\n        }\n\n        this.setStateAndEmit({ pan, pinch, rotate }, fingers)\n        this.emit('move')\n    }\n\n    /**\n     * Setta i valore dello state ed emette gli eventi\n     *\n     * @param {Object} eventValues Valori da emettere\n     */\n    setStateAndEmit(eventValues, fingers)\n    {\n        this.stateValue = this.state.set(this.stateValue, eventValues, this.events.state)\n\n        fingers == 1 && eventValues.pan && this.pan()\n        fingers == 2 && eventValues.pan && this.pan2()\n        eventValues.pinch && this.pinch(eventValues.pinch)\n        eventValues.rotate && this.rotate(eventValues.rotate)\n    }\n\n\n    /**\n     * Termino l'evento\n     */\n    finish(event)\n    {\n        if( !this.locked && this.started )  // Controllo che vale anche per l'evento touchmove\n        {\n            this.$event = event\n            this.mooving && this.swipe()\n            this.mooving === null && this.tap()\n            this.stateValue = this.state.refresh(this.stateValue, this.events.state) // aggiorno lo state\n            this.emit('end')\n        }\n\n        this.clear()\n    }\n\n    /**\n     * Reset delle variabili\n     */\n    clear()\n    {\n        this.pressEmitted && window.clearTimeout(this.pressEmitted) // Cancello l'evento press\n\n        this.started = null\n        this.ended = null\n        this.mooving = null\n        this.$event = null\n        this.pressEmitted = null\n    }\n\n    /* -------------------------------------\n     *  Eventi\n     * ------------------------------------- */\n\n    /**\n     * Ritorna vero se questo oggetto è bloccato, falso altrimenti\n     *\n     * @return {Boolean}\n     */\n    isLock() {\n        return this.locked\n    }\n\n    /**\n     * Rimuove i listener degli eventi\n     */\n    lock()\n    {\n        if( !this.locked ) {\n            this.off('touchstart', this.start, true)\n            this.off('touchmove', this.move)\n            this.off('touchend touchcancel', this.finish, true)\n            this.locked = true\n        }\n    }\n\n    /**\n     * Binda gli eventi\n     */\n    unlock()\n    {\n        if( this.locked ) {\n            this.on('touchstart', this.start, true)\n            this.on('touchmove', this.move)\n            this.on('touchend touchcancel', this.finish, true)\n            this.locked = false\n        }\n    }\n\n    /* -------------------------------------\n     *  State\n     * ------------------------------------- */\n\n    /**\n     * Setta uno state\n     *\n     * @param {Object} state\n     */\n    setState(state)\n    {\n        Object.keys(state).forEach( s => this.events.state[s] = state[s] )\n    }\n\n    /**\n     * Ritorna i valori dello state corrente\n     */\n    getState()\n    {\n        return this.stateValue\n    }\n\n    /**\n     * Rimuove uno state\n     *\n     * @param {String} name Nome dello state da rimuovere\n     */\n    removeState(name)\n    {\n        this.state[name] = null\n        this.stateValue[name] = null\n        delete this.state[name]\n        delete this.stateValue[name]\n    }\n\n    /**\n     * Cancella lo state con ivalori correnti\n     */\n    clearState()\n    {\n        this.stateValue = this.state.create()\n    }\n\n    /* -------------------------------------\n     *  Eventi\n     * ------------------------------------- */\n\n    /**\n     * Valido l'evento tap\n     */\n    tap()\n    {\n        let fingers = this.utils.howManyTouches(this.ended)\n        let time = Date.now() - this.started.time\n\n        if( fingers < 2 && time < ALOETOUCH_PRESS_MIN_TIME )\n            this.emit('tap')\n    }\n\n    /**\n     * Evento press\n     */\n    press()\n    {\n        if(this.pressEmitted && !this.mooving) {\n            this.emit('press')\n            this.pressEmitted = null\n        }\n    }\n\n    /**\n     * Valido l'evento swipe\n     */\n    swipe()\n    {\n        let coords = this.utils.coords(this.started, this.ended)\n\n        if( Math.abs(coords.x) > ALOETOUCH_MIN_SWIPE_DISTANCE )\n        {\n            let stringDirection = this.utils.stringDirection(coords)\n\n            this.emit('swipe' + stringDirection.x)\n            this.emit('swipe' + stringDirection.y)\n            this.emit('swipe')\n        }\n    }\n\n    /**\n     * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n\n     * @param {Object} coords\n     */\n    pan()\n    {\n        this.emit('pan')\n    }\n\n    /**\n     * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n\n     * @param {Object} coords\n     */\n    pan2()\n    {\n        this.emit('pan2')\n    }\n\n    /**\n     * L'evento pinch non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n     *\n     * @param {Number} distance\n     */\n    pinch(distance)\n    {\n        this.emit('pinch', { distance })\n    }\n\n    /**\n     * L'evento rotate non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n     *\n     * @param {Number} rotation\n     */\n    rotate(rotation)\n    {\n        this.emit('rotate', { rotation })\n    }\n\n    /* -------------------------------------\n     *  Bindaggio ed emissione eventi\n     * ------------------------------------- */\n\n    /**\n     * Emette un evento se settato\n     *\n     * @param {String} event Nome dell'evento da emettere\n     */\n    emit(event, data)\n    {\n        if(this.events[event]) {\n\n            //let result = this.events[event](data ? data : this.stateValue, data ? this.stateValue : null)\n            let result = this.events[event](this.setEventData(data))\n\n            // Prevengo la gestione degli altri eventi se - nella funzione settata dall'utente - viene restituito il booleano false\n            return result === false && this.clear()\n        }\n    }\n\n    setEventData(data)\n    {\n        let coords, directions, duration\n\n        // Per l'evento tap e press\n        if( !this.ended ){\n            this.ended = this.utils.create(null)\n            coords = { x: this.started.touches[0].clientX, y: this.started.touches[0].clientY }\n        } else {\n            coords = this.utils.coords(this.started, this.ended)\n            directions = this.utils.stringDirection(coords)\n        }\n        duration = this.ended.time - this.started.time\n\n        return Object.assign({}, {\n            el: this.el,\n            coords,\n            directions,\n            /*velocity: {\n                x: coords.x / duration * 1000,\n                y: coords.y / duration * 1000,\n                a: (this.utils.scalar(coords.x, coords.y) / duration ) * 1000\n            },*/\n            fingers: this.utils.howManyTouches(this.ended),\n            $state: this.stateValue,\n            $event: this.$event,\n            duration\n        }, data)\n    }\n\n    /**\n     * Aggiunge un evento\n     */\n    attach(events)\n    {\n        Object.keys(events).forEach( e => this.events[e] = events[e] )\n    }\n    /**\n     * Rimuove un evento\n     */\n    detach(events)\n    {\n        events = events.constructor.name === 'Array' ? events : [events]\n        events.forEach(e => this.events[e] && delete this.events[e])\n    }\n\n    /**\n     * Bindo gli eventi all'elemento\n     */\n    on(events, handler, passive)\n    {\n        events.split(' ').forEach( e => this.el.addEventListener(e, handler, passive ? { passive: true } : false) )\n    }\n\n    /**\n     * Rimuovo i listeners\n     */\n    off(events, handler, passive)\n    {\n        events.split(' ').forEach( e => this.el.removeEventListener(e, handler, passive ? { passive: true } : false) )\n    }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/AloeTouchObject.js","let State = {\n\n    /**\n     * Crea un oggetto vuoto per il contenimento dei valori degli eventi pan, pinch e rotate\n     */\n    init()\n    {\n        return {\n            pan: { x: null, y: null },\n            pinch: null,\n            rotate: null\n        }\n    },\n\n    /**\n     * Crea un nuovo oggetto che conterra i valori precedenti degli eventi\n     */\n    create()\n    {\n        return Object.assign({}, State.init(), { $old: State.init() })\n    },\n\n    /**\n     * Binda i nuovi valori dall'evento corrente (chiamato da touchmove->dispatch->emit) con i valori precendenti\n     *\n     * @param {ATS} state\n     * @param {ATEvent} event\n     */\n    set(state, event, customState)\n    {\n        event.rotate && ( state.rotate = event.rotate + state.$old.rotate )\n        event.pinch && ( state.pinch = event.pinch + state.$old.pinch )\n        event.pan && event.pan.x && ( state.pan.x = event.pan.x + state.$old.pan.x )\n        event.pan && event.pan.y && ( state.pan.y = event.pan.y + state.$old.pan.y )\n\n        // Aggiungo gli state settati dall'utente\n        Object.keys(customState).forEach( cs => state[cs] = customState[cs](state) )\n\n        return state\n    },\n\n    /**\n     * All'evento touchend setto i valori precendeti con l'ultimo settato\n     *\n     * @param {ATS} state\n     */\n    refresh(state)\n    {\n        state.$old = State.copyState(state)\n\n        return state\n    },\n\n    /**\n     * Copio l'oggetto state\n     */\n    copyState(state)\n    {\n        let n = {}\n        Object.keys(state).forEach( k => {\n            k != '$old' && ( n[k] = typeof(state[k]) === 'object' && state[k] !== null ? State.copyState(state[k]) : state[k] )\n        })\n        return n\n    }\n\n}\n\nexport default {\n    set: State.set,\n    create: State.create,\n    refresh: State.refresh\n}\n\n\n// WEBPACK FOOTER //\n// ./src/services/state.js","let Utils = {\n    /**\n     * Crea (o modifico) l'oggetto ATO (AloeTouchObject) contenente la Touchlist\n     *\n     * @param  {Event}      event\n     * @param  {DOMElement} element\n     * @param  {ATO?}       oldATO\n     */\n    create(event, element, oldATO)\n    {\n        let ATO = oldATO ? Object.assign({}, oldATO, { updated: true }) : { time: Date.now() }\n\n        ATO.touches = event && event.touches ? Utils.getTouches(event.touches, element) : [{ clientX: 0, clientY: 0 }]\n\n        return ATO\n    },\n\n    /**\n     * Preleva la touchlist (modificata) dall'evento\n     *\n     * @param  {Touchlist}  touches [description]\n     * @param  {DOMElement} element L'emento esiste solo se è settato STRICT\n     * @return {Array}\n     */\n    getTouches(touches, element){\n        let data = []\n\n        Object.keys(touches).forEach(e => {\n            Utils.validate(touches[e], element) && data.push({\n                clientX: touches[e].clientX,\n                clientY: touches[e].clientY\n            })\n        })\n\n        return data\n    },\n\n    /**\n     * Aggiunge l'oggetto Touch se rispetta la validazone\n     *\n     * @param {Touch}      touch\n     * @param {DOMElement} element\n     */\n    validate(touch, element)\n    {\n        return touch && ( touch.clientX || touch.clientY ) && (!element || element == touch.target)\n    },\n\n    /**\n     * Ritorna la differenza delle coordinate tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    coords(ATOstart, ATOend)\n    {\n        return Utils.diff(ATOstart.touches[0], ATOend.touches[0])\n    },\n\n    /**\n     * Ritorna una coordinata basata sulla differenza tra due punti\n     *\n     * @param {ATO.touch} pointA\n     * @param {ATO.touch} pointB\n     */\n    diff(pointA, pointB)\n    {\n        return {\n            x: pointB.clientX - pointA.clientX,\n            y: pointB.clientY - pointA.clientY\n        }\n    },\n\n    /**\n     * Ritorna il numero di touch\n     *\n     * @param {ATO} ATOe\n     */\n    howManyTouches(ATO)\n    {\n        return ATO && ATO.touches ? ATO.touches.length : 0\n    },\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente verticale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isVertical(ATOstart, ATOend)\n    {\n        let coords = Utils.coords(ATOstart, ATOend)\n        return Math.abs(coords.y) > Math.abs(coords.x)\n    },\n\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente orizzontale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isHorizontal(ATOstart, ATOend)\n    {\n        let coords = Utils.coords(ATOstart, ATOend)\n        return Math.abs(coords.x) > Math.abs(coords.y)\n    },\n\n    /**\n     * Ritorna la direzione in base al valore delle coordinate\n     *\n     * @param {Object{x,y} } coords\n     */\n    stringDirection(coords)\n    {\n        return {\n            x: coords.x <= 0 ? 'Left' : 'Right',\n            y: coords.y <= 0 ? 'Top' : 'Bottom'\n        }\n    },\n\n    /* -------------------------------------\n     *  Helper per eventi\n     * ------------------------------------- */\n\n    /**\n     * Ritorna la distanza tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    distanceBetween(ATOstart, ATOend)\n    {\n        return Utils.distance(ATOend) - Utils.distance(ATOstart)\n    },\n\n    /**\n     * Ritorna la distanza vettoriale tra due coordinata\n     *\n     * @param {ATO} ATO\n     */\n    distance(ATO)\n    {\n        let distance = Utils.diff(ATO.touches[0], ATO.touches[1])\n        return Utils.scalar(distance.x, distance.y)\n    },\n\n    /**\n     * Distanza scalare\n     */\n    scalar(a, b)\n    {\n        return Math.sqrt(Math.pow(a, 2) +  Math.pow(b, 2))\n    },\n\n    /**\n     * Ritorna la direzione tangente tra due coordinate\n     *\n     * @param {ATO} ATO\n     */\n    direction(ATO)\n    {\n        let distance = Utils.diff(ATO.touches[0], ATO.touches[1])\n        return Utils.angle(distance.x, distance.y)\n    },\n\n    /**\n     * Angolo\n     */\n    angle(a, b) \n    {\n        return Math.atan2(b, a) * 180 / Math.PI\n    },\n\n    /**\n     * Ritorna l'angolo di rotazione tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    rotation(ATOstart, ATOend)\n    {\n        return Utils.direction(ATOend) - Utils.direction(ATOstart)\n    }\n}\n\nexport default {\n    create: Utils.create,\n    coords: Utils.coords,\n    howManyTouches: Utils.howManyTouches,\n    isVertical: Utils.isVertical,\n    isHorizontal: Utils.isHorizontal,\n    stringDirection: Utils.stringDirection,\n    distanceBetween: Utils.distanceBetween,\n    direction: Utils.direction,\n    rotation: Utils.rotation,\n    angle: Utils.angle,\n    scalar: Utils.scalar\n}\n\n\n// WEBPACK FOOTER //\n// ./src/services/utils.js","import AloeTouch from './src/AloeTouch'\n\nwindow.AloeTouch = AloeTouch\n\n\n// WEBPACK FOOTER //\n// ./index.js"],"sourceRoot":""}