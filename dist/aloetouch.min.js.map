{"version":3,"sources":["webpack:///dist/aloetouch.min.js","webpack:///webpack/bootstrap 5b2234e82c6a16ac8fb0","webpack:///./src/AloeTouchObject.js","webpack:///./src/services/state.js","webpack:///./src/services/utils.js","webpack:///./src/AloeTouch.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireDefault","obj","default","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","_utils","_utils2","_state","_state2","ALOETOUCH_MIN_TIME","ALOETOUCH_PRESS_MIN_TIME","ALOETOUCH_MIN_SWIPE_DISTANCE","AloeTouchObject","id","element","events","strict","this","el","document","querySelector","strictMode","state","locked","utils","start","bind","move","finish","clear","clearState","unlock","event","$event","started","create","updated","mooving","pressEmitted","window","setTimeout","press","emit","_this","prepareMove","ended","isPermissible","preventDefault","dispatch","callback","time","isHorizontal","fingers","howManyTouches","pan","pinch","rotate","coords","distanceBetween","rotation","setStateAndEmit","eventValues","stateValue","set","pan2","swipe","tap","refresh","clearTimeout","off","on","_this2","keys","forEach","Date","now","Math","abs","x","stringDirection","y","distance","data","setEventData","directions","duration","touches","clientX","clientY","assign","velocity","scalar","$state","_this3","e","_this4","constructor","handler","passive","_this5","split","addEventListener","_this6","removeEventListener","_typeof","Symbol","iterator","State","init","$old","customState","cs","copyState","k","Utils","oldATO","ATO","getTouches","validate","push","touch","ATOstart","ATOend","diff","pointA","pointB","isVertical","a","b","sqrt","pow","direction","angle","atan2","PI","_AloeTouchObject","_AloeTouchObject2","AloeTouch","list","$id","attach","caller","detach","setState","getState","removeState","isLock","lock","$ref","fn","unbind","aloetouchobject","getIds","aloetouchobjects","flag","map","ato","filter","lockExcept","ids","indexOf","lockOnly","unlockExcept","unlockOnly","callable"],"mappings":"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","file":"./dist/aloetouch.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(2);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _state = __webpack_require__(1);\n\nvar _state2 = _interopRequireDefault(_state);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * La durata minimina per bindare un evento\n * Utile a non prevenire lo scrolling\n * @type {Number}\n */\nvar ALOETOUCH_MIN_TIME = 85;\n\n/**\n * Tempo minimo per bindare l'evento press\n * @type {Number}\n */\nvar ALOETOUCH_PRESS_MIN_TIME = 600;\n\n/**\n * Distanza minima per bindare l'evento swipe[Direction]\n * @type {Number}\n */\nvar ALOETOUCH_MIN_SWIPE_DISTANCE = 20;\n\n/**\n * Assegna gli eventi touch ad un elemento\n *\n * GLi eventi disponibili sono:\n * Touch singolo\n *     tap, press, pan, swipeLeft, swipeRight, swipeTop, swipeBottom\n * Touch doppio\n *     pinch, rotate\n */\n\nvar AloeTouchObject = function () {\n\n    /**\n     * Binda gli eventi all'elemento\n     * @param {DomElement} element\n     * @param {Object} events Oggetto che contiene le funzioni es. { tap: ..., swipeLeft: ..., rotate: ... }\n     * @param {Boolean} strict Aggiunge le coordinate del tuoch solo se il target è uguale all'elemento bindato\n     */\n    function AloeTouchObject(id, element, events, strict) {\n        _classCallCheck(this, AloeTouchObject);\n\n        this.id = id;\n        this.el = typeof element === 'string' ? document.querySelector(element) : element;\n        this.events = events || {};\n        this.strictMode = strict || false;\n        this.events.state = this.events.state || {};\n        this.locked = true;\n\n        // Services\n        this.utils = _utils2.default;\n        this.state = _state2.default;\n\n        this.start = this.start.bind(this);\n        this.move = this.move.bind(this);\n        this.finish = this.finish.bind(this);\n\n        this.clear();\n        this.clearState();\n        this.unlock();\n    }\n\n    /**\n     * Eventi 'touchstart' 'mousedown'\n     */\n\n\n    _createClass(AloeTouchObject, [{\n        key: 'start',\n        value: function start(event) {\n            if (!this.locked) {\n                this.$event = event;\n                this.started = this.utils.create(event, this.strictMode ? this.el : null, this.started);\n                this.started.updated ? this.mooving = true : this.pressEmitted = window.setTimeout(this.press.bind(this), ALOETOUCH_PRESS_MIN_TIME);\n                // Binderà l'evento press solo se non sarà invocato nè l'evento move, nè finish\n                this.emit('start');\n            }\n        }\n\n        /**\n         * Eventi 'touchmove'\n         */\n\n    }, {\n        key: 'move',\n        value: function move(event) {\n            var _this = this;\n\n            // Controllo se sono settate le coordinate del touch all'evento start e bindo le nuove coordinate (ended)\n            !this.locked && this.prepareMove(event, function (ended) {\n                if (_this.isPermissible()) {\n                    event.preventDefault();\n                    _this.$event = event;\n                    _this.mooving = true;\n                    _this.dispatch(); // Smisto gli eventi 'mobili': pan, rotate, pitch\n                } else {\n                    _this.mooving = false; // L'evento non può più essere prevenuto\n                }\n            });\n        }\n\n        /**\n         * Eseguo la funczione moove solo se sono settate le coordinate iniziali\n         */\n\n    }, {\n        key: 'prepareMove',\n        value: function prepareMove(event, callback) {\n            this.started ? callback(this.ended = this.utils.create(event, this.strictMode ? this.el : null)) : this.clear();\n        }\n\n        /**\n         * Questa funzionalitò è molto importante poiché previene che l'evento 'touchmove'\n         * prevenga l'azione di default dell'evento (e quindi blocchi lo scrolling)\n         */\n\n    }, {\n        key: 'isPermissible',\n        value: function isPermissible() {\n            var time = this.ended.time - this.started.time;\n            var isHorizontal = this.utils.isHorizontal(this.started, this.ended); // Se lo scrolling è orizzontale implica che l'utente non sta scorrendo\n            // verticalmente la pagina, quindi è possibile bloccare lo scrolling\n            return this.mooving || this.mooving === null // Il caso in cui questa variabile risulta === null avviene solo la priva volta che viene invocata la fuonzione move,\n            && (isHorizontal || time > ALOETOUCH_MIN_TIME) // infatti viene nullata con la funzione clear presente nel metodo start. Questa cndizione è necessaria perché il metodo\n            ; // preventDefault() di Event non può essere invocato in un secondo stadio dell'evento 'touchmove', ma solo la prima volta\n        }\n\n        /**\n         * Smisto gli eventi in 'touchmove' in base al numero di tocchi\n         */\n\n    }, {\n        key: 'dispatch',\n        value: function dispatch() {\n            var fingers = this.utils.howManyTouches(this.ended),\n                pan = null,\n                pinch = null,\n                rotate = null;\n\n            if (fingers == 1) {\n                pan = this.utils.coords(this.started, this.ended);\n            } else if (fingers == 2) {\n                pan = this.utils.coords(this.started, this.ended);\n                pinch = this.utils.distanceBetween(this.started, this.ended);\n                rotate = this.utils.rotation(this.started, this.ended);\n            }\n\n            this.setStateAndEmit({ pan: pan, pinch: pinch, rotate: rotate }, fingers);\n            this.emit('move');\n        }\n\n        /**\n         * Setta i valore dello state ed emette gli eventi\n         *\n         * @param {Object} eventValues Valori da emettere\n         */\n\n    }, {\n        key: 'setStateAndEmit',\n        value: function setStateAndEmit(eventValues, fingers) {\n            this.stateValue = this.state.set(this.stateValue, eventValues, this.events.state);\n\n            fingers == 1 && eventValues.pan && this.pan();\n            fingers == 2 && eventValues.pan && this.pan2();\n            eventValues.pinch && this.pinch(eventValues.pinch);\n            eventValues.rotate && this.rotate(eventValues.rotate);\n        }\n\n        /**\n         * Termino l'evento\n         */\n\n    }, {\n        key: 'finish',\n        value: function finish(event) {\n            if (!this.locked && this.started) // Controllo che vale anche per l'evento touchmove\n                {\n                    this.$event = event;\n                    this.mooving && this.swipe();\n                    this.mooving === null && this.tap();\n                    this.stateValue = this.state.refresh(this.stateValue, this.events.state); // aggiorno lo state\n                    this.emit('end');\n                }\n\n            this.clear();\n        }\n\n        /**\n         * Reset delle variabili\n         */\n\n    }, {\n        key: 'clear',\n        value: function clear() {\n            this.pressEmitted && window.clearTimeout(this.pressEmitted); // Cancello l'evento press\n\n            this.started = null;\n            this.ended = null;\n            this.mooving = null;\n            this.$event = null;\n            this.pressEmitted = null;\n        }\n\n        /* -------------------------------------\n         *  Eventi\n         * ------------------------------------- */\n\n        /**\n         * Ritorna vero se questo oggetto è bloccato, falso altrimenti\n         *\n         * @return {Boolean}\n         */\n\n    }, {\n        key: 'isLock',\n        value: function isLock() {\n            return this.locked;\n        }\n\n        /**\n         * Rimuove i listener degli eventi\n         */\n\n    }, {\n        key: 'lock',\n        value: function lock() {\n            if (!this.locked) {\n                this.off('touchstart', this.start, true);\n                this.off('touchmove', this.move);\n                this.off('touchend touchcancel', this.finish, true);\n                this.locked = true;\n            }\n        }\n\n        /**\n         * Binda gli eventi\n         */\n\n    }, {\n        key: 'unlock',\n        value: function unlock() {\n            if (this.locked) {\n                this.on('touchstart', this.start, true);\n                this.on('touchmove', this.move);\n                this.on('touchend touchcancel', this.finish, true);\n                this.locked = false;\n            }\n        }\n\n        /* -------------------------------------\n         *  State\n         * ------------------------------------- */\n\n        /**\n         * Setta uno state\n         *\n         * @param {Object} state\n         */\n\n    }, {\n        key: 'setState',\n        value: function setState(state) {\n            var _this2 = this;\n\n            Object.keys(state).forEach(function (s) {\n                return _this2.events.state[s] = state[s];\n            });\n        }\n\n        /**\n         * Ritorna i valori dello state corrente\n         */\n\n    }, {\n        key: 'getState',\n        value: function getState() {\n            return this.stateValue;\n        }\n\n        /**\n         * Rimuove uno state\n         *\n         * @param {String} name Nome dello state da rimuovere\n         */\n\n    }, {\n        key: 'removeState',\n        value: function removeState(name) {\n            this.state[name] = null;\n            this.stateValue[name] = null;\n            delete this.state[name];\n            delete this.stateValue[name];\n        }\n\n        /**\n         * Cancella lo state con ivalori correnti\n         */\n\n    }, {\n        key: 'clearState',\n        value: function clearState() {\n            this.stateValue = this.state.create();\n        }\n\n        /* -------------------------------------\n         *  Eventi\n         * ------------------------------------- */\n\n        /**\n         * Valido l'evento tap\n         */\n\n    }, {\n        key: 'tap',\n        value: function tap() {\n            var fingers = this.utils.howManyTouches(this.ended);\n            var time = Date.now() - this.started.time;\n\n            if (fingers < 2 && time < ALOETOUCH_PRESS_MIN_TIME) this.emit('tap');\n        }\n\n        /**\n         * Evento press\n         */\n\n    }, {\n        key: 'press',\n        value: function press() {\n            if (this.pressEmitted && !this.mooving) {\n                this.emit('press');\n                this.pressEmitted = null;\n            }\n        }\n\n        /**\n         * Valido l'evento swipe\n         */\n\n    }, {\n        key: 'swipe',\n        value: function swipe() {\n            var coords = this.ended ? this.utils.coords(this.started, this.ended) : {};\n\n            if (Math.abs(coords.x) > ALOETOUCH_MIN_SWIPE_DISTANCE) {\n                var stringDirection = this.utils.stringDirection(coords);\n\n                this.emit('swipe' + stringDirection.x);\n                this.emit('swipe' + stringDirection.y);\n                this.emit('swipe');\n            }\n        }\n\n        /**\n         * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n          * @param {Object} coords\n         */\n\n    }, {\n        key: 'pan',\n        value: function pan() {\n            this.emit('pan');\n        }\n\n        /**\n         * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n          * @param {Object} coords\n         */\n\n    }, {\n        key: 'pan2',\n        value: function pan2() {\n            this.emit('pan2');\n        }\n\n        /**\n         * L'evento pinch non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n         *\n         * @param {Number} distance\n         */\n\n    }, {\n        key: 'pinch',\n        value: function pinch(distance) {\n            this.emit('pinch', { distance: distance });\n        }\n\n        /**\n         * L'evento rotate non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n         *\n         * @param {Number} rotation\n         */\n\n    }, {\n        key: 'rotate',\n        value: function rotate(rotation) {\n            this.emit('rotate', { rotation: rotation });\n        }\n\n        /* -------------------------------------\n         *  Bindaggio ed emissione eventi\n         * ------------------------------------- */\n\n        /**\n         * Emette un evento se settato\n         *\n         * @param {String} event Nome dell'evento da emettere\n         */\n\n    }, {\n        key: 'emit',\n        value: function emit(event, data) {\n            if (this.events[event]) {\n\n                //let result = this.events[event](data ? data : this.stateValue, data ? this.stateValue : null)\n                var result = this.events[event](this.setEventData(data));\n\n                // Prevengo la gestione degli altri eventi se - nella funzione settata dall'utente - viene restituito il booleano false\n                return result === false && this.clear();\n            }\n        }\n    }, {\n        key: 'setEventData',\n        value: function setEventData(data) {\n            var coords = void 0,\n                directions = void 0,\n                duration = void 0;\n\n            // Per l'evento tap e press\n            if (!this.ended) {\n                this.ended = this.utils.create(null);\n                coords = { x: this.started.touches[0].clientX, y: this.started.touches[0].clientY };\n            } else {\n                coords = this.utils.coords(this.started, this.ended);\n                directions = this.utils.stringDirection(coords);\n            }\n            duration = (this.ended.time - this.started.time) / 1000;\n\n            return Object.assign({}, {\n                el: this.el,\n                coords: coords,\n                directions: directions,\n                velocity: {\n                    x: coords.x / duration,\n                    y: coords.y / duration,\n                    d: this.utils.scalar(coords.x, coords.y) / duration\n                },\n                fingers: this.utils.howManyTouches(this.ended),\n                $state: this.stateValue,\n                $event: this.$event,\n                duration: duration\n            }, data);\n        }\n\n        /**\n         * Aggiunge un evento\n         */\n\n    }, {\n        key: 'attach',\n        value: function attach(events) {\n            var _this3 = this;\n\n            Object.keys(events).forEach(function (e) {\n                return _this3.events[e] = events[e];\n            });\n        }\n        /**\n         * Rimuove un evento\n         */\n\n    }, {\n        key: 'detach',\n        value: function detach(events) {\n            var _this4 = this;\n\n            events = events.constructor.name === 'Array' ? events : [events];\n            events.forEach(function (e) {\n                return _this4.events[e] && delete _this4.events[e];\n            });\n        }\n\n        /**\n         * Bindo gli eventi all'elemento\n         */\n\n    }, {\n        key: 'on',\n        value: function on(events, handler, passive) {\n            var _this5 = this;\n\n            events.split(' ').forEach(function (e) {\n                return _this5.el.addEventListener(e, handler, passive ? { passive: true } : false);\n            });\n        }\n\n        /**\n         * Rimuovo i listeners\n         */\n\n    }, {\n        key: 'off',\n        value: function off(events, handler, passive) {\n            var _this6 = this;\n\n            events.split(' ').forEach(function (e) {\n                return _this6.el.removeEventListener(e, handler, passive ? { passive: true } : false);\n            });\n        }\n    }]);\n\n    return AloeTouchObject;\n}();\n\nexports.default = AloeTouchObject;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar State = {\n\n    /**\n     * Crea un oggetto vuoto per il contenimento dei valori degli eventi pan, pinch e rotate\n     */\n    init: function init() {\n        return {\n            pan: { x: null, y: null },\n            pinch: null,\n            rotate: null\n        };\n    },\n\n\n    /**\n     * Crea un nuovo oggetto che conterra i valori precedenti degli eventi\n     */\n    create: function create() {\n        return Object.assign({}, State.init(), { $old: State.init() });\n    },\n\n\n    /**\n     * Binda i nuovi valori dall'evento corrente (chiamato da touchmove->dispatch->emit) con i valori precendenti\n     *\n     * @param {ATS} state\n     * @param {ATEvent} event\n     */\n    set: function set(state, event, customState) {\n        event.rotate && (state.rotate = event.rotate + state.$old.rotate);\n        event.pinch && (state.pinch = event.pinch + state.$old.pinch);\n        event.pan && event.pan.x && (state.pan.x = event.pan.x + state.$old.pan.x);\n        event.pan && event.pan.y && (state.pan.y = event.pan.y + state.$old.pan.y);\n\n        // Aggiungo gli state settati dall'utente\n        Object.keys(customState).forEach(function (cs) {\n            return state[cs] = customState[cs](state);\n        });\n\n        return state;\n    },\n\n\n    /**\n     * All'evento touchend setto i valori precendeti con l'ultimo settato\n     *\n     * @param {ATS} state\n     */\n    refresh: function refresh(state) {\n        state.$old = State.copyState(state);\n\n        return state;\n    },\n\n\n    /**\n     * Copio l'oggetto state\n     */\n    copyState: function copyState(state) {\n        var n = {};\n        Object.keys(state).forEach(function (k) {\n            k != '$old' && (n[k] = _typeof(state[k]) === 'object' && state[k] !== null ? State.copyState(state[k]) : state[k]);\n        });\n        return n;\n    }\n};\n\nexports.default = {\n    set: State.set,\n    create: State.create,\n    refresh: State.refresh\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar Utils = {\n    /**\n     * Crea (o modifico) l'oggetto ATO (AloeTouchObject) contenente la Touchlist\n     *\n     * @param  {Event}      event\n     * @param  {DOMElement} element\n     * @param  {ATO?}       oldATO\n     */\n    create: function create(event, element, oldATO) {\n        var ATO = oldATO ? Object.assign({}, oldATO, { updated: true }) : { time: Date.now() };\n\n        ATO.touches = event && event.touches ? Utils.getTouches(event.touches, element) : [{ clientX: 0, clientY: 0 }];\n\n        return ATO;\n    },\n\n\n    /**\n     * Preleva la touchlist (modificata) dall'evento\n     *\n     * @param  {Touchlist}  touches [description]\n     * @param  {DOMElement} element L'emento esiste solo se è settato STRICT\n     * @return {Array}\n     */\n    getTouches: function getTouches(touches, element) {\n        var data = [];\n\n        Object.keys(touches).forEach(function (e) {\n            Utils.validate(touches[e], element) && data.push({\n                clientX: touches[e].clientX,\n                clientY: touches[e].clientY\n            });\n        });\n\n        return data;\n    },\n\n\n    /**\n     * Aggiunge l'oggetto Touch se rispetta la validazone\n     *\n     * @param {Touch}      touch\n     * @param {DOMElement} element\n     */\n    validate: function validate(touch, element) {\n        return touch && (touch.clientX || touch.clientY) && (!element || element == touch.target);\n    },\n\n\n    /**\n     * Ritorna la differenza delle coordinate tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    coords: function coords(ATOstart, ATOend) {\n        return Utils.diff(ATOstart.touches[0], ATOend.touches[0]);\n    },\n\n\n    /**\n     * Ritorna una coordinata basata sulla differenza tra due punti\n     *\n     * @param {ATO.touch} pointA\n     * @param {ATO.touch} pointB\n     */\n    diff: function diff(pointA, pointB) {\n        return {\n            x: pointB.clientX - pointA.clientX,\n            y: pointB.clientY - pointA.clientY\n        };\n    },\n\n\n    /**\n     * Ritorna il numero di touch\n     *\n     * @param {ATO} ATOe\n     */\n    howManyTouches: function howManyTouches(ATO) {\n        return ATO && ATO.touches ? ATO.touches.length : 0;\n    },\n\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente verticale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isVertical: function isVertical(ATOstart, ATOend) {\n        var coords = Utils.coords(ATOstart, ATOend);\n        return Math.abs(coords.y) > Math.abs(coords.x);\n    },\n\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente orizzontale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isHorizontal: function isHorizontal(ATOstart, ATOend) {\n        var coords = Utils.coords(ATOstart, ATOend);\n        return Math.abs(coords.x) > Math.abs(coords.y);\n    },\n\n\n    /**\n     * Ritorna la direzione in base al valore delle coordinate\n     *\n     * @param {Object{x,y} } coords\n     */\n    stringDirection: function stringDirection(coords) {\n        return {\n            x: coords.x <= 0 ? 'Left' : 'Right',\n            y: coords.y <= 0 ? 'Top' : 'Bottom'\n        };\n    },\n\n\n    /* -------------------------------------\n     *  Helper per eventi\n     * ------------------------------------- */\n\n    /**\n     * Ritorna la distanza tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    distanceBetween: function distanceBetween(ATOstart, ATOend) {\n        return Utils.distance(ATOend) - Utils.distance(ATOstart);\n    },\n\n\n    /**\n     * Ritorna la distanza vettoriale tra due coordinata\n     *\n     * @param {ATO} ATO\n     */\n    distance: function distance(ATO) {\n        var distance = Utils.diff(ATO.touches[0], ATO.touches[1]);\n        return Utils.scalar(distance.x, distance.y);\n    },\n\n\n    /**\n     * Distanza scalare\n     */\n    scalar: function scalar(a, b) {\n        return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n    },\n\n\n    /**\n     * Ritorna la direzione tangente tra due coordinate\n     *\n     * @param {ATO} ATO\n     */\n    direction: function direction(ATO) {\n        var distance = Utils.diff(ATO.touches[0], ATO.touches[1]);\n        return Utils.angle(distance.x, distance.y);\n    },\n\n\n    /**\n     * Angolo\n     */\n    angle: function angle(a, b) {\n        return Math.atan2(b, a) * 180 / Math.PI;\n    },\n\n\n    /**\n     * Ritorna l'angolo di rotazione tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    rotation: function rotation(ATOstart, ATOend) {\n        return Utils.direction(ATOend) - Utils.direction(ATOstart);\n    }\n};\n\nexports.default = {\n    create: Utils.create,\n    coords: Utils.coords,\n    howManyTouches: Utils.howManyTouches,\n    isVertical: Utils.isVertical,\n    isHorizontal: Utils.isHorizontal,\n    stringDirection: Utils.stringDirection,\n    distanceBetween: Utils.distanceBetween,\n    direction: Utils.direction,\n    rotation: Utils.rotation,\n    angle: Utils.angle,\n    scalar: Utils.scalar\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AloeTouchObject = __webpack_require__(0);\n\nvar _AloeTouchObject2 = _interopRequireDefault(_AloeTouchObject);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * AloeTouch\n */\nexports.default = AloeTouch = {\n\n  /**\n   * Contiene il numero di elementi\n   *\n   * @type {Number}\n   */\n  length: 0,\n\n  /**\n   * Lista degli AloeTouchObject\n   *\n   * @type {Object}\n   */\n  list: {},\n\n  /**\n   * Binda un nuovo elemento\n   *\n   * @param {DOMElement} element Elemento da bindare\n   * @param {Object}     events  Eventi da assegnare all'elemento\n   * @param {Boolean}    strict  Se settata, valida l'evento solo se il target del touch è l'elemento bindato\n   */\n  bind: function bind(element, events, strict) {\n    var id = ++AloeTouch.length;\n\n    return AloeTouch.list[id] = {\n      $id: id, // id dell'oggetto\n      attach: AloeTouch.caller('attach'), // Binda un evento\n      detach: AloeTouch.caller('detach'), // Rimuovo il listener di un evento\n      setState: AloeTouch.caller('setState'), // Setta uno stato personalizzato\n      getState: AloeTouch.caller('getState'), // Setta uno stato personalizzato\n      removeState: AloeTouch.caller('removeState'), // Rimuove uno state\n      clearState: AloeTouch.caller('clearState'), // Azzera la variabile state\n      isLock: AloeTouch.caller('isLock'), // Rimuove i listener per tutti gli eventi\n      lock: AloeTouch.caller('lock'), // Rimuove i listener per tutti gli eventi\n      unlock: AloeTouch.caller('unlock'), // Rebinda i listener per gli eventii\n      $ref: new _AloeTouchObject2.default(id, element, events, strict) // refrenza all'oggetto\n    };\n  },\n\n\n  /**\n   * Chiama una funzione bindando il riferimento dell'oggetto chimante\n   * @param  {String} fn\n   * @return {Function}\n   */\n  caller: function caller(fn) {\n    return function (data) {\n      this.$ref && this.$ref[fn](data);\n    };\n  },\n\n\n  /**\n   * Rimuove i listener ad un elemento\n   *\n   * @param {AloeTouchObject or Numer} aloetouchobject\n   * @return {Boolean} true se l'elemento è stato rimosso, falso altrimenti\n   */\n  unbind: function unbind(aloetouchobject) {\n    var id = this.getIds(aloetouchobject, true);\n\n    if (id) {\n      AloeTouch.list[id].lock();\n      delete AloeTouch.list[id].$ref;\n      delete AloeTouch.list[id];\n      return true;\n    }\n\n    return false;\n  },\n\n\n  /**\n   * Ritorna un elemento in base al suo id\n   *\n   * @param {Number} id\n   */\n  get: function get(id) {\n    return AloeTouch.list.hasOwnProperty(id) ? AloeTouch.list[id] : null;\n  },\n\n\n  /**\n   * Ritorna un' array di id\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   * @param {Boolean} flag Ritorna un id se l'array ha lunghezza pari a uno\n   * @return {Array<Number> or Number}\n   */\n  getIds: function getIds(aloetouchobjects, flag) {\n    aloetouchobjects = aloetouchobjects.constructor.name === 'Array' ? aloetouchobjects : [aloetouchobjects];\n    aloetouchobjects = aloetouchobjects.map(function (ato) {\n      return typeof ato === 'number' ? AloeTouch.get(ato) ? ato : null : ato.$ref ? ato.$id : null;\n    });\n    aloetouchobjects = aloetouchobjects.filter(function (id) {\n      return !!id;\n    });\n\n    return flag ? aloetouchobjects.length == 1 ? aloetouchobjects[0] : aloetouchobjects : aloetouchobjects;\n  },\n\n\n  /**\n   * Blocca un oggetto singolo o tutti\n   *\n   * @param {Number?} id Blocca gli eventi per l'oggetto con id 'id'\n   */\n  lock: function lock(id) {\n    id ? AloeTouch.list[id].lock() : AloeTouch.map(function (ato) {\n      return ato.lock();\n    });\n  },\n\n\n  /**\n   *  Blocca tutti gli oggetti tranne quelli presenti nell'array aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  lockExcept: function lockExcept(aloetouchobjects) {\n    ids = this.getIds(ids) || [];\n\n    AloeTouch.map(function (ato, id) {\n      return ato[ids.indexOf(id) == -1 ? 'unlock' : 'lock']();\n    });\n  },\n\n\n  /**\n   * Blocca solo gli oggetti presenti in aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  lockOnly: function lockOnly(aloetouchobjects) {\n    ids = this.getIds(ids) || [];\n\n    AloeTouch.map(function (ato, id) {\n      return ato[ids.indexOf(id) >= 0 ? 'lock' : 'unlock']();\n    });\n  },\n\n\n  /**\n   * Abilita li eventi ad un oggetto singolo o tutti\n   *\n   * @param {Number?} id\n   */\n  unlock: function unlock(id) {\n    id ? AloeTouch.list[id].unlock() : AloeTouch.map(function (ato) {\n      return ato.unlock();\n    });\n  },\n\n\n  /**\n   * Abilita gli eventi tranne agli elementi presenti nell'array aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  unlockExcept: function unlockExcept(aloetouchobjects) {\n    AloeTouch.lockOnly(aloetouchobjects);\n  },\n\n\n  /**\n   * Abilita gli eventi solo agli elementi presenti nell'array aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  unlockOnly: function unlockOnly(aloetouchobjects) {\n    AloeTouch.lockExcept(aloetouchobjects);\n  },\n\n\n  /**\n   * Mappa tutti li elementi bindati\n   *\n   * @param {Callable(AloeTouchObject, id)}\n   */\n  map: function map(callable) {\n    Object.keys(AloeTouch.list).forEach(function (id) {\n      return callable(AloeTouch.list[id], id);\n    });\n  }\n};\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dist/aloetouch.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5b2234e82c6a16ac8fb0","import Utils from './services/utils'\nimport State from './services/state'\n\n/**\n * La durata minimina per bindare un evento\n * Utile a non prevenire lo scrolling\n * @type {Number}\n */\nconst ALOETOUCH_MIN_TIME = 85\n\n/**\n * Tempo minimo per bindare l'evento press\n * @type {Number}\n */\nconst ALOETOUCH_PRESS_MIN_TIME = 600\n\n/**\n * Distanza minima per bindare l'evento swipe[Direction]\n * @type {Number}\n */\nconst ALOETOUCH_MIN_SWIPE_DISTANCE = 20\n\n/**\n * Assegna gli eventi touch ad un elemento\n *\n * GLi eventi disponibili sono:\n * Touch singolo\n *     tap, press, pan, swipeLeft, swipeRight, swipeTop, swipeBottom\n * Touch doppio\n *     pinch, rotate\n */\nexport default class AloeTouchObject {\n\n    /**\n     * Binda gli eventi all'elemento\n     * @param {DomElement} element\n     * @param {Object} events Oggetto che contiene le funzioni es. { tap: ..., swipeLeft: ..., rotate: ... }\n     * @param {Boolean} strict Aggiunge le coordinate del tuoch solo se il target è uguale all'elemento bindato\n     */\n    constructor(id, element, events, strict)\n    {\n        this.id = id\n        this.el = typeof element === 'string' ? document.querySelector(element) : element\n        this.events = events || {}\n        this.strictMode = strict || false\n        this.events.state = this.events.state || {}\n        this.locked = true\n\n        // Services\n        this.utils = Utils\n        this.state = State\n\n        this.start = this.start.bind(this)\n        this.move = this.move.bind(this)\n        this.finish = this.finish.bind(this)\n\n        this.clear()\n        this.clearState()\n        this.unlock()\n    }\n\n\n    /**\n     * Eventi 'touchstart' 'mousedown'\n     */\n    start(event)\n    {\n        if(!this.locked) {\n            this.$event = event\n            this.started = this.utils.create(event, this.strictMode ? this.el : null, this.started)\n            this.started.updated ?( this.mooving = true ) : ( this.pressEmitted = window.setTimeout(this.press.bind(this), ALOETOUCH_PRESS_MIN_TIME) )\n            // Binderà l'evento press solo se non sarà invocato nè l'evento move, nè finish\n            this.emit('start')\n        }\n    }\n\n    /**\n     * Eventi 'touchmove'\n     */\n    move(event)\n    {\n        // Controllo se sono settate le coordinate del touch all'evento start e bindo le nuove coordinate (ended)\n        !this.locked && this.prepareMove(event, ended => {\n            if(this.isPermissible())\n            {\n                event.preventDefault()\n                this.$event = event\n                this.mooving = true\n                this.dispatch() // Smisto gli eventi 'mobili': pan, rotate, pitch\n            } else {\n                this.mooving = false // L'evento non può più essere prevenuto\n            }\n        })\n    }\n\n    /**\n     * Eseguo la funczione moove solo se sono settate le coordinate iniziali\n     */\n    prepareMove(event, callback)\n    {\n        this.started ? callback((this.ended = this.utils.create(event, this.strictMode ? this.el : null))) : this.clear()\n    }\n\n    /**\n     * Questa funzionalitò è molto importante poiché previene che l'evento 'touchmove'\n     * prevenga l'azione di default dell'evento (e quindi blocchi lo scrolling)\n     */\n    isPermissible()\n    {\n        let time = this.ended.time - this.started.time\n        let isHorizontal = this.utils.isHorizontal(this.started, this.ended); // Se lo scrolling è orizzontale implica che l'utente non sta scorrendo\n                                                                              // verticalmente la pagina, quindi è possibile bloccare lo scrolling\n        return this.mooving || (\n            this.mooving === null                              // Il caso in cui questa variabile risulta === null avviene solo la priva volta che viene invocata la fuonzione move,\n            && ( isHorizontal || time > ALOETOUCH_MIN_TIME )   // infatti viene nullata con la funzione clear presente nel metodo start. Questa cndizione è necessaria perché il metodo\n        )                                                      // preventDefault() di Event non può essere invocato in un secondo stadio dell'evento 'touchmove', ma solo la prima volta\n    }\n\n    /**\n     * Smisto gli eventi in 'touchmove' in base al numero di tocchi\n     */\n    dispatch()\n    {\n        let fingers = this.utils.howManyTouches(this.ended),\n            pan = null, pinch = null, rotate = null\n\n        if(fingers == 1) {\n            pan = this.utils.coords(this.started, this.ended)\n        } else if(fingers == 2) {\n            pan = this.utils.coords(this.started, this.ended)\n            pinch = this.utils.distanceBetween(this.started, this.ended)\n            rotate = this.utils.rotation(this.started, this.ended)\n        }\n\n        this.setStateAndEmit({ pan, pinch, rotate }, fingers)\n        this.emit('move')\n    }\n\n    /**\n     * Setta i valore dello state ed emette gli eventi\n     *\n     * @param {Object} eventValues Valori da emettere\n     */\n    setStateAndEmit(eventValues, fingers)\n    {\n        this.stateValue = this.state.set(this.stateValue, eventValues, this.events.state)\n\n        fingers == 1 && eventValues.pan && this.pan()\n        fingers == 2 && eventValues.pan && this.pan2()\n        eventValues.pinch && this.pinch(eventValues.pinch)\n        eventValues.rotate && this.rotate(eventValues.rotate)\n    }\n\n\n    /**\n     * Termino l'evento\n     */\n    finish(event)\n    {\n        if( !this.locked && this.started )  // Controllo che vale anche per l'evento touchmove\n        {\n            this.$event = event\n            this.mooving && this.swipe()\n            this.mooving === null && this.tap()\n            this.stateValue = this.state.refresh(this.stateValue, this.events.state) // aggiorno lo state\n            this.emit('end')\n        }\n\n        this.clear()\n    }\n\n    /**\n     * Reset delle variabili\n     */\n    clear()\n    {\n        this.pressEmitted && window.clearTimeout(this.pressEmitted) // Cancello l'evento press\n\n        this.started = null\n        this.ended = null\n        this.mooving = null\n        this.$event = null\n        this.pressEmitted = null\n    }\n\n    /* -------------------------------------\n     *  Eventi\n     * ------------------------------------- */\n\n    /**\n     * Ritorna vero se questo oggetto è bloccato, falso altrimenti\n     *\n     * @return {Boolean}\n     */\n    isLock() {\n        return this.locked\n    }\n\n    /**\n     * Rimuove i listener degli eventi\n     */\n    lock()\n    {\n        if( !this.locked ) {\n            this.off('touchstart', this.start, true)\n            this.off('touchmove', this.move)\n            this.off('touchend touchcancel', this.finish, true)\n            this.locked = true\n        }\n    }\n\n    /**\n     * Binda gli eventi\n     */\n    unlock()\n    {\n        if( this.locked ) {\n            this.on('touchstart', this.start, true)\n            this.on('touchmove', this.move)\n            this.on('touchend touchcancel', this.finish, true)\n            this.locked = false\n        }\n    }\n\n    /* -------------------------------------\n     *  State\n     * ------------------------------------- */\n\n    /**\n     * Setta uno state\n     *\n     * @param {Object} state\n     */\n    setState(state)\n    {\n        Object.keys(state).forEach( s => this.events.state[s] = state[s] )\n    }\n\n    /**\n     * Ritorna i valori dello state corrente\n     */\n    getState()\n    {\n        return this.stateValue\n    }\n\n    /**\n     * Rimuove uno state\n     *\n     * @param {String} name Nome dello state da rimuovere\n     */\n    removeState(name)\n    {\n        this.state[name] = null\n        this.stateValue[name] = null\n        delete this.state[name]\n        delete this.stateValue[name]\n    }\n\n    /**\n     * Cancella lo state con ivalori correnti\n     */\n    clearState()\n    {\n        this.stateValue = this.state.create()\n    }\n\n    /* -------------------------------------\n     *  Eventi\n     * ------------------------------------- */\n\n    /**\n     * Valido l'evento tap\n     */\n    tap()\n    {\n        let fingers = this.utils.howManyTouches(this.ended)\n        let time = Date.now() - this.started.time\n\n        if( fingers < 2 && time < ALOETOUCH_PRESS_MIN_TIME )\n            this.emit('tap')\n    }\n\n    /**\n     * Evento press\n     */\n    press()\n    {\n        if(this.pressEmitted && !this.mooving) {\n            this.emit('press')\n            this.pressEmitted = null\n        }\n    }\n\n    /**\n     * Valido l'evento swipe\n     */\n    swipe()\n    {\n        let coords = this.ended ? this.utils.coords(this.started, this.ended) : {}\n\n        if( Math.abs(coords.x) > ALOETOUCH_MIN_SWIPE_DISTANCE )\n        {\n            let stringDirection = this.utils.stringDirection(coords)\n\n            this.emit('swipe' + stringDirection.x)\n            this.emit('swipe' + stringDirection.y)\n            this.emit('swipe')\n        }\n    }\n\n    /**\n     * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n\n     * @param {Object} coords\n     */\n    pan()\n    {\n        this.emit('pan')\n    }\n\n    /**\n     * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n\n     * @param {Object} coords\n     */\n    pan2()\n    {\n        this.emit('pan2')\n    }\n\n    /**\n     * L'evento pinch non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n     *\n     * @param {Number} distance\n     */\n    pinch(distance)\n    {\n        this.emit('pinch', { distance })\n    }\n\n    /**\n     * L'evento rotate non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n     *\n     * @param {Number} rotation\n     */\n    rotate(rotation)\n    {\n        this.emit('rotate', { rotation })\n    }\n\n    /* -------------------------------------\n     *  Bindaggio ed emissione eventi\n     * ------------------------------------- */\n\n    /**\n     * Emette un evento se settato\n     *\n     * @param {String} event Nome dell'evento da emettere\n     */\n    emit(event, data)\n    {\n        if(this.events[event]) {\n\n            //let result = this.events[event](data ? data : this.stateValue, data ? this.stateValue : null)\n            let result = this.events[event](this.setEventData(data))\n\n            // Prevengo la gestione degli altri eventi se - nella funzione settata dall'utente - viene restituito il booleano false\n            return result === false && this.clear()\n        }\n    }\n\n    setEventData(data)\n    {\n        let coords, directions, duration\n\n        // Per l'evento tap e press\n        if( !this.ended ){\n            this.ended = this.utils.create(null)\n            coords = { x: this.started.touches[0].clientX, y: this.started.touches[0].clientY }\n        } else {\n            coords = this.utils.coords(this.started, this.ended)\n            directions = this.utils.stringDirection(coords)\n        }\n        duration = (this.ended.time - this.started.time) / 1000\n\n        return Object.assign({}, {\n            el: this.el,\n            coords,\n            directions,\n            velocity: {\n                x: coords.x / duration,\n                y: coords.y / duration,\n                d: (this.utils.scalar(coords.x, coords.y) / duration )\n            },\n            fingers: this.utils.howManyTouches(this.ended),\n            $state: this.stateValue,\n            $event: this.$event,\n            duration\n        }, data)\n    }\n\n    /**\n     * Aggiunge un evento\n     */\n    attach(events)\n    {\n        Object.keys(events).forEach( e => this.events[e] = events[e] )\n    }\n    /**\n     * Rimuove un evento\n     */\n    detach(events)\n    {\n        events = events.constructor.name === 'Array' ? events : [events]\n        events.forEach(e => this.events[e] && delete this.events[e])\n    }\n\n    /**\n     * Bindo gli eventi all'elemento\n     */\n    on(events, handler, passive)\n    {\n        events.split(' ').forEach( e => this.el.addEventListener(e, handler, passive ? { passive: true } : false) )\n    }\n\n    /**\n     * Rimuovo i listeners\n     */\n    off(events, handler, passive)\n    {\n        events.split(' ').forEach( e => this.el.removeEventListener(e, handler, passive ? { passive: true } : false) )\n    }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/AloeTouchObject.js","let State = {\n\n    /**\n     * Crea un oggetto vuoto per il contenimento dei valori degli eventi pan, pinch e rotate\n     */\n    init()\n    {\n        return {\n            pan: { x: null, y: null },\n            pinch: null,\n            rotate: null\n        }\n    },\n\n    /**\n     * Crea un nuovo oggetto che conterra i valori precedenti degli eventi\n     */\n    create()\n    {\n        return Object.assign({}, State.init(), { $old: State.init() })\n    },\n\n    /**\n     * Binda i nuovi valori dall'evento corrente (chiamato da touchmove->dispatch->emit) con i valori precendenti\n     *\n     * @param {ATS} state\n     * @param {ATEvent} event\n     */\n    set(state, event, customState)\n    {\n        event.rotate && ( state.rotate = event.rotate + state.$old.rotate )\n        event.pinch && ( state.pinch = event.pinch + state.$old.pinch )\n        event.pan && event.pan.x && ( state.pan.x = event.pan.x + state.$old.pan.x )\n        event.pan && event.pan.y && ( state.pan.y = event.pan.y + state.$old.pan.y )\n\n        // Aggiungo gli state settati dall'utente\n        Object.keys(customState).forEach( cs => state[cs] = customState[cs](state) )\n\n        return state\n    },\n\n    /**\n     * All'evento touchend setto i valori precendeti con l'ultimo settato\n     *\n     * @param {ATS} state\n     */\n    refresh(state)\n    {\n        state.$old = State.copyState(state)\n\n        return state\n    },\n\n    /**\n     * Copio l'oggetto state\n     */\n    copyState(state)\n    {\n        let n = {}\n        Object.keys(state).forEach( k => {\n            k != '$old' && ( n[k] = typeof(state[k]) === 'object' && state[k] !== null ? State.copyState(state[k]) : state[k] )\n        })\n        return n\n    }\n\n}\n\nexport default {\n    set: State.set,\n    create: State.create,\n    refresh: State.refresh\n}\n\n\n// WEBPACK FOOTER //\n// ./src/services/state.js","let Utils = {\n    /**\n     * Crea (o modifico) l'oggetto ATO (AloeTouchObject) contenente la Touchlist\n     *\n     * @param  {Event}      event\n     * @param  {DOMElement} element\n     * @param  {ATO?}       oldATO\n     */\n    create(event, element, oldATO)\n    {\n        let ATO = oldATO ? Object.assign({}, oldATO, { updated: true }) : { time: Date.now() }\n\n        ATO.touches = event && event.touches ? Utils.getTouches(event.touches, element) : [{ clientX: 0, clientY: 0 }]\n\n        return ATO\n    },\n\n    /**\n     * Preleva la touchlist (modificata) dall'evento\n     *\n     * @param  {Touchlist}  touches [description]\n     * @param  {DOMElement} element L'emento esiste solo se è settato STRICT\n     * @return {Array}\n     */\n    getTouches(touches, element){\n        let data = []\n\n        Object.keys(touches).forEach(e => {\n            Utils.validate(touches[e], element) && data.push({\n                clientX: touches[e].clientX,\n                clientY: touches[e].clientY\n            })\n        })\n\n        return data\n    },\n\n    /**\n     * Aggiunge l'oggetto Touch se rispetta la validazone\n     *\n     * @param {Touch}      touch\n     * @param {DOMElement} element\n     */\n    validate(touch, element)\n    {\n        return touch && ( touch.clientX || touch.clientY ) && (!element || element == touch.target)\n    },\n\n    /**\n     * Ritorna la differenza delle coordinate tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    coords(ATOstart, ATOend)\n    {\n        return Utils.diff(ATOstart.touches[0], ATOend.touches[0])\n    },\n\n    /**\n     * Ritorna una coordinata basata sulla differenza tra due punti\n     *\n     * @param {ATO.touch} pointA\n     * @param {ATO.touch} pointB\n     */\n    diff(pointA, pointB)\n    {\n        return {\n            x: pointB.clientX - pointA.clientX,\n            y: pointB.clientY - pointA.clientY\n        }\n    },\n\n    /**\n     * Ritorna il numero di touch\n     *\n     * @param {ATO} ATOe\n     */\n    howManyTouches(ATO)\n    {\n        return ATO && ATO.touches ? ATO.touches.length : 0\n    },\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente verticale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isVertical(ATOstart, ATOend)\n    {\n        let coords = Utils.coords(ATOstart, ATOend)\n        return Math.abs(coords.y) > Math.abs(coords.x)\n    },\n\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente orizzontale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isHorizontal(ATOstart, ATOend)\n    {\n        let coords = Utils.coords(ATOstart, ATOend)\n        return Math.abs(coords.x) > Math.abs(coords.y)\n    },\n\n    /**\n     * Ritorna la direzione in base al valore delle coordinate\n     *\n     * @param {Object{x,y} } coords\n     */\n    stringDirection(coords)\n    {\n        return {\n            x: coords.x <= 0 ? 'Left' : 'Right',\n            y: coords.y <= 0 ? 'Top' : 'Bottom'\n        }\n    },\n\n    /* -------------------------------------\n     *  Helper per eventi\n     * ------------------------------------- */\n\n    /**\n     * Ritorna la distanza tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    distanceBetween(ATOstart, ATOend)\n    {\n        return Utils.distance(ATOend) - Utils.distance(ATOstart)\n    },\n\n    /**\n     * Ritorna la distanza vettoriale tra due coordinata\n     *\n     * @param {ATO} ATO\n     */\n    distance(ATO)\n    {\n        let distance = Utils.diff(ATO.touches[0], ATO.touches[1])\n        return Utils.scalar(distance.x, distance.y)\n    },\n\n    /**\n     * Distanza scalare\n     */\n    scalar(a, b)\n    {\n        return Math.sqrt(Math.pow(a, 2) +  Math.pow(b, 2))\n    },\n\n    /**\n     * Ritorna la direzione tangente tra due coordinate\n     *\n     * @param {ATO} ATO\n     */\n    direction(ATO)\n    {\n        let distance = Utils.diff(ATO.touches[0], ATO.touches[1])\n        return Utils.angle(distance.x, distance.y)\n    },\n\n    /**\n     * Angolo\n     */\n    angle(a, b) \n    {\n        return Math.atan2(b, a) * 180 / Math.PI\n    },\n\n    /**\n     * Ritorna l'angolo di rotazione tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    rotation(ATOstart, ATOend)\n    {\n        return Utils.direction(ATOend) - Utils.direction(ATOstart)\n    }\n}\n\nexport default {\n    create: Utils.create,\n    coords: Utils.coords,\n    howManyTouches: Utils.howManyTouches,\n    isVertical: Utils.isVertical,\n    isHorizontal: Utils.isHorizontal,\n    stringDirection: Utils.stringDirection,\n    distanceBetween: Utils.distanceBetween,\n    direction: Utils.direction,\n    rotation: Utils.rotation,\n    angle: Utils.angle,\n    scalar: Utils.scalar\n}\n\n\n// WEBPACK FOOTER //\n// ./src/services/utils.js","import AloeTouchObject from './AloeTouchObject'\n\n/**\n * AloeTouch\n */\nexport default AloeTouch = {\n\n    /**\n     * Contiene il numero di elementi\n     *\n     * @type {Number}\n     */\n    length: 0,\n\n    /**\n     * Lista degli AloeTouchObject\n     *\n     * @type {Object}\n     */\n    list: {},\n\n    /**\n     * Binda un nuovo elemento\n     *\n     * @param {DOMElement} element Elemento da bindare\n     * @param {Object}     events  Eventi da assegnare all'elemento\n     * @param {Boolean}    strict  Se settata, valida l'evento solo se il target del touch è l'elemento bindato\n     */\n    bind(element, events, strict)\n    {\n        let id = ++AloeTouch.length\n\n        return ( AloeTouch.list[id] = {\n                    $id: id,                              // id dell'oggetto\n                 attach: AloeTouch.caller('attach'),      // Binda un evento\n                 detach: AloeTouch.caller('detach'),      // Rimuovo il listener di un evento\n               setState: AloeTouch.caller('setState'),    // Setta uno stato personalizzato\n               getState: AloeTouch.caller('getState'),    // Setta uno stato personalizzato\n            removeState: AloeTouch.caller('removeState'), // Rimuove uno state\n             clearState: AloeTouch.caller('clearState'),  // Azzera la variabile state\n                 isLock: AloeTouch.caller('isLock'),      // Rimuove i listener per tutti gli eventi\n                   lock: AloeTouch.caller('lock'),        // Rimuove i listener per tutti gli eventi\n                 unlock: AloeTouch.caller('unlock'),      // Rebinda i listener per gli eventii\n                   $ref: new AloeTouchObject( id, element, events, strict )  // refrenza all'oggetto\n        } )\n    },\n\n    /**\n     * Chiama una funzione bindando il riferimento dell'oggetto chimante\n     * @param  {String} fn\n     * @return {Function}\n     */\n    caller(fn)\n    {\n        return function(data) {\n            this.$ref && this.$ref[fn](data)\n        }\n    },\n\n    /**\n     * Rimuove i listener ad un elemento\n     *\n     * @param {AloeTouchObject or Numer} aloetouchobject\n     * @return {Boolean} true se l'elemento è stato rimosso, falso altrimenti\n     */\n    unbind(aloetouchobject)\n    {\n        let id = this.getIds(aloetouchobject, true)\n\n        if(id) {\n            AloeTouch.list[id].lock()\n            delete AloeTouch.list[id].$ref\n            delete AloeTouch.list[id]\n            return true\n        }\n\n        return false\n    },\n\n    /**\n     * Ritorna un elemento in base al suo id\n     *\n     * @param {Number} id\n     */\n    get(id)\n    {\n        return AloeTouch.list.hasOwnProperty(id) ? AloeTouch.list[id] : null\n    },\n\n    /**\n     * Ritorna un' array di id\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     * @param {Boolean} flag Ritorna un id se l'array ha lunghezza pari a uno\n     * @return {Array<Number> or Number}\n     */\n    getIds(aloetouchobjects, flag)\n    {\n        aloetouchobjects = aloetouchobjects.constructor.name === 'Array' ? aloetouchobjects : [aloetouchobjects]\n        aloetouchobjects = aloetouchobjects.map( ato => typeof ato === 'number' ? ( AloeTouch.get(ato) ? ato : null ) : ( ato.$ref ? ato.$id : null ) )\n        aloetouchobjects = aloetouchobjects.filter(id => !!id)\n\n        return flag ? ( aloetouchobjects.length == 1 ? aloetouchobjects[0] : aloetouchobjects ) : aloetouchobjects\n    },\n\n    /**\n     * Blocca un oggetto singolo o tutti\n     *\n     * @param {Number?} id Blocca gli eventi per l'oggetto con id 'id'\n     */\n    lock(id)\n    {\n        id ? AloeTouch.list[id].lock() : AloeTouch.map(ato => ato.lock())\n    },\n\n    /**\n     *  Blocca tutti gli oggetti tranne quelli presenti nell'array aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    lockExcept(aloetouchobjects)\n    {\n        ids = this.getIds(ids) || []\n\n        AloeTouch.map((ato, id) => ato[ids.indexOf(id) == -1 ? 'unlock' : 'lock']())\n    },\n\n    /**\n     * Blocca solo gli oggetti presenti in aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    lockOnly(aloetouchobjects)\n    {\n        ids = this.getIds(ids) || []\n\n        AloeTouch.map((ato, id) => ato[ids.indexOf(id) >= 0 ? 'lock' : 'unlock']())\n    },\n\n    /**\n     * Abilita li eventi ad un oggetto singolo o tutti\n     *\n     * @param {Number?} id\n     */\n    unlock(id)\n    {\n        id ? AloeTouch.list[id].unlock() : AloeTouch.map(ato => ato.unlock())\n    },\n\n    /**\n     * Abilita gli eventi tranne agli elementi presenti nell'array aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    unlockExcept(aloetouchobjects)\n    {\n        AloeTouch.lockOnly(aloetouchobjects)\n    },\n\n    /**\n     * Abilita gli eventi solo agli elementi presenti nell'array aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    unlockOnly(aloetouchobjects)\n    {\n        AloeTouch.lockExcept(aloetouchobjects)\n    },\n\n    /**\n     * Mappa tutti li elementi bindati\n     *\n     * @param {Callable(AloeTouchObject, id)}\n     */\n    map(callable) {\n        Object.keys(AloeTouch.list).forEach(id => callable(AloeTouch.list[id], id))\n    }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./src/AloeTouch.js"],"sourceRoot":""}