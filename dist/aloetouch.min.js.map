{"version":3,"sources":["webpack:///dist/aloetouch.min.js","webpack:///webpack/bootstrap 486a9256186ddd8e0f0d","webpack:///./src/AloeTouchObject.js","webpack:///./src/services/state.js","webpack:///./src/services/utils.js","webpack:///./src/AloeTouch.js"],"names":["exports","modules","__webpack_require__","moduleId","installedModules","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireDefault","obj","default","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","_utils","_utils2","_state","_state2","ALOETOUCH_MIN_TIME","ALOETOUCH_PRESS_MIN_TIME","ALOETOUCH_MIN_SWIPE_DISTANCE","AloeTouchObject","id","element","events","strict","this","el","document","querySelector","strictMode","state","locked","utils","start","bind","move","finish","clear","clearState","unlock","event","console","log","started","create","updated","mooving","pressEmitted","window","setTimeout","press","emit","_this","prepareMove","ended","isPermissible","preventDefault","stopPropagation","dispatch","callback","time","isHorizontal","fingers","howManyTouches","pan","pinch","rotate","coords","distanceBetween","rotation","setStateAndEmit","eventValues","stateValue","set","pan2","swipe","tap","refresh","clearTimeout","off","on","_this2","keys","forEach","Date","now","Math","abs","x","stringDirection","y","distance","data","setEventData","directions","duration","touches","clientX","clientY","assign","velocity","scalar","$state","_this3","e","_this4","constructor","handler","_this5","split","addEventListener","passive","_this6","removeEventListener","_typeof","Symbol","iterator","State","init","$old","customState","cs","copyState","k","Utils","oldATO","ATO","getTouches","validate","push","touch","contains","ATOstart","ATOend","diff","pointA","pointB","isVertical","a","b","sqrt","pow","direction","angle","atan2","PI","_AloeTouchObject","_AloeTouchObject2","AloeTouch","list","$id","attach","caller","detach","setState","getState","removeState","isLock","lock","$ref","fn","unbind","aloetouchobject","getIds","aloetouchobjects","flag","map","ato","filter","lockExcept","ids","indexOf","lockOnly","unlockExcept","unlockOnly","callable"],"mappings":"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","file":"./dist/aloetouch.min.js","sourcesContent":["exports[\"AloeTouch\"] =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(2);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _state = __webpack_require__(1);\n\nvar _state2 = _interopRequireDefault(_state);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * La durata minimina per bindare un evento\n * Utile a non prevenire lo scrolling\n * @type {Number}\n */\nvar ALOETOUCH_MIN_TIME = 85;\n\n/**\n * Tempo minimo per bindare l'evento press\n * @type {Number}\n */\nvar ALOETOUCH_PRESS_MIN_TIME = 600;\n\n/**\n * Distanza minima per bindare l'evento swipe[Direction]\n * @type {Number}\n */\nvar ALOETOUCH_MIN_SWIPE_DISTANCE = 20;\n\n/**\n * Assegna gli eventi touch ad un elemento\n *\n * GLi eventi disponibili sono:\n * Touch singolo\n *     tap, press, pan, swipeLeft, swipeRight, swipeTop, swipeBottom\n * Touch doppio\n *     pinch, rotate\n */\n\nvar AloeTouchObject = function () {\n\n    /**\n     * Binda gli eventi all'elemento\n     * @param {DomElement} element\n     * @param {Object} events Oggetto che contiene le funzioni es. { tap: ..., swipeLeft: ..., rotate: ... }\n     * @param {Boolean} strict Aggiunge le coordinate del tuoch solo se il target è uguale all'elemento bindato\n     */\n    function AloeTouchObject(id, element, events, strict) {\n        _classCallCheck(this, AloeTouchObject);\n\n        this.id = id;\n        this.el = typeof element === 'string' ? document.querySelector(element) : element;\n        this.events = events || {};\n        this.strictMode = strict || false;\n        this.events.state = this.events.state || {};\n        this.locked = true;\n\n        // Services\n        this.utils = _utils2.default;\n        this.state = _state2.default;\n\n        this.start = this.start.bind(this);\n        this.move = this.move.bind(this);\n        this.finish = this.finish.bind(this);\n\n        this.clear();\n        this.clearState();\n        this.unlock();\n    }\n\n    /**\n     * Eventi 'touchstart' 'mousedown'\n     */\n\n\n    _createClass(AloeTouchObject, [{\n        key: 'start',\n        value: function start(event) {\n            if (!this.locked) {\n                console.log('start');\n                this.started = this.utils.create(event, this.el, this.strictMode, this.started);\n                this.started.updated ? this.mooving = true : this.pressEmitted = window.setTimeout(this.press.bind(this), ALOETOUCH_PRESS_MIN_TIME);\n                // Binderà l'evento press solo se non sarà invocato nè l'evento move, nè finish\n                this.emit('start');\n            }\n        }\n\n        /**\n         * Eventi 'touchmove'\n         */\n\n    }, {\n        key: 'move',\n        value: function move(event) {\n            var _this = this;\n\n            // Controllo se sono settate le coordinate del touch all'evento start e bindo le nuove coordinate (ended)\n\n            this.prepareMove(event, function (ended) {\n                if (_this.isPermissible()) {\n                    event.preventDefault();\n                    event.stopPropagation();\n\n                    _this.mooving = true;\n                    _this.dispatch(); // Smisto gli eventi 'mobili': pan, rotate, pitch\n                } else {\n                    _this.mooving = false; // L'evento non può più essere prevenuto\n                }\n            });\n        }\n\n        /**\n         * Eseguo la funczione moove solo se sono settate le coordinate iniziali\n         */\n\n    }, {\n        key: 'prepareMove',\n        value: function prepareMove(event, callback) {\n            !this.locked && this.started ? callback(this.ended = this.utils.create(event, this.el, this.strictMode)) : null;\n        }\n\n        /**\n         * Questa funzionalitò è molto importante poiché previene che l'evento 'touchmove'\n         * prevenga l'azione di default dell'evento (e quindi blocchi lo scrolling)\n         */\n\n    }, {\n        key: 'isPermissible',\n        value: function isPermissible() {\n            var time = this.ended.time - this.started.time;\n            var isHorizontal = this.utils.isHorizontal(this.started, this.ended); // Se lo scrolling è orizzontale implica che l'utente non sta scorrendo\n            // verticalmente la pagina, quindi è possibile bloccare lo scrolling\n            return this.mooving || this.mooving === null // Il caso in cui questa variabile risulta === null avviene solo la priva volta che viene invocata la fuonzione move,\n            && (isHorizontal || time > ALOETOUCH_MIN_TIME) // infatti viene nullata con la funzione clear presente nel metodo start. Questa cndizione è necessaria perché il metodo\n            ; // preventDefault() di Event non può essere invocato in un secondo stadio dell'evento 'touchmove', ma solo la prima volta\n        }\n\n        /**\n         * Smisto gli eventi in 'touchmove' in base al numero di tocchi\n         */\n\n    }, {\n        key: 'dispatch',\n        value: function dispatch() {\n            var fingers = this.utils.howManyTouches(this.ended),\n                pan = null,\n                pinch = null,\n                rotate = null;\n\n            if (fingers == 1) {\n                pan = this.utils.coords(this.started, this.ended);\n            } else if (fingers == 2) {\n                pan = this.utils.coords(this.started, this.ended);\n                pinch = this.utils.distanceBetween(this.started, this.ended);\n                rotate = this.utils.rotation(this.started, this.ended);\n            }\n\n            this.setStateAndEmit({ pan: pan, pinch: pinch, rotate: rotate }, fingers);\n            this.emit('move');\n        }\n\n        /**\n         * Setta i valore dello state ed emette gli eventi\n         *\n         * @param {Object} eventValues Valori da emettere\n         */\n\n    }, {\n        key: 'setStateAndEmit',\n        value: function setStateAndEmit(eventValues, fingers) {\n            this.stateValue = this.state.set(this.stateValue, eventValues, this.events.state);\n\n            fingers == 1 && eventValues.pan && this.pan();\n            fingers == 2 && eventValues.pan && this.pan2();\n            eventValues.pinch && this.pinch(eventValues.pinch);\n            eventValues.rotate && this.rotate(eventValues.rotate);\n        }\n\n        /**\n         * Termino l'evento\n         */\n\n    }, {\n        key: 'finish',\n        value: function finish(event) {\n            console.log('finish');\n            if (!this.locked && this.started) // Controllo che vale anche per l'evento touchmove\n                {\n                    this.mooving && this.swipe();\n                    this.mooving === null && this.tap();\n                    this.stateValue = this.state.refresh(this.stateValue, this.events.state); // aggiorno lo state\n                    this.emit('end');\n                }\n\n            this.clear();\n        }\n\n        /**\n         * Reset delle variabili\n         */\n\n    }, {\n        key: 'clear',\n        value: function clear() {\n            console.log('CLEAR');\n            this.pressEmitted && window.clearTimeout(this.pressEmitted); // Cancello l'evento press\n\n            this.started = null;\n            this.ended = null;\n            this.mooving = null;\n            this.pressEmitted = null;\n        }\n\n        /* -------------------------------------\n         *  Eventi\n         * ------------------------------------- */\n\n        /**\n         * Ritorna vero se questo oggetto è bloccato, falso altrimenti\n         *\n         * @return {Boolean}\n         */\n\n    }, {\n        key: 'isLock',\n        value: function isLock() {\n            return this.locked;\n        }\n\n        /**\n         * Rimuove i listener degli eventi\n         */\n\n    }, {\n        key: 'lock',\n        value: function lock() {\n            if (!this.locked) {\n                this.off('touchstart', this.start);\n                this.off('touchmove', this.move);\n                this.off('touchend touchcancel', this.finish);\n                this.locked = true;\n            }\n        }\n\n        /**\n         * Binda gli eventi\n         */\n\n    }, {\n        key: 'unlock',\n        value: function unlock() {\n            if (this.locked) {\n                this.on('touchstart', this.start);\n                this.on('touchmove', this.move);\n                this.on('touchend touchcancel', this.finish);\n                this.locked = false;\n            }\n        }\n\n        /* -------------------------------------\n         *  State\n         * ------------------------------------- */\n\n        /**\n         * Setta uno state\n         *\n         * @param {Object} state\n         */\n\n    }, {\n        key: 'setState',\n        value: function setState(state) {\n            var _this2 = this;\n\n            Object.keys(state).forEach(function (s) {\n                return _this2.events.state[s] = state[s];\n            });\n        }\n\n        /**\n         * Ritorna i valori dello state corrente\n         */\n\n    }, {\n        key: 'getState',\n        value: function getState() {\n            return this.stateValue;\n        }\n\n        /**\n         * Rimuove uno state\n         *\n         * @param {String} name Nome dello state da rimuovere\n         */\n\n    }, {\n        key: 'removeState',\n        value: function removeState(name) {\n            this.state[name] = null;\n            this.stateValue[name] = null;\n            delete this.state[name];\n            delete this.stateValue[name];\n        }\n\n        /**\n         * Cancella lo state con ivalori correnti\n         */\n\n    }, {\n        key: 'clearState',\n        value: function clearState() {\n            this.stateValue = this.state.create();\n        }\n\n        /* -------------------------------------\n         *  Eventi\n         * ------------------------------------- */\n\n        /**\n         * Valido l'evento tap\n         */\n\n    }, {\n        key: 'tap',\n        value: function tap() {\n            var fingers = this.utils.howManyTouches(this.ended);\n            var time = Date.now() - this.started.time;\n\n            if (fingers < 2 && time < ALOETOUCH_PRESS_MIN_TIME) this.emit('tap');\n        }\n\n        /**\n         * Evento press\n         */\n\n    }, {\n        key: 'press',\n        value: function press() {\n            if (this.pressEmitted && !this.mooving) {\n                this.emit('press');\n                this.pressEmitted = null;\n            }\n        }\n\n        /**\n         * Valido l'evento swipe\n         */\n\n    }, {\n        key: 'swipe',\n        value: function swipe() {\n            var coords = this.ended ? this.utils.coords(this.started, this.ended) : {};\n\n            if (Math.abs(coords.x) > ALOETOUCH_MIN_SWIPE_DISTANCE) {\n                var stringDirection = this.utils.stringDirection(coords);\n\n                this.emit('swipe' + stringDirection.x);\n                this.emit('swipe' + stringDirection.y);\n                this.emit('swipe');\n            }\n        }\n\n        /**\n         * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n          * @param {Object} coords\n         */\n\n    }, {\n        key: 'pan',\n        value: function pan() {\n            this.emit('pan');\n        }\n\n        /**\n         * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n          * @param {Object} coords\n         */\n\n    }, {\n        key: 'pan2',\n        value: function pan2() {\n            this.emit('pan2');\n        }\n\n        /**\n         * L'evento pinch non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n         *\n         * @param {Number} distance\n         */\n\n    }, {\n        key: 'pinch',\n        value: function pinch(distance) {\n            this.emit('pinch', { distance: distance });\n        }\n\n        /**\n         * L'evento rotate non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n         *\n         * @param {Number} rotation\n         */\n\n    }, {\n        key: 'rotate',\n        value: function rotate(rotation) {\n            this.emit('rotate', { rotation: rotation });\n        }\n\n        /* -------------------------------------\n         *  Bindaggio ed emissione eventi\n         * ------------------------------------- */\n\n        /**\n         * Emette un evento se settato\n         *\n         * @param {String} event Nome dell'evento da emettere\n         */\n\n    }, {\n        key: 'emit',\n        value: function emit(event, data) {\n            if (this.events[event]) {\n\n                //let result = this.events[event](data ? data : this.stateValue, data ? this.stateValue : null)\n                var result = this.events[event](this.setEventData(data));\n\n                // Prevengo la gestione degli altri eventi se - nella funzione settata dall'utente - viene restituito il booleano false\n                return result === false && this.clear();\n            }\n        }\n    }, {\n        key: 'setEventData',\n        value: function setEventData(data) {\n            var coords = void 0,\n                directions = void 0,\n                duration = void 0;\n\n            // Per l'evento tap e press\n            if (!this.ended) {\n                this.ended = this.utils.create(null);\n                coords = { x: this.started.touches[0].clientX, y: this.started.touches[0].clientY };\n            } else {\n                coords = this.utils.coords(this.started, this.ended);\n                directions = this.utils.stringDirection(coords);\n            }\n            duration = (this.ended.time - this.started.time) / 1000;\n\n            return Object.assign({}, {\n                el: this.el,\n                coords: coords,\n                directions: directions,\n                velocity: {\n                    x: coords.x / duration,\n                    y: coords.y / duration,\n                    d: this.utils.scalar(coords.x, coords.y) / duration\n                },\n                fingers: this.utils.howManyTouches(this.ended),\n                $state: this.stateValue,\n                duration: duration\n            }, data);\n        }\n\n        /**\n         * Aggiunge un evento\n         */\n\n    }, {\n        key: 'attach',\n        value: function attach(events) {\n            var _this3 = this;\n\n            Object.keys(events).forEach(function (e) {\n                return _this3.events[e] = events[e];\n            });\n        }\n        /**\n         * Rimuove un evento\n         */\n\n    }, {\n        key: 'detach',\n        value: function detach(events) {\n            var _this4 = this;\n\n            events = events.constructor.name === 'Array' ? events : [events];\n            events.forEach(function (e) {\n                return _this4.events[e] && delete _this4.events[e];\n            });\n        }\n\n        /**\n         * Bindo gli eventi all'elemento\n         */\n\n    }, {\n        key: 'on',\n        value: function on(events, handler) {\n            var _this5 = this;\n\n            events.split(' ').forEach(function (e) {\n                return _this5.el.addEventListener(e, handler, true);\n            });\n        }\n\n        /**\n         * Rimuovo i listeners\n         */\n\n    }, {\n        key: 'off',\n        value: function off(events, handler, passive) {\n            var _this6 = this;\n\n            events.split(' ').forEach(function (e) {\n                return _this6.el.removeEventListener(e, handler, true);\n            });\n        }\n    }]);\n\n    return AloeTouchObject;\n}();\n\nexports.default = AloeTouchObject;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar State = {\n\n    /**\n     * Crea un oggetto vuoto per il contenimento dei valori degli eventi pan, pinch e rotate\n     */\n    init: function init() {\n        return {\n            pan: { x: null, y: null },\n            pinch: null,\n            rotate: null\n        };\n    },\n\n\n    /**\n     * Crea un nuovo oggetto che conterra i valori precedenti degli eventi\n     */\n    create: function create() {\n        return Object.assign({}, State.init(), { $old: State.init() });\n    },\n\n\n    /**\n     * Binda i nuovi valori dall'evento corrente (chiamato da touchmove->dispatch->emit) con i valori precendenti\n     *\n     * @param {ATS} state\n     * @param {ATEvent} event\n     */\n    set: function set(state, event, customState) {\n        event.rotate && (state.rotate = event.rotate + state.$old.rotate);\n        event.pinch && (state.pinch = event.pinch + state.$old.pinch);\n        event.pan && event.pan.x && (state.pan.x = event.pan.x + state.$old.pan.x);\n        event.pan && event.pan.y && (state.pan.y = event.pan.y + state.$old.pan.y);\n\n        // Aggiungo gli state settati dall'utente\n        Object.keys(customState).forEach(function (cs) {\n            return state[cs] = customState[cs](state);\n        });\n\n        return state;\n    },\n\n\n    /**\n     * All'evento touchend setto i valori precendeti con l'ultimo settato\n     *\n     * @param {ATS} state\n     */\n    refresh: function refresh(state) {\n        state.$old = State.copyState(state);\n\n        return state;\n    },\n\n\n    /**\n     * Copio l'oggetto state\n     */\n    copyState: function copyState(state) {\n        var n = {};\n        Object.keys(state).forEach(function (k) {\n            k != '$old' && (n[k] = _typeof(state[k]) === 'object' && state[k] !== null ? State.copyState(state[k]) : state[k]);\n        });\n        return n;\n    }\n};\n\nexports.default = {\n    set: State.set,\n    create: State.create,\n    refresh: State.refresh\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar Utils = {\n    /**\n     * Crea (o modifico) l'oggetto ATO (AloeTouchObject) contenente la Touchlist\n     *\n     * @param  {Event}      event\n     * @param  {DOMElement} element\n     * @param  {ATO?}       oldATO\n     */\n    create: function create(event, element, strict, oldATO) {\n        var ATO = oldATO ? Object.assign({}, oldATO, { updated: true }) : { time: Date.now() };\n        ATO.touches = event && event.touches ? Utils.getTouches(event.touches, element) : [{ clientX: 0, clientY: 0 }];\n        console.log('create', ATO, event, oldATO);\n\n        return ATO;\n    },\n\n\n    /**\n     * Preleva la touchlist (modificata) dall'evento\n     *\n     * @param  {Touchlist}  touches [description]\n     * @param  {DOMElement} element L'emento esiste solo se è settato STRICT\n     * @return {Array}\n     */\n    getTouches: function getTouches(touches, element, strict) {\n        var data = [];\n\n        Object.keys(touches).forEach(function (e) {\n            Utils.validate(touches[e], element, strict) && data.push({\n                clientX: touches[e].clientX,\n                clientY: touches[e].clientY\n            });\n        });\n\n        return data;\n    },\n\n\n    /**\n     * Aggiunge l'oggetto Touch se rispetta la validazone\n     *\n     * @param {Touch}      touch\n     * @param {DOMElement} element\n     */\n    validate: function validate(touch, element, strict) {\n        return touch && (touch.clientX || touch.clientY) && (!strict ? element.contains(touch.target) : element == touch.target);\n    },\n\n\n    /**\n     * Ritorna la differenza delle coordinate tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    coords: function coords(ATOstart, ATOend) {\n        return Utils.diff(ATOstart.touches[0], ATOend.touches[0]);\n    },\n\n\n    /**\n     * Ritorna una coordinata basata sulla differenza tra due punti\n     *\n     * @param {ATO.touch} pointA\n     * @param {ATO.touch} pointB\n     */\n    diff: function diff(pointA, pointB) {\n        return {\n            x: pointB.clientX - pointA.clientX,\n            y: pointB.clientY - pointA.clientY\n        };\n    },\n\n\n    /**\n     * Ritorna il numero di touch\n     *\n     * @param {ATO} ATOe\n     */\n    howManyTouches: function howManyTouches(ATO) {\n        return ATO && ATO.touches ? ATO.touches.length : 0;\n    },\n\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente verticale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isVertical: function isVertical(ATOstart, ATOend) {\n        var coords = Utils.coords(ATOstart, ATOend);\n        return Math.abs(coords.y) > Math.abs(coords.x);\n    },\n\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente orizzontale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isHorizontal: function isHorizontal(ATOstart, ATOend) {\n        var coords = Utils.coords(ATOstart, ATOend);\n        return Math.abs(coords.x) > Math.abs(coords.y);\n    },\n\n\n    /**\n     * Ritorna la direzione in base al valore delle coordinate\n     *\n     * @param {Object{x,y} } coords\n     */\n    stringDirection: function stringDirection(coords) {\n        return {\n            x: coords.x <= 0 ? 'Left' : 'Right',\n            y: coords.y <= 0 ? 'Top' : 'Bottom'\n        };\n    },\n\n\n    /* -------------------------------------\n     *  Helper per eventi\n     * ------------------------------------- */\n\n    /**\n     * Ritorna la distanza tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    distanceBetween: function distanceBetween(ATOstart, ATOend) {\n        console.log('distanceBetween', ATOstart, ATOend);\n        return Utils.distance(ATOend) - Utils.distance(ATOstart);\n    },\n\n\n    /**\n     * Ritorna la distanza vettoriale tra due coordinata\n     *\n     * @param {ATO} ATO\n     */\n    distance: function distance(ATO) {\n        var distance = Utils.diff(ATO.touches[0], ATO.touches[1]);\n        return Utils.scalar(distance.x, distance.y);\n    },\n\n\n    /**\n     * Distanza scalare\n     */\n    scalar: function scalar(a, b) {\n        return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n    },\n\n\n    /**\n     * Ritorna la direzione tangente tra due coordinate\n     *\n     * @param {ATO} ATO\n     */\n    direction: function direction(ATO) {\n        var distance = Utils.diff(ATO.touches[0], ATO.touches[1]);\n        return Utils.angle(distance.x, distance.y);\n    },\n\n\n    /**\n     * Angolo\n     */\n    angle: function angle(a, b) {\n        return Math.atan2(b, a) * 180 / Math.PI;\n    },\n\n\n    /**\n     * Ritorna l'angolo di rotazione tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    rotation: function rotation(ATOstart, ATOend) {\n        return Utils.direction(ATOend) - Utils.direction(ATOstart);\n    }\n};\n\nexports.default = {\n    create: Utils.create,\n    coords: Utils.coords,\n    howManyTouches: Utils.howManyTouches,\n    isVertical: Utils.isVertical,\n    isHorizontal: Utils.isHorizontal,\n    stringDirection: Utils.stringDirection,\n    distanceBetween: Utils.distanceBetween,\n    direction: Utils.direction,\n    rotation: Utils.rotation,\n    angle: Utils.angle,\n    scalar: Utils.scalar\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AloeTouchObject = __webpack_require__(0);\n\nvar _AloeTouchObject2 = _interopRequireDefault(_AloeTouchObject);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * AloeTouch\n */\nvar AloeTouch = {\n\n  /**\n   * Contiene il numero di elementi\n   *\n   * @type {Number}\n   */\n  length: 0,\n\n  /**\n   * Lista degli AloeTouchObject\n   *\n   * @type {Object}\n   */\n  list: {},\n\n  /**\n   * Binda un nuovo elemento\n   *\n   * @param {DOMElement} element Elemento da bindare\n   * @param {Object}     events  Eventi da assegnare all'elemento\n   * @param {Boolean}    strict  Se settata, valida l'evento solo se il target del touch è l'elemento bindato\n   */\n  bind: function bind(element, events, strict) {\n    var id = ++AloeTouch.length;\n\n    return AloeTouch.list[id] = {\n      $id: id, // id dell'oggetto\n      attach: AloeTouch.caller('attach'), // Binda un evento\n      detach: AloeTouch.caller('detach'), // Rimuovo il listener di un evento\n      setState: AloeTouch.caller('setState'), // Setta uno stato personalizzato\n      getState: AloeTouch.caller('getState'), // Setta uno stato personalizzato\n      removeState: AloeTouch.caller('removeState'), // Rimuove uno state\n      clearState: AloeTouch.caller('clearState'), // Azzera la variabile state\n      isLock: AloeTouch.caller('isLock'), // Rimuove i listener per tutti gli eventi\n      lock: AloeTouch.caller('lock'), // Rimuove i listener per tutti gli eventi\n      unlock: AloeTouch.caller('unlock'), // Rebinda i listener per gli eventii\n      $ref: new _AloeTouchObject2.default(id, element, events, strict) // refrenza all'oggetto\n    };\n  },\n\n\n  /**\n   * Chiama una funzione bindando il riferimento dell'oggetto chimante\n   * @param  {String} fn\n   * @return {Function}\n   */\n  caller: function caller(fn) {\n    return function (data) {\n      this.$ref && this.$ref[fn](data);\n    };\n  },\n\n\n  /**\n   * Rimuove i listener ad un elemento\n   *\n   * @param {AloeTouchObject or Numer} aloetouchobject\n   * @return {Boolean} true se l'elemento è stato rimosso, falso altrimenti\n   */\n  unbind: function unbind(aloetouchobject) {\n    var id = this.getIds(aloetouchobject, true);\n\n    if (id) {\n      AloeTouch.list[id].lock();\n      delete AloeTouch.list[id].$ref;\n      delete AloeTouch.list[id];\n      return true;\n    }\n\n    return false;\n  },\n\n\n  /**\n   * Ritorna un elemento in base al suo id\n   *\n   * @param {Number} id\n   */\n  get: function get(id) {\n    return AloeTouch.list.hasOwnProperty(id) ? AloeTouch.list[id] : null;\n  },\n\n\n  /**\n   * Ritorna un' array di id\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   * @param {Boolean} flag Ritorna un id se l'array ha lunghezza pari a uno\n   * @return {Array<Number> or Number}\n   */\n  getIds: function getIds(aloetouchobjects, flag) {\n    aloetouchobjects = aloetouchobjects.constructor.name === 'Array' ? aloetouchobjects : [aloetouchobjects];\n    aloetouchobjects = aloetouchobjects.map(function (ato) {\n      return typeof ato === 'number' ? AloeTouch.get(ato) ? ato : null : ato.$ref ? ato.$id : null;\n    });\n    aloetouchobjects = aloetouchobjects.filter(function (id) {\n      return !!id;\n    });\n\n    return flag ? aloetouchobjects.length == 1 ? aloetouchobjects[0] : aloetouchobjects : aloetouchobjects;\n  },\n\n\n  /**\n   * Blocca un oggetto singolo o tutti\n   *\n   * @param {Number?} id Blocca gli eventi per l'oggetto con id 'id'\n   */\n  lock: function lock(id) {\n    id ? AloeTouch.list[id].lock() : AloeTouch.map(function (ato) {\n      return ato.lock();\n    });\n  },\n\n\n  /**\n   *  Blocca tutti gli oggetti tranne quelli presenti nell'array aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  lockExcept: function lockExcept(aloetouchobjects) {\n    ids = this.getIds(ids) || [];\n\n    AloeTouch.map(function (ato, id) {\n      return ato[ids.indexOf(id) == -1 ? 'unlock' : 'lock']();\n    });\n  },\n\n\n  /**\n   * Blocca solo gli oggetti presenti in aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  lockOnly: function lockOnly(aloetouchobjects) {\n    ids = this.getIds(ids) || [];\n\n    AloeTouch.map(function (ato, id) {\n      return ato[ids.indexOf(id) >= 0 ? 'lock' : 'unlock']();\n    });\n  },\n\n\n  /**\n   * Abilita li eventi ad un oggetto singolo o tutti\n   *\n   * @param {Number?} id\n   */\n  unlock: function unlock(id) {\n    id ? AloeTouch.list[id].unlock() : AloeTouch.map(function (ato) {\n      return ato.unlock();\n    });\n  },\n\n\n  /**\n   * Abilita gli eventi tranne agli elementi presenti nell'array aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  unlockExcept: function unlockExcept(aloetouchobjects) {\n    AloeTouch.lockOnly(aloetouchobjects);\n  },\n\n\n  /**\n   * Abilita gli eventi solo agli elementi presenti nell'array aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  unlockOnly: function unlockOnly(aloetouchobjects) {\n    AloeTouch.lockExcept(aloetouchobjects);\n  },\n\n\n  /**\n   * Mappa tutti li elementi bindati\n   *\n   * @param {Callable(AloeTouchObject, id)}\n   */\n  map: function map(callable) {\n    Object.keys(AloeTouch.list).forEach(function (id) {\n      return callable(AloeTouch.list[id], id);\n    });\n  }\n};\n\nexports.default = AloeTouch;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dist/aloetouch.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 486a9256186ddd8e0f0d","import Utils from './services/utils'\nimport State from './services/state'\n\n/**\n * La durata minimina per bindare un evento\n * Utile a non prevenire lo scrolling\n * @type {Number}\n */\nconst ALOETOUCH_MIN_TIME = 85\n\n/**\n * Tempo minimo per bindare l'evento press\n * @type {Number}\n */\nconst ALOETOUCH_PRESS_MIN_TIME = 600\n\n/**\n * Distanza minima per bindare l'evento swipe[Direction]\n * @type {Number}\n */\nconst ALOETOUCH_MIN_SWIPE_DISTANCE = 20\n\n/**\n * Assegna gli eventi touch ad un elemento\n *\n * GLi eventi disponibili sono:\n * Touch singolo\n *     tap, press, pan, swipeLeft, swipeRight, swipeTop, swipeBottom\n * Touch doppio\n *     pinch, rotate\n */\nexport default class AloeTouchObject {\n\n    /**\n     * Binda gli eventi all'elemento\n     * @param {DomElement} element\n     * @param {Object} events Oggetto che contiene le funzioni es. { tap: ..., swipeLeft: ..., rotate: ... }\n     * @param {Boolean} strict Aggiunge le coordinate del tuoch solo se il target è uguale all'elemento bindato\n     */\n    constructor(id, element, events, strict)\n    {\n        this.id = id\n        this.el = typeof element === 'string' ? document.querySelector(element) : element\n        this.events = events || {}\n        this.strictMode = strict || false\n        this.events.state = this.events.state || {}\n        this.locked = true\n\n        // Services\n        this.utils = Utils\n        this.state = State\n\n        this.start = this.start.bind(this)\n        this.move = this.move.bind(this)\n        this.finish = this.finish.bind(this)\n\n        this.clear()\n        this.clearState()\n        this.unlock()\n    }\n\n\n    /**\n     * Eventi 'touchstart' 'mousedown'\n     */\n    start(event)\n    {\n        if(!this.locked) {\n            console.log('start');\n            this.started = this.utils.create(event, this.el, this.strictMode, this.started)\n            this.started.updated ? ( this.mooving = true ) : ( this.pressEmitted = window.setTimeout(this.press.bind(this), ALOETOUCH_PRESS_MIN_TIME) )\n            // Binderà l'evento press solo se non sarà invocato nè l'evento move, nè finish\n            this.emit('start')\n        }\n    }\n\n    /**\n     * Eventi 'touchmove'\n     */\n    move(event)\n    {\n        // Controllo se sono settate le coordinate del touch all'evento start e bindo le nuove coordinate (ended)\n\n        this.prepareMove(event, ended => {\n            if(this.isPermissible())\n            {\n                event.preventDefault()\n                event.stopPropagation()\n\n                this.mooving = true\n                this.dispatch() // Smisto gli eventi 'mobili': pan, rotate, pitch\n            } else {\n                this.mooving = false // L'evento non può più essere prevenuto\n            }\n        })\n    }\n\n    /**\n     * Eseguo la funczione moove solo se sono settate le coordinate iniziali\n     */\n    prepareMove(event, callback)\n    {\n        !this.locked && this.started ? callback((this.ended = this.utils.create(event, this.el, this.strictMode))) : null\n    }\n\n    /**\n     * Questa funzionalitò è molto importante poiché previene che l'evento 'touchmove'\n     * prevenga l'azione di default dell'evento (e quindi blocchi lo scrolling)\n     */\n    isPermissible()\n    {\n        let time = this.ended.time - this.started.time\n        let isHorizontal = this.utils.isHorizontal(this.started, this.ended); // Se lo scrolling è orizzontale implica che l'utente non sta scorrendo\n                                                                              // verticalmente la pagina, quindi è possibile bloccare lo scrolling\n        return this.mooving || (\n            this.mooving === null                              // Il caso in cui questa variabile risulta === null avviene solo la priva volta che viene invocata la fuonzione move,\n            && ( isHorizontal || time > ALOETOUCH_MIN_TIME )   // infatti viene nullata con la funzione clear presente nel metodo start. Questa cndizione è necessaria perché il metodo\n        )                                                      // preventDefault() di Event non può essere invocato in un secondo stadio dell'evento 'touchmove', ma solo la prima volta\n    }\n\n    /**\n     * Smisto gli eventi in 'touchmove' in base al numero di tocchi\n     */\n    dispatch()\n    {\n        let fingers = this.utils.howManyTouches(this.ended),\n            pan = null, pinch = null, rotate = null\n\n        if(fingers == 1) {\n            pan = this.utils.coords(this.started, this.ended)\n        } else if(fingers == 2) {\n            pan = this.utils.coords(this.started, this.ended)\n            pinch = this.utils.distanceBetween(this.started, this.ended)\n            rotate = this.utils.rotation(this.started, this.ended)\n        }\n\n        this.setStateAndEmit({ pan, pinch, rotate }, fingers)\n        this.emit('move')\n    }\n\n    /**\n     * Setta i valore dello state ed emette gli eventi\n     *\n     * @param {Object} eventValues Valori da emettere\n     */\n    setStateAndEmit(eventValues, fingers)\n    {\n        this.stateValue = this.state.set(this.stateValue, eventValues, this.events.state)\n\n        fingers == 1 && eventValues.pan && this.pan()\n        fingers == 2 && eventValues.pan && this.pan2()\n        eventValues.pinch && this.pinch(eventValues.pinch)\n        eventValues.rotate && this.rotate(eventValues.rotate)\n    }\n\n\n    /**\n     * Termino l'evento\n     */\n    finish(event)\n    {\n        console.log('finish');\n        if( !this.locked && this.started )  // Controllo che vale anche per l'evento touchmove\n        {\n            this.mooving && this.swipe()\n            this.mooving === null && this.tap()\n            this.stateValue = this.state.refresh(this.stateValue, this.events.state) // aggiorno lo state\n            this.emit('end')\n        }\n\n        this.clear()\n    }\n\n    /**\n     * Reset delle variabili\n     */\n    clear()\n    {\n        console.log('CLEAR');\n        this.pressEmitted && window.clearTimeout(this.pressEmitted) // Cancello l'evento press\n\n        this.started = null\n        this.ended = null\n        this.mooving = null\n        this.pressEmitted = null\n    }\n\n    /* -------------------------------------\n     *  Eventi\n     * ------------------------------------- */\n\n    /**\n     * Ritorna vero se questo oggetto è bloccato, falso altrimenti\n     *\n     * @return {Boolean}\n     */\n    isLock() {\n        return this.locked\n    }\n\n    /**\n     * Rimuove i listener degli eventi\n     */\n    lock()\n    {\n        if( !this.locked ) {\n            this.off('touchstart', this.start)\n            this.off('touchmove', this.move)\n            this.off('touchend touchcancel', this.finish)\n            this.locked = true\n        }\n    }\n\n    /**\n     * Binda gli eventi\n     */\n    unlock()\n    {\n        if( this.locked ) {\n            this.on('touchstart', this.start)\n            this.on('touchmove', this.move)\n            this.on('touchend touchcancel', this.finish)\n            this.locked = false\n        }\n    }\n\n    /* -------------------------------------\n     *  State\n     * ------------------------------------- */\n\n    /**\n     * Setta uno state\n     *\n     * @param {Object} state\n     */\n    setState(state)\n    {\n        Object.keys(state).forEach( s => this.events.state[s] = state[s] )\n    }\n\n    /**\n     * Ritorna i valori dello state corrente\n     */\n    getState()\n    {\n        return this.stateValue\n    }\n\n    /**\n     * Rimuove uno state\n     *\n     * @param {String} name Nome dello state da rimuovere\n     */\n    removeState(name)\n    {\n        this.state[name] = null\n        this.stateValue[name] = null\n        delete this.state[name]\n        delete this.stateValue[name]\n    }\n\n    /**\n     * Cancella lo state con ivalori correnti\n     */\n    clearState()\n    {\n        this.stateValue = this.state.create()\n    }\n\n    /* -------------------------------------\n     *  Eventi\n     * ------------------------------------- */\n\n    /**\n     * Valido l'evento tap\n     */\n    tap()\n    {\n        let fingers = this.utils.howManyTouches(this.ended)\n        let time = Date.now() - this.started.time\n\n        if( fingers < 2 && time < ALOETOUCH_PRESS_MIN_TIME )\n            this.emit('tap')\n    }\n\n    /**\n     * Evento press\n     */\n    press()\n    {\n        if(this.pressEmitted && !this.mooving) {\n            this.emit('press')\n            this.pressEmitted = null\n        }\n    }\n\n    /**\n     * Valido l'evento swipe\n     */\n    swipe()\n    {\n        let coords = this.ended ? this.utils.coords(this.started, this.ended) : {}\n\n        if( Math.abs(coords.x) > ALOETOUCH_MIN_SWIPE_DISTANCE )\n        {\n            let stringDirection = this.utils.stringDirection(coords)\n\n            this.emit('swipe' + stringDirection.x)\n            this.emit('swipe' + stringDirection.y)\n            this.emit('swipe')\n        }\n    }\n\n    /**\n     * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n\n     * @param {Object} coords\n     */\n    pan()\n    {\n        this.emit('pan')\n    }\n\n    /**\n     * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n\n     * @param {Object} coords\n     */\n    pan2()\n    {\n        this.emit('pan2')\n    }\n\n    /**\n     * L'evento pinch non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n     *\n     * @param {Number} distance\n     */\n    pinch(distance)\n    {\n        this.emit('pinch', { distance })\n    }\n\n    /**\n     * L'evento rotate non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n     *\n     * @param {Number} rotation\n     */\n    rotate(rotation)\n    {\n        this.emit('rotate', { rotation })\n    }\n\n    /* -------------------------------------\n     *  Bindaggio ed emissione eventi\n     * ------------------------------------- */\n\n    /**\n     * Emette un evento se settato\n     *\n     * @param {String} event Nome dell'evento da emettere\n     */\n    emit(event, data)\n    {\n        if(this.events[event]) {\n\n            //let result = this.events[event](data ? data : this.stateValue, data ? this.stateValue : null)\n            let result = this.events[event](this.setEventData(data))\n\n            // Prevengo la gestione degli altri eventi se - nella funzione settata dall'utente - viene restituito il booleano false\n            return result === false && this.clear()\n        }\n    }\n\n    setEventData(data)\n    {\n        let coords, directions, duration\n\n        // Per l'evento tap e press\n        if( !this.ended ){\n            this.ended = this.utils.create(null)\n            coords = { x: this.started.touches[0].clientX, y: this.started.touches[0].clientY }\n        } else {\n            coords = this.utils.coords(this.started, this.ended)\n            directions = this.utils.stringDirection(coords)\n        }\n        duration = (this.ended.time - this.started.time) / 1000\n\n        return Object.assign({}, {\n            el: this.el,\n            coords,\n            directions,\n            velocity: {\n                x: coords.x / duration,\n                y: coords.y / duration,\n                d: (this.utils.scalar(coords.x, coords.y) / duration )\n            },\n            fingers: this.utils.howManyTouches(this.ended),\n            $state: this.stateValue,\n            duration\n        }, data)\n    }\n\n    /**\n     * Aggiunge un evento\n     */\n    attach(events)\n    {\n        Object.keys(events).forEach( e => this.events[e] = events[e] )\n    }\n    /**\n     * Rimuove un evento\n     */\n    detach(events)\n    {\n        events = events.constructor.name === 'Array' ? events : [events]\n        events.forEach(e => this.events[e] && delete this.events[e])\n    }\n\n    /**\n     * Bindo gli eventi all'elemento\n     */\n    on(events, handler)\n    {\n        events.split(' ').forEach( e => this.el.addEventListener(e, handler, true) )\n    }\n\n    /**\n     * Rimuovo i listeners\n     */\n    off(events, handler, passive)\n    {\n        events.split(' ').forEach( e => this.el.removeEventListener(e, handler, true) )\n    }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/AloeTouchObject.js","let State = {\n\n    /**\n     * Crea un oggetto vuoto per il contenimento dei valori degli eventi pan, pinch e rotate\n     */\n    init()\n    {\n        return {\n            pan: { x: null, y: null },\n            pinch: null,\n            rotate: null\n        }\n    },\n\n    /**\n     * Crea un nuovo oggetto che conterra i valori precedenti degli eventi\n     */\n    create()\n    {\n        return Object.assign({}, State.init(), { $old: State.init() })\n    },\n\n    /**\n     * Binda i nuovi valori dall'evento corrente (chiamato da touchmove->dispatch->emit) con i valori precendenti\n     *\n     * @param {ATS} state\n     * @param {ATEvent} event\n     */\n    set(state, event, customState)\n    {\n        event.rotate && ( state.rotate = event.rotate + state.$old.rotate )\n        event.pinch && ( state.pinch = event.pinch + state.$old.pinch )\n        event.pan && event.pan.x && ( state.pan.x = event.pan.x + state.$old.pan.x )\n        event.pan && event.pan.y && ( state.pan.y = event.pan.y + state.$old.pan.y )\n\n        // Aggiungo gli state settati dall'utente\n        Object.keys(customState).forEach( cs => state[cs] = customState[cs](state) )\n\n        return state\n    },\n\n    /**\n     * All'evento touchend setto i valori precendeti con l'ultimo settato\n     *\n     * @param {ATS} state\n     */\n    refresh(state)\n    {\n        state.$old = State.copyState(state)\n\n        return state\n    },\n\n    /**\n     * Copio l'oggetto state\n     */\n    copyState(state)\n    {\n        let n = {}\n        Object.keys(state).forEach( k => {\n            k != '$old' && ( n[k] = typeof(state[k]) === 'object' && state[k] !== null ? State.copyState(state[k]) : state[k] )\n        })\n        return n\n    }\n\n}\n\nexport default {\n    set: State.set,\n    create: State.create,\n    refresh: State.refresh\n}\n\n\n// WEBPACK FOOTER //\n// ./src/services/state.js","let Utils = {\n    /**\n     * Crea (o modifico) l'oggetto ATO (AloeTouchObject) contenente la Touchlist\n     *\n     * @param  {Event}      event\n     * @param  {DOMElement} element\n     * @param  {ATO?}       oldATO\n     */\n    create(event, element, strict, oldATO)\n    {\n        let ATO = oldATO ? Object.assign({}, oldATO, { updated: true }) : { time: Date.now() }\n        ATO.touches = event && event.touches ? Utils.getTouches(event.touches, element) : [{ clientX: 0, clientY: 0 }]\n        console.log('create', ATO, event,  oldATO);\n\n        return ATO\n    },\n\n    /**\n     * Preleva la touchlist (modificata) dall'evento\n     *\n     * @param  {Touchlist}  touches [description]\n     * @param  {DOMElement} element L'emento esiste solo se è settato STRICT\n     * @return {Array}\n     */\n    getTouches(touches, element, strict){\n        let data = []\n\n        Object.keys(touches).forEach(e => {\n            Utils.validate(touches[e], element, strict) && data.push({\n                clientX: touches[e].clientX,\n                clientY: touches[e].clientY\n            })\n        })\n\n        return data\n    },\n\n    /**\n     * Aggiunge l'oggetto Touch se rispetta la validazone\n     *\n     * @param {Touch}      touch\n     * @param {DOMElement} element\n     */\n    validate(touch, element, strict)\n    {\n        return touch && ( touch.clientX || touch.clientY ) && ( !strict ? element.contains(touch.target) : element == touch.target )\n    },\n\n    /**\n     * Ritorna la differenza delle coordinate tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    coords(ATOstart, ATOend)\n    {\n        return Utils.diff(ATOstart.touches[0], ATOend.touches[0])\n    },\n\n    /**\n     * Ritorna una coordinata basata sulla differenza tra due punti\n     *\n     * @param {ATO.touch} pointA\n     * @param {ATO.touch} pointB\n     */\n    diff(pointA, pointB)\n    {\n        return {\n            x: pointB.clientX - pointA.clientX,\n            y: pointB.clientY - pointA.clientY\n        }\n    },\n\n    /**\n     * Ritorna il numero di touch\n     *\n     * @param {ATO} ATOe\n     */\n    howManyTouches(ATO)\n    {\n        return ATO && ATO.touches ? ATO.touches.length : 0\n    },\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente verticale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isVertical(ATOstart, ATOend)\n    {\n        let coords = Utils.coords(ATOstart, ATOend)\n        return Math.abs(coords.y) > Math.abs(coords.x)\n    },\n\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente orizzontale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isHorizontal(ATOstart, ATOend)\n    {\n        let coords = Utils.coords(ATOstart, ATOend)\n        return Math.abs(coords.x) > Math.abs(coords.y)\n    },\n\n    /**\n     * Ritorna la direzione in base al valore delle coordinate\n     *\n     * @param {Object{x,y} } coords\n     */\n    stringDirection(coords)\n    {\n        return {\n            x: coords.x <= 0 ? 'Left' : 'Right',\n            y: coords.y <= 0 ? 'Top' : 'Bottom'\n        }\n    },\n\n    /* -------------------------------------\n     *  Helper per eventi\n     * ------------------------------------- */\n\n    /**\n     * Ritorna la distanza tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    distanceBetween(ATOstart, ATOend)\n    {\n        console.log('distanceBetween', ATOstart, ATOend);\n        return Utils.distance(ATOend) - Utils.distance(ATOstart)\n    },\n\n    /**\n     * Ritorna la distanza vettoriale tra due coordinata\n     *\n     * @param {ATO} ATO\n     */\n    distance(ATO)\n    {\n        let distance = Utils.diff(ATO.touches[0], ATO.touches[1])\n        return Utils.scalar(distance.x, distance.y)\n    },\n\n    /**\n     * Distanza scalare\n     */\n    scalar(a, b)\n    {\n        return Math.sqrt(Math.pow(a, 2) +  Math.pow(b, 2))\n    },\n\n    /**\n     * Ritorna la direzione tangente tra due coordinate\n     *\n     * @param {ATO} ATO\n     */\n    direction(ATO)\n    {\n        let distance = Utils.diff(ATO.touches[0], ATO.touches[1])\n        return Utils.angle(distance.x, distance.y)\n    },\n\n    /**\n     * Angolo\n     */\n    angle(a, b) \n    {\n        return Math.atan2(b, a) * 180 / Math.PI\n    },\n\n    /**\n     * Ritorna l'angolo di rotazione tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    rotation(ATOstart, ATOend)\n    {\n        return Utils.direction(ATOend) - Utils.direction(ATOstart)\n    }\n}\n\nexport default {\n    create: Utils.create,\n    coords: Utils.coords,\n    howManyTouches: Utils.howManyTouches,\n    isVertical: Utils.isVertical,\n    isHorizontal: Utils.isHorizontal,\n    stringDirection: Utils.stringDirection,\n    distanceBetween: Utils.distanceBetween,\n    direction: Utils.direction,\n    rotation: Utils.rotation,\n    angle: Utils.angle,\n    scalar: Utils.scalar\n}\n\n\n// WEBPACK FOOTER //\n// ./src/services/utils.js","import AloeTouchObject from './AloeTouchObject'\n\n/**\n * AloeTouch\n */\nlet AloeTouch = {\n\n    /**\n     * Contiene il numero di elementi\n     *\n     * @type {Number}\n     */\n    length: 0,\n\n    /**\n     * Lista degli AloeTouchObject\n     *\n     * @type {Object}\n     */\n    list: {},\n\n    /**\n     * Binda un nuovo elemento\n     *\n     * @param {DOMElement} element Elemento da bindare\n     * @param {Object}     events  Eventi da assegnare all'elemento\n     * @param {Boolean}    strict  Se settata, valida l'evento solo se il target del touch è l'elemento bindato\n     */\n    bind(element, events, strict)\n    {\n        let id = ++AloeTouch.length\n\n        return ( AloeTouch.list[id] = {\n                    $id: id,                              // id dell'oggetto\n                 attach: AloeTouch.caller('attach'),      // Binda un evento\n                 detach: AloeTouch.caller('detach'),      // Rimuovo il listener di un evento\n               setState: AloeTouch.caller('setState'),    // Setta uno stato personalizzato\n               getState: AloeTouch.caller('getState'),    // Setta uno stato personalizzato\n            removeState: AloeTouch.caller('removeState'), // Rimuove uno state\n             clearState: AloeTouch.caller('clearState'),  // Azzera la variabile state\n                 isLock: AloeTouch.caller('isLock'),      // Rimuove i listener per tutti gli eventi\n                   lock: AloeTouch.caller('lock'),        // Rimuove i listener per tutti gli eventi\n                 unlock: AloeTouch.caller('unlock'),      // Rebinda i listener per gli eventii\n                   $ref: new AloeTouchObject( id, element, events, strict )  // refrenza all'oggetto\n        } )\n    },\n\n    /**\n     * Chiama una funzione bindando il riferimento dell'oggetto chimante\n     * @param  {String} fn\n     * @return {Function}\n     */\n    caller(fn)\n    {\n        return function(data) {\n            this.$ref && this.$ref[fn](data)\n        }\n    },\n\n    /**\n     * Rimuove i listener ad un elemento\n     *\n     * @param {AloeTouchObject or Numer} aloetouchobject\n     * @return {Boolean} true se l'elemento è stato rimosso, falso altrimenti\n     */\n    unbind(aloetouchobject)\n    {\n        let id = this.getIds(aloetouchobject, true)\n\n        if(id) {\n            AloeTouch.list[id].lock()\n            delete AloeTouch.list[id].$ref\n            delete AloeTouch.list[id]\n            return true\n        }\n\n        return false\n    },\n\n    /**\n     * Ritorna un elemento in base al suo id\n     *\n     * @param {Number} id\n     */\n    get(id)\n    {\n        return AloeTouch.list.hasOwnProperty(id) ? AloeTouch.list[id] : null\n    },\n\n    /**\n     * Ritorna un' array di id\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     * @param {Boolean} flag Ritorna un id se l'array ha lunghezza pari a uno\n     * @return {Array<Number> or Number}\n     */\n    getIds(aloetouchobjects, flag)\n    {\n        aloetouchobjects = aloetouchobjects.constructor.name === 'Array' ? aloetouchobjects : [aloetouchobjects]\n        aloetouchobjects = aloetouchobjects.map( ato => typeof ato === 'number' ? ( AloeTouch.get(ato) ? ato : null ) : ( ato.$ref ? ato.$id : null ) )\n        aloetouchobjects = aloetouchobjects.filter(id => !!id)\n\n        return flag ? ( aloetouchobjects.length == 1 ? aloetouchobjects[0] : aloetouchobjects ) : aloetouchobjects\n    },\n\n    /**\n     * Blocca un oggetto singolo o tutti\n     *\n     * @param {Number?} id Blocca gli eventi per l'oggetto con id 'id'\n     */\n    lock(id)\n    {\n        id ? AloeTouch.list[id].lock() : AloeTouch.map(ato => ato.lock())\n    },\n\n    /**\n     *  Blocca tutti gli oggetti tranne quelli presenti nell'array aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    lockExcept(aloetouchobjects)\n    {\n        ids = this.getIds(ids) || []\n\n        AloeTouch.map((ato, id) => ato[ids.indexOf(id) == -1 ? 'unlock' : 'lock']())\n    },\n\n    /**\n     * Blocca solo gli oggetti presenti in aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    lockOnly(aloetouchobjects)\n    {\n        ids = this.getIds(ids) || []\n\n        AloeTouch.map((ato, id) => ato[ids.indexOf(id) >= 0 ? 'lock' : 'unlock']())\n    },\n\n    /**\n     * Abilita li eventi ad un oggetto singolo o tutti\n     *\n     * @param {Number?} id\n     */\n    unlock(id)\n    {\n        id ? AloeTouch.list[id].unlock() : AloeTouch.map(ato => ato.unlock())\n    },\n\n    /**\n     * Abilita gli eventi tranne agli elementi presenti nell'array aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    unlockExcept(aloetouchobjects)\n    {\n        AloeTouch.lockOnly(aloetouchobjects)\n    },\n\n    /**\n     * Abilita gli eventi solo agli elementi presenti nell'array aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    unlockOnly(aloetouchobjects)\n    {\n        AloeTouch.lockExcept(aloetouchobjects)\n    },\n\n    /**\n     * Mappa tutti li elementi bindati\n     *\n     * @param {Callable(AloeTouchObject, id)}\n     */\n    map(callable) {\n        Object.keys(AloeTouch.list).forEach(id => callable(AloeTouch.list[id], id))\n    }\n\n}\n\nexport default AloeTouch\n\n\n// WEBPACK FOOTER //\n// ./src/AloeTouch.js"],"sourceRoot":""}