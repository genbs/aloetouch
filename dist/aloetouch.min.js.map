{"version":3,"sources":["webpack:///dist/aloetouch.min.js","webpack:///webpack/bootstrap 3d1ed798d92805455109","webpack:///./src/AloeTouch.js","webpack:///./src/AloeTouchObject.js","webpack:///./src/services/state.js","webpack:///./src/services/utils.js","webpack:///./index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireDefault","obj","default","_AloeTouchObject","_AloeTouchObject2","AloeTouch","length","list","bind","element","events","strict","id","$id","attach","caller","detach","setState","getState","removeState","clearState","isLock","lock","unlock","$ref","fn","data","this","unbind","aloetouchobject","getIds","aloetouchobjects","flag","constructor","map","ato","filter","lockExcept","ids","indexOf","lockOnly","unlockExcept","unlockOnly","callable","keys","forEach","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","_utils","_utils2","_state","_state2","ALOETOUCH_MIN_TIME","ALOETOUCH_PRESS_MIN_TIME","ALOETOUCH_MIN_SWIPE_DISTANCE","AloeTouchObject","el","document","querySelector","strictMode","state","locked","utils","__start","start","__move","move","__finish","finish","clear","event","started","create","updated","mooving","pressEmitted","window","setTimeout","press","emit","_this","prepareMove","ended","isPermissible","preventDefault","stopPropagation","dispatch","callback","time","isHorizontal","fingers","howManyTouches","pan","pinch","rotate","assign","coords","distanceBetween","rotation","setStateAndEmit","stateValue","eventValues","set","pan2","swipe","tap","refresh","clearTimeout","off","on","_this2","Date","now","Math","abs","x","stringDirection","y","directions","distance","_this3","e","_this4","handler","passive","_this5","split","addEventListener","_this6","removeEventListener","_typeof","Symbol","iterator","State","new","old","customState","cs","copyState","k","Utils","oldATO","ATO","touches","getTouches","validate","push","clientX","clientY","touch","ATOstart","ATOend","diff","pointA","pointB","isVertical","scalar","a","b","nosqrt","pow","sqrt","direction","angle","atan2","PI","_AloeTouch","_AloeTouch2"],"mappings":"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","file":"./dist/aloetouch.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AloeTouchObject = __webpack_require__(1);\n\nvar _AloeTouchObject2 = _interopRequireDefault(_AloeTouchObject);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * AloeTouch\n */\nvar AloeTouch = {\n\n  /**\n   * Contiene il numero di elementi\n   *\n   * @type {Number}\n   */\n  length: 0,\n\n  /**\n   * Lista degli AloeTouchObject\n   *\n   * @type {Object}\n   */\n  list: {},\n\n  /**\n   * Binda un nuovo elemento\n   *\n   * @param {DOMElement} element Elemento da bindare\n   * @param {Object}     events  Eventi da assegnare all'elemento\n   * @param {Boolean}    strict  Se settata, valida l'evento solo se il target del touch è l'elemento bindato\n   */\n  bind: function bind(element, events, strict) {\n    var id = ++AloeTouch.length;\n\n    return AloeTouch.list[id] = {\n      $id: id, // id dell'oggetto\n      attach: AloeTouch.caller('attach'), // Binda un evento\n      detach: AloeTouch.caller('detach'), // Rimuovo il listener di un evento\n      setState: AloeTouch.caller('setState'), // Setta uno stato personalizzato\n      getState: AloeTouch.caller('getState'), // Setta uno stato personalizzato\n      removeState: AloeTouch.caller('removeState'), // Rimuove uno state\n      clearState: AloeTouch.caller('clearState'), // Azzera la variabile state\n      isLock: AloeTouch.caller('isLock'), // Rimuove i listener per tutti gli eventi\n      lock: AloeTouch.caller('lock'), // Rimuove i listener per tutti gli eventi\n      unlock: AloeTouch.caller('unlock'), // Rebinda i listener per gli eventii\n      $ref: new _AloeTouchObject2.default(id, element, events, strict) // refrenza all'oggetto\n    };\n  },\n\n\n  /**\n   * Chiama una funzione bindando il riferimento dell'oggetto chimante\n   * @param  {String} fn\n   * @return {Function}\n   */\n  caller: function caller(fn) {\n    return function (data) {\n      this.$ref && this.$ref[fn](data);\n    };\n  },\n\n\n  /**\n   * Rimuove i listener ad un elemento\n   *\n   * @param {AloeTouchObject or Numer} aloetouchobject\n   * @return {Boolean} true se l'elemento è stato rimosso, falso altrimenti\n   */\n  unbind: function unbind(aloetouchobject) {\n    var id = void 0;\n\n    if (!(id = this.getIds(aloetouchobject, true))) return false;\n\n    AloeTouch.list[id].lock();\n    AloeTouch.list[id].$ref = null;\n    delete AloeTouch.list[id];\n\n    return true;\n  },\n\n\n  /**\n   * Ritorna un elemento in base al suo id\n   *\n   * @param {Number} id\n   */\n  get: function get(id) {\n    return AloeTouch.list.hasOwnProperty(id) ? AloeTouch.list[id] : null;\n  },\n\n\n  /**\n   * Ritorna un' array di id\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   * @param {Boolean} flag Ritorna un id se l'array ha lunghezza pari a uno\n   * @return {Array<Number> or Number}\n   */\n  getIds: function getIds(aloetouchobjects, flag) {\n    aloetouchobjects = aloetouchobjects.constructor.name === 'Array' ? aloetouchobjects : [aloetouchobjects];\n\n    aloetouchobjects.map(function (ato) {\n      return typeof ato === 'number' ? AloeTouch.get(ato) ? ato : null : aloetouchobject.$ref ? aloetouchobject.$id : null;\n    });\n    aloetouchobjects = aloetouchobjects.filter(function (id) {\n      return !!id;\n    });\n\n    return flag ? aloetouchobjects.length == 1 ? aloetouchobjects[0] : aloetouchobjects : aloetouchobjects;\n  },\n\n\n  /**\n   * Blocca un oggetto singolo o tutti\n   *\n   * @param {Number?} id Blocca gli eventi per l'oggetto con id 'id'\n   */\n  lock: function lock(id) {\n    id && AloeTouch.list[id].lock() || !id && AloeTouch.map(function (ato) {\n      return ato.lock();\n    });\n  },\n\n\n  /**\n   *  Blocca tutti gli oggetti tranne quelli presenti nell'array aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  lockExcept: function lockExcept(aloetouchobjects) {\n    ids = this.getIds(ids) || [];\n\n    AloeTouch.map(function (ato, id) {\n      return ato[ids.indexOf(id) == -1 ? 'unlock' : 'lock']();\n    });\n  },\n\n\n  /**\n   * Blocca solo gli oggetti presenti in aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  lockOnly: function lockOnly(aloetouchobjects) {\n    ids = this.getIds(ids) || [];\n\n    AloeTouch.map(function (ato, id) {\n      return ato[ids.indexOf(id) >= 0 ? 'lock' : 'unlock']();\n    });\n  },\n\n\n  /**\n   * Abilita li eventi ad un oggetto singolo o tutti\n   *\n   * @param {Number?} id\n   */\n  unlock: function unlock(id) {\n    id && AloeTouch.list[id].unlock() || !id && AloeTouch.map(function (ato) {\n      return ato.unlock();\n    });\n  },\n\n\n  /**\n   * Abilita gli eventi tranne agli elementi presenti nell'array aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  unlockExcept: function unlockExcept(aloetouchobjects) {\n    AloeTouch.lockOnly(aloetouchobjects);\n  },\n\n\n  /**\n   * Abilita gli eventi solo agli elementi presenti nell'array aloetouchobjects\n   *\n   * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n   */\n  unlockOnly: function unlockOnly(aloetouchobjects) {\n    AloeTouch.lockExcept(aloetouchobjects);\n  },\n\n\n  /**\n   * Mappa tutti li elementi bindati\n   *\n   * @param {Callable(AloeTouchObject, id)}\n   */\n  map: function map(callable) {\n    Object.keys(AloeTouch.list).forEach(function (id) {\n      return callable(AloeTouch.list[id], id);\n    });\n  }\n};\n\nexports.default = AloeTouch;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(3);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _state = __webpack_require__(2);\n\nvar _state2 = _interopRequireDefault(_state);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * La durata minimina per bindare un evento\n * Utile a non prevenire lo scrolling\n * @type {Number}\n */\nvar ALOETOUCH_MIN_TIME = 85;\n\n/**\n * Tempo minimo per bindare l'evento press\n * @type {Number}\n */\nvar ALOETOUCH_PRESS_MIN_TIME = 600;\n\n/**\n * Distanza minima per bindare l'evento swipe[Direction]\n * @type {Number}\n */\nvar ALOETOUCH_MIN_SWIPE_DISTANCE = 20;\n\n/**\n * Assegna gli eventi touch ad un elemento\n *\n * GLi eventi disponibili sono:\n * Touch singolo\n *     tap, press, pan, swipeLeft, swipeRight, swipeTop, swipeBottom\n * Touch doppio\n *     pinch, rotate\n */\n\nvar AloeTouchObject = function () {\n\n    /**\n     * Binda gli eventi all'elemento\n     * @param {DomElement} element\n     * @param {Object} events Oggetto che contiene le funzioni es. { tap: ..., swipeLeft: ..., rotate: ... }\n     * @param {Boolean} strict Aggiunge le coordinate del tuoch solo se il target è uguale all'elemento bindato\n     */\n    function AloeTouchObject(id, element, events, strict) {\n        _classCallCheck(this, AloeTouchObject);\n\n        this.id = id;\n        this.el = typeof element === 'string' ? document.querySelector(element) : element;\n        this.events = events || {};\n        this.strictMode = strict || false;\n        this.events.state = this.events.state || {};\n        this.locked = true;\n\n        // Services\n        this.utils = _utils2.default;\n        this.state = _state2.default;\n\n        this.__start = this.start.bind(this);\n        this.__move = this.move.bind(this);\n        this.__finish = this.finish.bind(this);\n\n        this.clear();\n        this.clearState();\n        this.unlock();\n    }\n\n    /**\n     * Eventi 'touchstart' 'mousedown'\n     */\n\n\n    _createClass(AloeTouchObject, [{\n        key: 'start',\n        value: function start(event) {\n            if (!this.locked) {\n                this.started = this.utils.create(event, this.strictMode ? this.el : null, this.started);\n\n                this.started.updated && (this.mooving = true);\n\n                // Binderà l'evento press solo se non sarà invocato nè l'evento move, nè finish\n                !this.started.updated && (this.pressEmitted = window.setTimeout(this.press.bind(this), ALOETOUCH_PRESS_MIN_TIME));\n\n                this.emit('start');\n            }\n        }\n\n        /**\n         * Eventi 'touchmove'\n         */\n\n    }, {\n        key: 'move',\n        value: function move(event) {\n            var _this = this;\n\n            // Controllo se sono settate le coordinate del touch all'evento start e bindo le nuove coordinate (ended)\n            !this.locked && this.prepareMove(event, function (ended) {\n                if (_this.isPermissible()) {\n                    event.preventDefault();\n                    event.stopPropagation();\n\n                    _this.mooving = true;\n                    _this.dispatch(); // Smisto gli eventi 'mobili': pan, rotate, pitch\n                } else {\n                    _this.mooving = false; // L'evento non può più essere prevenuto\n                }\n            });\n        }\n\n        /**\n         * Eseguo la funczione moove solo se sono settate le coordinate iniziali\n         */\n\n    }, {\n        key: 'prepareMove',\n        value: function prepareMove(event, callback) {\n            this.started && callback.call(this, this.ended = this.utils.create(event, this.el));\n            !this.started && this.clear();\n        }\n\n        /**\n         * Questa funzionalitò è molto importante poiché previene che l'evento 'touchmove'\n         * prevenga l'azione di default dell'evento (e quindi blocchi lo scrolling)\n         */\n\n    }, {\n        key: 'isPermissible',\n        value: function isPermissible() {\n            var time = this.ended.time - this.started.time;\n            var isHorizontal = this.utils.isHorizontal(this.started, this.ended); // Se lo scrolling è orizzontale implica che l'utente non sta scorrendo\n            // verticalmente la pagina, quindi è possibile bloccare lo scrolling\n            return this.mooving || this.mooving === null // Il caso in cui questa variabile risulta === null avviene solo la priva volta che viene invocata la fuonzione move,\n            && (isHorizontal || time > ALOETOUCH_MIN_TIME) // infatti viene nullata con la funzione clear presente nel metodo start. Questa cndizione è necessaria perché il metodo\n            ; // preventDefault() di Event non può essere invocato in un secondo stadio dell'evento 'touchmove', ma solo la prima volta\n        }\n\n        /**\n         * Smisto gli eventi in 'touchmove' in base al numero di tocchi\n         */\n\n    }, {\n        key: 'dispatch',\n        value: function dispatch() {\n            var fingers = this.utils.howManyTouches(this.ended),\n                pan = null,\n                pinch = null,\n                rotate = null;\n\n            if (fingers == 1) {\n                pan = Object.assign({}, this.utils.coords(this.started, this.ended), { fingers: 1 });\n            } else if (fingers == 2) {\n                pan = Object.assign({}, this.utils.coords(this.started, this.ended), { fingers: 2 }), pinch = this.utils.distanceBetween(this.started, this.ended), rotate = this.utils.rotation(this.started, this.ended);\n            }\n\n            this.setStateAndEmit({ pan: pan, pinch: pinch, rotate: rotate, fingers: fingers });\n            this.emit('move', this.stateValue);\n        }\n\n        /**\n         * Setta i valore dello state ed emette gli eventi\n         *\n         * @param {Object} eventValues Valori da emettere\n         */\n\n    }, {\n        key: 'setStateAndEmit',\n        value: function setStateAndEmit(eventValues, fingers) {\n            this.stateValue = this.state.set(this.stateValue, eventValues, this.events.state);\n\n            fingers == 1 && eventValues.pan && this.pan(eventValues.pan);\n            fingers == 2 && eventValues.pan && this.pan2(eventValues.pan);\n            eventValues.pinch && this.pinch(eventValues.pinch);\n            eventValues.rotate && this.rotate(eventValues.rotate);\n        }\n\n        /**\n         * Termino l'evento\n         */\n\n    }, {\n        key: 'finish',\n        value: function finish(event) {\n            if (!this.locked && this.started) // Controllo che vale anche per l'evento touchmove\n                {\n                    this.mooving && this.swipe();\n                    this.mooving === null && this.tap();\n\n                    this.stateValue = this.state.refresh(this.stateValue, this.events.state); // aggiorno lo state\n\n                    this.emit('end');\n                }\n\n            this.clear();\n        }\n\n        /**\n         * Reset delle variabili\n         */\n\n    }, {\n        key: 'clear',\n        value: function clear() {\n            this.pressEmitted && window.clearTimeout(this.pressEmitted); // Cancello l'evento press\n\n            this.started = null;\n            this.ended = null;\n            this.mooving = null;\n            this.pressEmitted = null;\n        }\n\n        /* -------------------------------------\n         *  Eventi\n         * ------------------------------------- */\n\n        /**\n         * Ritorna vero se questo oggetto è bloccato, falso altrimenti\n         *\n         * @return {Boolean}\n         */\n\n    }, {\n        key: 'isLock',\n        value: function isLock() {\n            return this.locked;\n        }\n\n        /**\n         * Rimuove i listener degli eventi\n         */\n\n    }, {\n        key: 'lock',\n        value: function lock() {\n            if (!this.locked) {\n                this.off('touchstart', this.__start, true);\n                this.off('touchmove', this.__move);\n                this.off('touchend touchcancel', this.__finish, true);\n                this.locked = true;\n            }\n        }\n\n        /**\n         * Binda gli eventi\n         */\n\n    }, {\n        key: 'unlock',\n        value: function unlock() {\n            if (this.locked) {\n                this.on('touchstart', this.__start, true);\n                this.on('touchmove', this.__move);\n                this.on('touchend touchcancel', this.__finish, true);\n                this.locked = false;\n            }\n        }\n\n        /* -------------------------------------\n         *  State\n         * ------------------------------------- */\n\n        /**\n         * Setta uno state\n         *\n         * @param {Object} state\n         */\n\n    }, {\n        key: 'setState',\n        value: function setState(state) {\n            var _this2 = this;\n\n            Object.keys(state).forEach(function (s) {\n                return _this2.events.state[s] = state[s];\n            });\n        }\n\n        /**\n         * Ritorna i valori dello state corrente\n         */\n\n    }, {\n        key: 'getState',\n        value: function getState() {\n            return this.stateValue;\n        }\n\n        /**\n         * Rimuove uno state\n         *\n         * @param {String} name Nome dello state da rimuovere\n         */\n\n    }, {\n        key: 'removeState',\n        value: function removeState(name) {\n            this.state[name] = null;\n            this.stateValue[name] = null;\n            delete this.state[name];\n            delete this.stateValue[name];\n        }\n\n        /**\n         * Cancella lo state con ivalori correnti\n         */\n\n    }, {\n        key: 'clearState',\n        value: function clearState() {\n            this.stateValue = this.state.create();\n        }\n\n        /* -------------------------------------\n         *  Eventi\n         * ------------------------------------- */\n\n        /**\n         * Valido l'evento tap\n         */\n\n    }, {\n        key: 'tap',\n        value: function tap() {\n            var fingers = this.utils.howManyTouches(this.ended);\n            var time = Date.now() - this.started.time;\n            if (fingers < 2 && time < ALOETOUCH_PRESS_MIN_TIME) this.emit('tap');\n        }\n\n        /**\n         * Evento press\n         */\n\n    }, {\n        key: 'press',\n        value: function press() {\n            if (this.pressEmitted && !this.mooving) {\n                this.emit('press', null);\n                this.pressEmitted = null;\n            }\n        }\n\n        /**\n         * Valido l'evento swipe\n         */\n\n    }, {\n        key: 'swipe',\n        value: function swipe() {\n            var coords = this.utils.coords(this.started, this.ended);\n\n            if (Math.abs(coords.x) > ALOETOUCH_MIN_SWIPE_DISTANCE) {\n                var stringDirection = this.utils.stringDirection(coords);\n\n                this.emit('swipe' + stringDirection.x, coords);\n                this.emit('swipe' + stringDirection.y, coords);\n                this.emit('swipe', { directions: stringDirection, coords: coords });\n            }\n        }\n\n        /**\n         * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n          * @param {Object} coords\n         */\n\n    }, {\n        key: 'pan',\n        value: function pan(coords) {\n            this.emit('pan', coords);\n        }\n\n        /**\n         * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n          * @param {Object} coords\n         */\n\n    }, {\n        key: 'pan2',\n        value: function pan2(coords) {\n            this.emit('pan2', coords);\n        }\n\n        /**\n         * L'evento pinch non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n         *\n         * @param {Number} distance\n         */\n\n    }, {\n        key: 'pinch',\n        value: function pinch(distance) {\n            this.emit('pinch', distance);\n        }\n\n        /**\n         * L'evento rotate non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n         *\n         * @param {Number} rotation\n         */\n\n    }, {\n        key: 'rotate',\n        value: function rotate(rotation) {\n            this.emit('rotate', rotation);\n        }\n\n        /* -------------------------------------\n         *  Bindaggio ed emissione eventi\n         * ------------------------------------- */\n\n        /**\n         * Emette un evento se settato\n         *\n         * @param {String} event Nome dell'evento da emettere\n         * @param {Object} data Dati da passare alla funzione settata per l'evento\n         */\n\n    }, {\n        key: 'emit',\n        value: function emit(event, data) {\n            if (this.events[event]) {\n                var result = this.events[event](data ? data : this.stateValue, data ? this.stateValue : null);\n\n                // Prevengo la gestione degli altri eventi se - nella funzione settata dall'utente - viene restituito il booleano false\n                return result === false && this.clear();\n            }\n        }\n\n        /**\n         * Aggiunge un evento\n         */\n\n    }, {\n        key: 'attach',\n        value: function attach(events) {\n            var _this3 = this;\n\n            Object.keys(events).forEach(function (e) {\n                return _this3.events[e] = events[e];\n            });\n        }\n        /**\n         * Rimuove un evento\n         */\n\n    }, {\n        key: 'detach',\n        value: function detach(events) {\n            var _this4 = this;\n\n            events = events.constructor.name === 'Array' ? events : [events];\n            events.forEach(function (e) {\n                return _this4.events[e] && delete _this4.events[e];\n            });\n        }\n\n        /**\n         * Bindo gli eventi all'elemento\n         */\n\n    }, {\n        key: 'on',\n        value: function on(events, handler, passive) {\n            var _this5 = this;\n\n            events.split(' ').forEach(function (e) {\n                return _this5.el.addEventListener(e, handler, passive ? { passive: true } : false);\n            });\n        }\n\n        /**\n         * Rimuovo i listeners\n         */\n\n    }, {\n        key: 'off',\n        value: function off(events, handler, passive) {\n            var _this6 = this;\n\n            events.split(' ').forEach(function (e) {\n                return _this6.el.removeEventListener(e, handler, passive ? { passive: true } : false);\n            });\n        }\n    }]);\n\n    return AloeTouchObject;\n}();\n\nexports.default = AloeTouchObject;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar State = {\n\n    /**\n     * Crea un oggetto vuoto per il contenimento dei valori degli eventi pan, pinch e rotate\n     */\n    new: function _new() {\n        return {\n            pan: { x: null, y: null },\n            pinch: null,\n            rotate: null,\n            fingers: null\n        };\n    },\n\n\n    /**\n     * Crea un nuovo oggetto che conterra i valori precedenti degli eventi\n     */\n    create: function create() {\n        return Object.assign({}, State.new(), { old: State.new() });\n    },\n\n\n    /**\n     * Binda i nuovi valori dall'evento corrente (chiamato da touchmove->dispatch->emit) con i valori precendenti\n     *\n     * @param {ATS} state\n     * @param {ATEvent} event\n     */\n    set: function set(state, event, customState) {\n        event.fingers && (state.fingers = event.fingers);\n        event.rotate && (state.rotate = event.rotate + state.old.rotate);\n        event.pinch && (state.pinch = event.pinch + state.old.pinch);\n        event.pan && event.pan.x && (state.pan.x = event.pan.x + state.old.pan.x);\n        event.pan && event.pan.y && (state.pan.y = event.pan.y + state.old.pan.y);\n\n        // Aggiungo gli state settati dall'utente\n        Object.keys(customState).forEach(function (cs) {\n            return state[cs] = customState[cs](state);\n        });\n\n        return state;\n    },\n\n\n    /**\n     * All'evento touchend setto i valori precendeti con l'ultimo settato\n     *\n     * @param {ATS} state\n     */\n    refresh: function refresh(state) {\n        state.old = State.copyState(state);\n\n        return state;\n    },\n\n\n    /**\n     * Copio l'oggetto state\n     */\n    copyState: function copyState(state) {\n        var n = {};\n        Object.keys(state).forEach(function (k) {\n            k != 'old' && (n[k] = _typeof(state[k]) === 'object' && state[k] !== null ? State.copyState(state[k]) : state[k]);\n        });\n        return n;\n    }\n};\n\nexports.default = {\n    set: State.set,\n    create: State.create,\n    refresh: State.refresh\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar Utils = {\n    /**\n     * Crea (o modifico) l'oggetto ATO (AloeTouchObject) contenente la Touchlist\n     *\n     * @param  {Event}      event\n     * @param  {DOMElement} element\n     * @param  {ATO?}       oldATO\n     */\n    create: function create(event, element, oldATO) {\n        var ATO = oldATO ? Object.assign({}, oldATO, { updated: true }) : { time: Date.now() };\n\n        ATO.touches = Utils.getTouches(event.touches ? event.touches : [event], element);\n\n        return ATO;\n    },\n\n\n    /**\n     * Preleva la touchlist (modificata) dall'evento\n     *\n     * @param  {Touchlist}  touches [description]\n     * @param  {DOMElement} element L'emento esiste solo se è settato STRICT\n     * @return {Array}\n     */\n    getTouches: function getTouches(touches, element) {\n        var data = [];\n\n        Object.keys(touches).forEach(function (e) {\n            Utils.validate(touches[e], element) && data.push({\n                clientX: touches[e].clientX,\n                clientY: touches[e].clientY\n            });\n        });\n\n        return data;\n    },\n\n\n    /**\n     * Aggiunge l'oggetto Touch se rispetta la validazone\n     *\n     * @param {Touch}      touch\n     * @param {DOMElement} element\n     */\n    validate: function validate(touch, element) {\n        return touch && (touch.clientX || touch.clientY) && (!element || element == touch.target);\n    },\n\n\n    /**\n     * Ritorna la differenza delle coordinate tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    coords: function coords(ATOstart, ATOend) {\n        return Utils.diff(ATOstart.touches[0], ATOend.touches[0]);\n    },\n\n\n    /**\n     * Ritorna una coordinata basata sulla differenza tra due punti\n     *\n     * @param {ATO.touch} pointA\n     * @param {ATO.touch} pointB\n     */\n    diff: function diff(pointA, pointB) {\n        return {\n            x: pointB.clientX - pointA.clientX,\n            y: pointB.clientY - pointA.clientY\n        };\n    },\n\n\n    /**\n     * Ritorna il numero di touch\n     *\n     * @param {ATO} ATOe\n     */\n    howManyTouches: function howManyTouches(ATO) {\n        return ATO && ATO.touches ? ATO.touches.length : 0;\n    },\n\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente verticale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isVertical: function isVertical(ATOstart, ATOend) {\n        var coords = Utils.coords(ATOstart, ATOend);\n        return Math.abs(coords.y) > Math.abs(coords.x);\n    },\n\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente orizzontale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isHorizontal: function isHorizontal(ATOstart, ATOend) {\n        var coords = Utils.coords(ATOstart, ATOend);\n        return Math.abs(coords.x) > Math.abs(coords.y);\n    },\n\n\n    /**\n     * Ritorna la direzione in base al valore delle coordinate\n     *\n     * @param {Object{x,y} } coords\n     */\n    stringDirection: function stringDirection(coords) {\n        return {\n            x: coords.x <= 0 ? 'Left' : 'Right',\n            y: coords.y <= 0 ? 'Top' : 'Bottom'\n        };\n    },\n\n\n    /* -------------------------------------\n     *  Helper per eventi\n     * ------------------------------------- */\n\n    /**\n     * Ritorna la distanza tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    distanceBetween: function distanceBetween(ATOstart, ATOend) {\n        return Utils.distance(ATOend) - Utils.distance(ATOstart);\n    },\n\n\n    /**\n     * Ritorna la distanza vettoriale tra due coordinata\n     *\n     * @param {ATO} ATO\n     */\n    distance: function distance(ATO) {\n        var distance = Utils.diff(ATO.touches[0], ATO.touches[1]);\n        return Utils.scalar(distance.x, distance.y);\n    },\n\n\n    /**\n     * Distanza scalare\n     */\n    scalar: function scalar(a, b, nosqrt) {\n        var s = Math.pow(a, 2) + Math.pow(b, 2);\n        return nosqrt === false ? s : Math.sqrt(s);\n    },\n\n\n    /**\n     * Ritorna la direzione tangente tra due coordinate\n     *\n     * @param {ATO} ATO\n     */\n    direction: function direction(ATO) {\n        var distance = Utils.diff(ATO.touches[0], ATO.touches[1]);\n        return Utils.angle(distance.x, distance.y);\n    },\n\n\n    /**\n     * Angolo\n     */\n    angle: function angle(a, b) {\n        return Math.atan2(b, a) * 180 / Math.PI;\n    },\n\n\n    /**\n     * Ritorna l'angolo di rotazione tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    rotation: function rotation(ATOstart, ATOend) {\n        return Utils.direction(ATOend) - Utils.direction(ATOstart);\n    }\n};\n\nexports.default = {\n    create: Utils.create,\n    coords: Utils.coords,\n    howManyTouches: Utils.howManyTouches,\n    isVertical: Utils.isVertical,\n    isHorizontal: Utils.isHorizontal,\n    stringDirection: Utils.stringDirection,\n    distanceBetween: Utils.distanceBetween,\n    direction: Utils.direction,\n    rotation: Utils.rotation,\n    angle: Utils.angle,\n    scalar: Utils.scalar\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _AloeTouch = __webpack_require__(0);\n\nvar _AloeTouch2 = _interopRequireDefault(_AloeTouch);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.AloeTouch = _AloeTouch2.default;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dist/aloetouch.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3d1ed798d92805455109","import AloeTouchObject from './AloeTouchObject'\n\n/**\n * AloeTouch\n */\nlet AloeTouch = {\n\n    /**\n     * Contiene il numero di elementi\n     *\n     * @type {Number}\n     */\n    length: 0,\n\n    /**\n     * Lista degli AloeTouchObject\n     *\n     * @type {Object}\n     */\n    list: {},\n\n    /**\n     * Binda un nuovo elemento\n     *\n     * @param {DOMElement} element Elemento da bindare\n     * @param {Object}     events  Eventi da assegnare all'elemento\n     * @param {Boolean}    strict  Se settata, valida l'evento solo se il target del touch è l'elemento bindato\n     */\n    bind(element, events, strict)\n    {\n        let id = ++AloeTouch.length\n\n        return ( AloeTouch.list[id] = {\n                    $id: id,                              // id dell'oggetto\n                 attach: AloeTouch.caller('attach'),      // Binda un evento\n                 detach: AloeTouch.caller('detach'),      // Rimuovo il listener di un evento\n               setState: AloeTouch.caller('setState'),    // Setta uno stato personalizzato\n               getState: AloeTouch.caller('getState'),    // Setta uno stato personalizzato\n            removeState: AloeTouch.caller('removeState'), // Rimuove uno state\n             clearState: AloeTouch.caller('clearState'),  // Azzera la variabile state\n                 isLock: AloeTouch.caller('isLock'),      // Rimuove i listener per tutti gli eventi\n                   lock: AloeTouch.caller('lock'),        // Rimuove i listener per tutti gli eventi\n                 unlock: AloeTouch.caller('unlock'),      // Rebinda i listener per gli eventii\n                   $ref: new AloeTouchObject( id, element, events, strict )  // refrenza all'oggetto\n        } )\n    },\n\n    /**\n     * Chiama una funzione bindando il riferimento dell'oggetto chimante\n     * @param  {String} fn\n     * @return {Function}\n     */\n    caller(fn)\n    {\n        return function(data) {\n            this.$ref && this.$ref[fn](data)\n        }\n    },\n\n    /**\n     * Rimuove i listener ad un elemento\n     *\n     * @param {AloeTouchObject or Numer} aloetouchobject\n     * @return {Boolean} true se l'elemento è stato rimosso, falso altrimenti\n     */\n    unbind(aloetouchobject)\n    {\n        let id\n\n        if(! (id = this.getIds(aloetouchobject, true)))\n            return false\n\n        AloeTouch.list[id].lock()\n        AloeTouch.list[id].$ref = null\n        delete AloeTouch.list[id]\n\n        return true\n    },\n\n    /**\n     * Ritorna un elemento in base al suo id\n     *\n     * @param {Number} id\n     */\n    get(id)\n    {\n        return AloeTouch.list.hasOwnProperty(id) ? AloeTouch.list[id] : null\n    },\n\n    /**\n     * Ritorna un' array di id\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     * @param {Boolean} flag Ritorna un id se l'array ha lunghezza pari a uno\n     * @return {Array<Number> or Number}\n     */\n    getIds(aloetouchobjects, flag)\n    {\n        aloetouchobjects = aloetouchobjects.constructor.name === 'Array' ? aloetouchobjects : [aloetouchobjects]\n\n        aloetouchobjects.map( ato => typeof ato === 'number' ? ( AloeTouch.get(ato) ? ato : null ) : ( aloetouchobject.$ref ? aloetouchobject.$id : null ) )\n        aloetouchobjects = aloetouchobjects.filter(id => !!id)\n\n        return flag ? ( aloetouchobjects.length == 1 ? aloetouchobjects[0] : aloetouchobjects ) : aloetouchobjects\n    },\n\n    /**\n     * Blocca un oggetto singolo o tutti\n     *\n     * @param {Number?} id Blocca gli eventi per l'oggetto con id 'id'\n     */\n    lock(id)\n    {\n        ( id && AloeTouch.list[id].lock() ) || ( !id && AloeTouch.map(ato => ato.lock()) )\n    },\n\n    /**\n     *  Blocca tutti gli oggetti tranne quelli presenti nell'array aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    lockExcept(aloetouchobjects)\n    {\n        ids = this.getIds(ids) || []\n\n        AloeTouch.map((ato, id) => ato[ids.indexOf(id) == -1 ? 'unlock' : 'lock']())\n    },\n\n    /**\n     * Blocca solo gli oggetti presenti in aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    lockOnly(aloetouchobjects)\n    {\n        ids = this.getIds(ids) || []\n\n        AloeTouch.map((ato, id) => ato[ids.indexOf(id) >= 0 ? 'lock' : 'unlock']())\n    },\n\n    /**\n     * Abilita li eventi ad un oggetto singolo o tutti\n     *\n     * @param {Number?} id\n     */\n    unlock(id)\n    {\n        ( id && AloeTouch.list[id].unlock() ) || ( !id && AloeTouch.map(ato => ato.unlock()) )\n    },\n\n    /**\n     * Abilita gli eventi tranne agli elementi presenti nell'array aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    unlockExcept(aloetouchobjects)\n    {\n        AloeTouch.lockOnly(aloetouchobjects)\n    },\n\n    /**\n     * Abilita gli eventi solo agli elementi presenti nell'array aloetouchobjects\n     *\n     * @param {Array<AloeTouchObject or Number>} aloetouchobjects\n     */\n    unlockOnly(aloetouchobjects)\n    {\n        AloeTouch.lockExcept(aloetouchobjects)\n    },\n\n    /**\n     * Mappa tutti li elementi bindati\n     *\n     * @param {Callable(AloeTouchObject, id)}\n     */\n    map(callable){\n        Object.keys(AloeTouch.list).forEach(id => callable(AloeTouch.list[id], id))\n    }\n\n}\n\nexport default AloeTouch\n\n\n// WEBPACK FOOTER //\n// ./src/AloeTouch.js","import Utils from './services/utils'\nimport State from './services/state'\n\n/**\n * La durata minimina per bindare un evento\n * Utile a non prevenire lo scrolling\n * @type {Number}\n */\nconst ALOETOUCH_MIN_TIME = 85\n\n/**\n * Tempo minimo per bindare l'evento press\n * @type {Number}\n */\nconst ALOETOUCH_PRESS_MIN_TIME = 600\n\n/**\n * Distanza minima per bindare l'evento swipe[Direction]\n * @type {Number}\n */\nconst ALOETOUCH_MIN_SWIPE_DISTANCE = 20\n\n/**\n * Assegna gli eventi touch ad un elemento\n *\n * GLi eventi disponibili sono:\n * Touch singolo\n *     tap, press, pan, swipeLeft, swipeRight, swipeTop, swipeBottom\n * Touch doppio\n *     pinch, rotate\n */\nexport default class AloeTouchObject {\n\n    /**\n     * Binda gli eventi all'elemento\n     * @param {DomElement} element\n     * @param {Object} events Oggetto che contiene le funzioni es. { tap: ..., swipeLeft: ..., rotate: ... }\n     * @param {Boolean} strict Aggiunge le coordinate del tuoch solo se il target è uguale all'elemento bindato\n     */\n    constructor(id, element, events, strict)\n    {\n        this.id = id\n        this.el = typeof element === 'string' ? document.querySelector(element) : element\n        this.events = events || {}\n        this.strictMode = strict || false\n        this.events.state = this.events.state || {}\n        this.locked = true\n\n        // Services\n        this.utils = Utils\n        this.state = State\n\n        this.__start = this.start.bind(this)\n        this.__move = this.move.bind(this)\n        this.__finish = this.finish.bind(this)\n\n        this.clear()\n        this.clearState()\n        this.unlock()\n    }\n\n\n    /**\n     * Eventi 'touchstart' 'mousedown'\n     */\n    start(event)\n    {\n        if(!this.locked) {\n            this.started = this.utils.create(event, this.strictMode ? this.el : null, this.started)\n\n            this.started.updated && ( this.mooving = true )\n\n            // Binderà l'evento press solo se non sarà invocato nè l'evento move, nè finish\n            !this.started.updated && ( this.pressEmitted = window.setTimeout(this.press.bind(this), ALOETOUCH_PRESS_MIN_TIME) )\n\n            this.emit('start')\n        }\n    }\n\n    /**\n     * Eventi 'touchmove'\n     */\n    move(event)\n    {\n        // Controllo se sono settate le coordinate del touch all'evento start e bindo le nuove coordinate (ended)\n        !this.locked && this.prepareMove(event, ended => {\n            if(this.isPermissible())\n            {\n                event.preventDefault()\n                event.stopPropagation()\n\n                this.mooving = true\n                this.dispatch() // Smisto gli eventi 'mobili': pan, rotate, pitch\n            } else {\n                this.mooving = false // L'evento non può più essere prevenuto\n            }\n        })\n    }\n\n    /**\n     * Eseguo la funczione moove solo se sono settate le coordinate iniziali\n     */\n    prepareMove(event, callback)\n    {\n        this.started && callback.call( this, ( this.ended = this.utils.create(event, this.el) ) )\n        !this.started && this.clear()\n    }\n\n    /**\n     * Questa funzionalitò è molto importante poiché previene che l'evento 'touchmove'\n     * prevenga l'azione di default dell'evento (e quindi blocchi lo scrolling)\n     */\n    isPermissible()\n    {\n        let time = this.ended.time - this.started.time\n        let isHorizontal = this.utils.isHorizontal(this.started, this.ended); // Se lo scrolling è orizzontale implica che l'utente non sta scorrendo\n                                                                              // verticalmente la pagina, quindi è possibile bloccare lo scrolling\n        return this.mooving || (\n            this.mooving === null                              // Il caso in cui questa variabile risulta === null avviene solo la priva volta che viene invocata la fuonzione move,\n            && ( isHorizontal || time > ALOETOUCH_MIN_TIME )   // infatti viene nullata con la funzione clear presente nel metodo start. Questa cndizione è necessaria perché il metodo\n        )                                                      // preventDefault() di Event non può essere invocato in un secondo stadio dell'evento 'touchmove', ma solo la prima volta\n    }\n\n    /**\n     * Smisto gli eventi in 'touchmove' in base al numero di tocchi\n     */\n    dispatch()\n    {\n        let fingers = this.utils.howManyTouches(this.ended),\n            pan = null, pinch = null, rotate = null\n\n        if(fingers == 1) {\n            pan = Object.assign({}, this.utils.coords(this.started, this.ended), { fingers: 1 })\n        } else if(fingers == 2) {\n            pan = Object.assign({}, this.utils.coords(this.started, this.ended), { fingers: 2 }),\n            pinch = this.utils.distanceBetween(this.started, this.ended),\n            rotate = this.utils.rotation(this.started, this.ended)\n        }\n\n        this.setStateAndEmit({ pan, pinch, rotate, fingers })\n        this.emit('move', this.stateValue)\n    }\n\n    /**\n     * Setta i valore dello state ed emette gli eventi\n     *\n     * @param {Object} eventValues Valori da emettere\n     */\n    setStateAndEmit(eventValues, fingers)\n    {\n        this.stateValue = this.state.set(this.stateValue, eventValues, this.events.state)\n\n        fingers == 1 && eventValues.pan && this.pan(eventValues.pan)\n        fingers == 2 && eventValues.pan && this.pan2(eventValues.pan)\n        eventValues.pinch && this.pinch(eventValues.pinch)\n        eventValues.rotate && this.rotate(eventValues.rotate)\n    }\n\n\n    /**\n     * Termino l'evento\n     */\n    finish(event)\n    {\n        if(!this.locked && this.started)  // Controllo che vale anche per l'evento touchmove\n        {\n            this.mooving && this.swipe()\n            this.mooving === null && this.tap()\n\n            this.stateValue = this.state.refresh(this.stateValue, this.events.state) // aggiorno lo state\n\n            this.emit('end')\n        }\n\n        this.clear()\n    }\n\n    /**\n     * Reset delle variabili\n     */\n    clear()\n    {\n        this.pressEmitted && window.clearTimeout(this.pressEmitted) // Cancello l'evento press\n\n        this.started = null\n        this.ended = null\n        this.mooving = null\n        this.pressEmitted = null\n    }\n\n    /* -------------------------------------\n     *  Eventi\n     * ------------------------------------- */\n\n    /**\n     * Ritorna vero se questo oggetto è bloccato, falso altrimenti\n     *\n     * @return {Boolean}\n     */\n    isLock() {\n        return this.locked\n    }\n\n    /**\n     * Rimuove i listener degli eventi\n     */\n    lock()\n    {\n        if(!this.locked) {\n            this.off('touchstart', this.__start, true)\n            this.off('touchmove', this.__move)\n            this.off('touchend touchcancel', this.__finish, true)\n            this.locked = true\n        }\n    }\n\n    /**\n     * Binda gli eventi\n     */\n    unlock()\n    {\n        if(this.locked) {\n            this.on('touchstart', this.__start, true)\n            this.on('touchmove', this.__move)\n            this.on('touchend touchcancel', this.__finish, true)\n            this.locked = false\n        }\n    }\n\n    /* -------------------------------------\n     *  State\n     * ------------------------------------- */\n\n    /**\n     * Setta uno state\n     *\n     * @param {Object} state\n     */\n    setState(state)\n    {\n        Object.keys(state).forEach( s => this.events.state[s] = state[s] )\n    }\n\n    /**\n     * Ritorna i valori dello state corrente\n     */\n    getState()\n    {\n        return this.stateValue\n    }\n\n    /**\n     * Rimuove uno state\n     *\n     * @param {String} name Nome dello state da rimuovere\n     */\n    removeState(name)\n    {\n        this.state[name] = null\n        this.stateValue[name] = null\n        delete this.state[name]\n        delete this.stateValue[name]\n    }\n\n    /**\n     * Cancella lo state con ivalori correnti\n     */\n    clearState()\n    {\n        this.stateValue = this.state.create()\n    }\n\n    /* -------------------------------------\n     *  Eventi\n     * ------------------------------------- */\n\n    /**\n     * Valido l'evento tap\n     */\n    tap()\n    {\n        let fingers = this.utils.howManyTouches(this.ended)\n        let time = Date.now() - this.started.time\n        if( fingers < 2 && time < ALOETOUCH_PRESS_MIN_TIME )\n            this.emit('tap')\n    }\n\n    /**\n     * Evento press\n     */\n    press()\n    {\n        if(this.pressEmitted && !this.mooving) {\n            this.emit('press', null)\n            this.pressEmitted = null\n        }\n    }\n\n    /**\n     * Valido l'evento swipe\n     */\n    swipe()\n    {\n        let coords = this.utils.coords(this.started, this.ended)\n\n        if( Math.abs(coords.x) > ALOETOUCH_MIN_SWIPE_DISTANCE )\n        {\n            let stringDirection = this.utils.stringDirection(coords)\n\n            this.emit('swipe' + stringDirection.x, coords)\n            this.emit('swipe' + stringDirection.y, coords)\n            this.emit('swipe', { directions: stringDirection, coords })\n        }\n    }\n\n    /**\n     * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n\n     * @param {Object} coords\n     */\n    pan(coords)\n    {\n        this.emit('pan', coords)\n    }\n\n    /**\n     * L'evento pan non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n\n     * @param {Object} coords\n     */\n    pan2(coords)\n    {\n        this.emit('pan2', coords)\n    }\n\n    /**\n     * L'evento pinch non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n     *\n     * @param {Number} distance\n     */\n    pinch(distance)\n    {\n        this.emit('pinch', distance)\n    }\n\n    /**\n     * L'evento rotate non ha bisogno di validazioni, siccome sono state fatte nel metodo move\n     *\n     * @param {Number} rotation\n     */\n    rotate(rotation)\n    {\n        this.emit('rotate', rotation)\n    }\n\n    /* -------------------------------------\n     *  Bindaggio ed emissione eventi\n     * ------------------------------------- */\n\n    /**\n     * Emette un evento se settato\n     *\n     * @param {String} event Nome dell'evento da emettere\n     * @param {Object} data Dati da passare alla funzione settata per l'evento\n     */\n    emit(event, data)\n    {\n        if(this.events[event]) {\n            let result = this.events[event](data ? data : this.stateValue, data ? this.stateValue : null)\n\n            // Prevengo la gestione degli altri eventi se - nella funzione settata dall'utente - viene restituito il booleano false\n            return result === false && this.clear()\n        }\n    }\n\n    /**\n     * Aggiunge un evento\n     */\n    attach(events)\n    {\n        Object.keys(events).forEach( e => this.events[e] = events[e] )\n    }\n    /**\n     * Rimuove un evento\n     */\n    detach(events)\n    {\n        events = events.constructor.name === 'Array' ? events : [events]\n        events.forEach(e => this.events[e] && delete this.events[e])\n    }\n\n    /**\n     * Bindo gli eventi all'elemento\n     */\n    on(events, handler, passive)\n    {\n        events.split(' ').forEach( e => this.el.addEventListener(e, handler, passive ? { passive: true } : false) )\n    }\n\n    /**\n     * Rimuovo i listeners\n     */\n    off(events, handler, passive)\n    {\n        events.split(' ').forEach( e => this.el.removeEventListener(e, handler, passive ? { passive: true } : false) )\n    }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/AloeTouchObject.js","let State = {\n\n    /**\n     * Crea un oggetto vuoto per il contenimento dei valori degli eventi pan, pinch e rotate\n     */\n    new()\n    {\n        return {\n            pan: { x: null, y: null },\n            pinch: null,\n            rotate: null,\n            fingers: null\n        }\n    },\n\n    /**\n     * Crea un nuovo oggetto che conterra i valori precedenti degli eventi\n     */\n    create()\n    {\n        return Object.assign({}, State.new(), { old: State.new() })\n    },\n\n    /**\n     * Binda i nuovi valori dall'evento corrente (chiamato da touchmove->dispatch->emit) con i valori precendenti\n     *\n     * @param {ATS} state\n     * @param {ATEvent} event\n     */\n    set(state, event, customState)\n    {\n        event.fingers && ( state.fingers = event.fingers )\n        event.rotate && ( state.rotate = event.rotate + state.old.rotate )\n        event.pinch && ( state.pinch = event.pinch + state.old.pinch )\n        event.pan && event.pan.x && ( state.pan.x = event.pan.x + state.old.pan.x )\n        event.pan && event.pan.y && ( state.pan.y = event.pan.y + state.old.pan.y )\n\n        // Aggiungo gli state settati dall'utente\n        Object.keys(customState).forEach( cs => state[cs] = customState[cs](state) )\n\n        return state\n    },\n\n    /**\n     * All'evento touchend setto i valori precendeti con l'ultimo settato\n     *\n     * @param {ATS} state\n     */\n    refresh(state)\n    {\n        state.old = State.copyState(state)\n\n        return state\n    },\n\n    /**\n     * Copio l'oggetto state\n     */\n    copyState(state)\n    {\n        let n = {}\n        Object.keys(state).forEach( k => {\n            k != 'old' && ( n[k] = typeof(state[k]) === 'object' && state[k] !== null ? State.copyState(state[k]) : state[k] )\n        })\n        return n\n    }\n\n}\n\nexport default {\n    set: State.set,\n    create: State.create,\n    refresh: State.refresh\n}\n\n\n// WEBPACK FOOTER //\n// ./src/services/state.js","let Utils = {\n    /**\n     * Crea (o modifico) l'oggetto ATO (AloeTouchObject) contenente la Touchlist\n     *\n     * @param  {Event}      event\n     * @param  {DOMElement} element\n     * @param  {ATO?}       oldATO\n     */\n    create(event, element, oldATO)\n    {\n        let ATO = oldATO ? Object.assign({}, oldATO, { updated: true }) : { time: Date.now() }\n\n        ATO.touches = Utils.getTouches(event.touches ? event.touches : [event], element)\n\n        return ATO\n    },\n\n    /**\n     * Preleva la touchlist (modificata) dall'evento\n     *\n     * @param  {Touchlist}  touches [description]\n     * @param  {DOMElement} element L'emento esiste solo se è settato STRICT\n     * @return {Array}\n     */\n    getTouches(touches, element){\n        let data = []\n\n        Object.keys(touches).forEach(e => {\n            Utils.validate(touches[e], element) && data.push({\n                clientX: touches[e].clientX,\n                clientY: touches[e].clientY\n            })\n        })\n\n        return data\n    },\n\n    /**\n     * Aggiunge l'oggetto Touch se rispetta la validazone\n     *\n     * @param {Touch}      touch\n     * @param {DOMElement} element\n     */\n    validate(touch, element)\n    {\n        return touch && ( touch.clientX || touch.clientY ) && (!element || element == touch.target)\n    },\n\n    /**\n     * Ritorna la differenza delle coordinate tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    coords(ATOstart, ATOend)\n    {\n        return Utils.diff(ATOstart.touches[0], ATOend.touches[0])\n    },\n\n    /**\n     * Ritorna una coordinata basata sulla differenza tra due punti\n     *\n     * @param {ATO.touch} pointA\n     * @param {ATO.touch} pointB\n     */\n    diff(pointA, pointB)\n    {\n        return {\n            x: pointB.clientX - pointA.clientX,\n            y: pointB.clientY - pointA.clientY\n        }\n    },\n\n    /**\n     * Ritorna il numero di touch\n     *\n     * @param {ATO} ATOe\n     */\n    howManyTouches(ATO)\n    {\n        return ATO && ATO.touches ? ATO.touches.length : 0\n    },\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente verticale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isVertical(ATOstart, ATOend)\n    {\n        let coords = Utils.coords(ATOstart, ATOend)\n        return Math.abs(coords.y) > Math.abs(coords.x)\n    },\n\n\n    /**\n     * Ritorna true se la differenza tra le coordinate è principalmente orizzontale\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    isHorizontal(ATOstart, ATOend)\n    {\n        let coords = Utils.coords(ATOstart, ATOend)\n        return Math.abs(coords.x) > Math.abs(coords.y)\n    },\n\n    /**\n     * Ritorna la direzione in base al valore delle coordinate\n     *\n     * @param {Object{x,y} } coords\n     */\n    stringDirection(coords)\n    {\n        return {\n            x: coords.x <= 0 ? 'Left' : 'Right',\n            y: coords.y <= 0 ? 'Top' : 'Bottom'\n        }\n    },\n\n    /* -------------------------------------\n     *  Helper per eventi\n     * ------------------------------------- */\n\n    /**\n     * Ritorna la distanza tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    distanceBetween(ATOstart, ATOend)\n    {\n        return Utils.distance(ATOend) - Utils.distance(ATOstart)\n    },\n\n    /**\n     * Ritorna la distanza vettoriale tra due coordinata\n     *\n     * @param {ATO} ATO\n     */\n    distance(ATO)\n    {\n        let distance = Utils.diff(ATO.touches[0], ATO.touches[1])\n        return Utils.scalar(distance.x, distance.y)\n    },\n\n    /**\n     * Distanza scalare\n     */\n    scalar(a, b, nosqrt)\n    {\n        let s = Math.pow(a, 2) +  Math.pow(b, 2)\n        return nosqrt === false ? s : Math.sqrt(s)\n    },\n\n    /**\n     * Ritorna la direzione tangente tra due coordinate\n     *\n     * @param {ATO} ATO\n     */\n    direction(ATO)\n    {\n        let distance = Utils.diff(ATO.touches[0], ATO.touches[1])\n        return Utils.angle(distance.x, distance.y)\n    },\n\n    /**\n     * Angolo\n     */\n    angle(a, b) \n    {\n        return Math.atan2(b, a) * 180 / Math.PI\n    },\n\n    /**\n     * Ritorna l'angolo di rotazione tra due ATO\n     *\n     * @param {ATO} ATOstart\n     * @param {ATO} ATOend\n     */\n    rotation(ATOstart, ATOend)\n    {\n        return Utils.direction(ATOend) - Utils.direction(ATOstart)\n    }\n}\n\nexport default {\n    create: Utils.create,\n    coords: Utils.coords,\n    howManyTouches: Utils.howManyTouches,\n    isVertical: Utils.isVertical,\n    isHorizontal: Utils.isHorizontal,\n    stringDirection: Utils.stringDirection,\n    distanceBetween: Utils.distanceBetween,\n    direction: Utils.direction,\n    rotation: Utils.rotation,\n    angle: Utils.angle,\n    scalar: Utils.scalar\n}\n\n\n// WEBPACK FOOTER //\n// ./src/services/utils.js","import AloeTouch from './src/AloeTouch'\n\nwindow.AloeTouch = AloeTouch\n\n\n// WEBPACK FOOTER //\n// ./index.js"],"sourceRoot":""}